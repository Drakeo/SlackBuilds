diff -Naupr a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2021-06-07 01:41:30.000000000 +0200
+++ b/CMakeLists.txt	2021-08-13 13:03:08.000000000 +0200
@@ -194,6 +194,7 @@ set(libtorrent_aux_include_files
 	aligned_union.hpp
 	alloca.hpp
 	allocating_handler.hpp
+	apply_pad_files.hpp
 	array.hpp
 	bandwidth_limit.hpp
 	bandwidth_manager.hpp
diff -Naupr a/ChangeLog b/ChangeLog
--- a/ChangeLog	2021-06-07 01:41:30.000000000 +0200
+++ b/ChangeLog	2021-08-13 13:03:08.000000000 +0200
@@ -1,3 +1,8 @@
+	* fix use-after-free bug in make_magnet_uri
+	* add write_torrent_file() to produce a .torrent file from add_torrent_params
+	* allow loading v2 .torrent files without piece layer
+	* fix issue with adding v2 torrents with invalid file root hash
+
 * 2.0.4 released
 
 	* fix piece picker bug causing double-picks with prefer-contiguous enabled
@@ -71,6 +76,9 @@
 	* libtorrent now requires C++14 to build
 	* added support for GnuTLS for HTTPS and torrents over SSL
 
+	* fix issue on MacOS where the DHT was not restarted on a network-up notification
+	* make remove_torrent flags be treated as flags (instead of an enum)
+
 1.2.14 released
 
 	* improve handling of seed flag in PEX messages
diff -Naupr a/Jamfile b/Jamfile
--- a/Jamfile	2021-06-07 01:41:30.000000000 +0200
+++ b/Jamfile	2021-08-13 13:03:08.000000000 +0200
@@ -340,10 +340,6 @@ rule building ( properties * )
 		# probably not a production build anyway
 		&& ! <debug-iterators>on in $(properties)
 	{
-		# hide non-external symbols
-		result += <cflags>-fvisibility=hidden ;
-		result += <cxxflags>-fvisibility-inlines-hidden ;
-
 		if ( <toolset>gcc in $(properties) )
 		{
 			result += <linkflags>-Wl,-Bsymbolic ;
@@ -919,6 +915,7 @@ lib torrent
 	<threading>multi
 	<cxxstd>14
 	<c++-template-depth>512
+	<visibility>hidden
 
 	: # usage requirements
 	$(usage-requirements)
@@ -1058,21 +1055,21 @@ rule generate-pkg-config ( properties *
 rule install-pkg-config ( target-name : data * : requirements * )
 {
 	import stage ;
-    local p = [ install-paths $(requirements) ] ;
-    local libdir = $(p[0]) ;
+	local p = [ install-paths $(requirements) ] ;
+	local libdir = $(p[0]) ;
 
-    stage.install $(target-name)
-        : $(data)
-        : $(requirements) <location>$(libdir)/pkgconfig
-        ;
+	stage.install $(target-name)
+		: $(data)
+		: $(requirements) <location>$(libdir)/pkgconfig
+		;
 
 	import project ;
-    local c = [ project.current ] ;
-    local project-module = [ $(c).project-module ] ;
-    module $(project-module)
-    {
-        explicit $(1) ;
-    }
+	local c = [ project.current ] ;
+	local project-module = [ $(c).project-module ] ;
+	module $(project-module)
+	{
+		explicit $(1) ;
+	}
 }
 
 headers = [ path.glob-tree include/libtorrent : *.hpp ] ;
diff -Naupr a/Makefile b/Makefile
--- a/Makefile	2021-06-07 01:41:30.000000000 +0200
+++ b/Makefile	2021-08-13 13:03:08.000000000 +0200
@@ -562,6 +562,7 @@ HEADERS = \
   aux_/alloca.hpp                   \
   aux_/allocating_handler.hpp       \
   aux_/announce_entry.hpp           \
+  aux_/apply_pad_files.hpp          \
   aux_/array.hpp                    \
   aux_/bandwidth_limit.hpp          \
   aux_/bandwidth_manager.hpp        \
@@ -820,9 +821,11 @@ LIBSIM_TESTS = \
 
 TEST_SOURCES = \
   enum_if.cpp \
+  test_add_torrent.cpp \
   test_alert_manager.cpp \
   test_alert_types.cpp \
   test_alloca.cpp \
+  test_apply_pad.cpp \
   test_auto_unchoke.cpp \
   test_bandwidth_limiter.cpp \
   test_bdecode.cpp \
@@ -1024,6 +1027,7 @@ TEST_TORRENTS = \
   v2_deep_recursion.torrent \
   v2_non_multiple_piece_layer.torrent \
   v2_piece_layer_invalid_file_hash.torrent \
+  v2_incomplete_piece_layer.torrent \
   v2_invalid_pad_file.torrent \
   v2_invalid_piece_layer.torrent \
   v2_invalid_piece_layer_size.torrent \
@@ -1040,6 +1044,7 @@ TEST_TORRENTS = \
   v2_zero_root.torrent \
   v2_zero_root_small.torrent \
   v2_hybrid.torrent \
+  v2_invalid_root_hash.torrent \
   zero.torrent \
   zero2.torrent
 
diff -Naupr a/appveyor.yml b/appveyor.yml
--- a/appveyor.yml	1970-01-01 01:00:00.000000000 +0100
+++ b/appveyor.yml	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,107 @@
+version: "{build}"
+branches:
+  only:
+    - master
+    - RC_2_0
+    - RC_1_2
+    - RC_1_1
+image: Visual Studio 2017
+clone_depth: 1
+environment:
+  matrix:
+    - variant: debug
+      compiler: gcc
+      model: 32
+      crypto: openssl
+      ssl_lib: /usr/local/include
+      ssl_include: /usr/local/lib
+      lib: 1
+    - cmake: 1
+    - variant: release
+      compiler: msvc-14.1
+      model: 64
+      crypto: openssl
+      ssl_lib: c:\OpenSSL-v111-Win64\lib
+      ssl_include: c:\OpenSSL-v111-Win64\include
+      tests: 1
+
+artifacts:
+  - path: bindings/python/dist/*
+    name: python-module
+
+install:
+  - git submodule update --init --recursive
+  - set ROOT_DIRECTORY=%CD%
+  - cd %ROOT_DIRECTORY%
+  - if not defined api ( set api="desktop" )
+  - if not defined compiler ( set compiler="" )
+  - if not defined crypto ( set crypto=built-in )
+  - if not defined ssl_lib ( set ssl_lib=c:\ )
+  - if not defined ssl_include ( set ssl_include=c:\ )
+  - cd %ROOT_DIRECTORY%
+  - set BOOST_ROOT=c:\Libraries\boost_1_69_0
+  - set BOOST_BUILD_PATH=%BOOST_ROOT%\tools\build
+  - echo %BOOST_ROOT%
+  - echo %BOOST_BUILD_PATH%
+  - set PATH=%PATH%;%BOOST_BUILD_PATH%
+  - ps: '"using msvc : 14.1 ;`nusing gcc ;`nusing python : 3.6 : c:\\Python36-x64 : c:\\Python36-x64\\include : c:\\Python36-x64\\libs ;`n" | Set-Content $env:HOMEDRIVE\$env:HOMEPATH\user-config.jam'
+  - type %HOMEDRIVE%%HOMEPATH%\user-config.jam
+  - cd %ROOT_DIRECTORY%
+  - set PATH=c:\msys64\mingw32\bin;%PATH%
+  - g++ --version
+  - set PATH=c:\Python36-x64;%PATH%
+  - set PYTHON_INTERPRETER=c:\Python36-x64\python.exe
+  - python --version
+  - echo %ROOT_DIRECTORY%
+  - cd %BOOST_BUILD_PATH%
+  - bootstrap.bat >nul
+  - cd %ROOT_DIRECTORY%
+
+build_script:
+
+  # just the library
+  - cd %ROOT_DIRECTORY%
+  - if defined lib (
+    b2.exe --hash openssl-lib=%ssl_lib% openssl-include=%ssl_include% warnings=all warnings-as-errors=on %compiler% address-model=%model% picker-debugging=on invariant-checks=full variant=%variant% link=shared crypto=%crypto% asserts=on export-extra=on windows-api=%api% windows-version=win10 cxxstd=14
+    )
+
+  # test
+  - cd %ROOT_DIRECTORY%\test
+  - if defined tests (
+    b2.exe --hash openssl-lib=%ssl_lib% openssl-include=%ssl_include% warnings=all warnings-as-errors=on %compiler% address-model=%model% picker-debugging=on invariant-checks=full variant=%variant% link=shared crypto=%crypto% asserts=on export-extra=on windows-api=%api% windows-version=win10 testing.execute=off
+    )
+
+  # python binding
+  - cd %ROOT_DIRECTORY%\bindings\python
+  # we use 64 bit python builds
+  # boost.python itself doesn't build warning free, so we can't build
+  # with warnings-as-errors
+  - if defined python (
+    b2.exe --hash openssl-lib=%ssl_lib% openssl-include=%ssl_include% warnings=all %compiler% address-model=%model% picker-debugging=on invariant-checks=full variant=%variant% link=shared crypto=%crypto% asserts=on export-extra=on windows-api=%api% windows-version=win10 libtorrent-link=shared stage_module stage_dependencies
+    )
+  - if defined python_dist (
+    c:\Python36-x64\python.exe setup.py bdist --format=msi
+    )
+
+  # minimal support for cmake build
+  # we need to build the boost libraries we use with C++14
+  # and stage it for cmake to pick up
+  - if defined cmake (
+    cd %BOOST_ROOT% &&
+    bjam cxxstd=14 release --with-python --with-system --layout=system address-model=64 link=shared stage &&
+    cd %ROOT_DIRECTORY% &&
+    mkdir build &&
+    cd build &&
+    cmake -DBOOST_LIBRARYDIR=%BOOST_ROOT%\stage\lib -DCMAKE_CXX_STANDARD=14 -Dbuild_tests=ON -Dbuild_examples=ON -Dbuild_tools=ON -Dpython-bindings=%python% -Dboost-python-module-name="python" -Dskip-python-runtime-test=true -DPython_ADDITIONAL_VERSIONS="2.7" -G "Visual Studio 15 2017" -A x64 .. &&
+    cmake --build . --config Release --parallel %NUMBER_OF_PROCESSORS% -- -verbosity:minimal
+    )
+
+test_script:
+  - cd %ROOT_DIRECTORY%\test
+  - if defined tests (
+    appveyor-retry b2.exe -l500 --hash openssl-lib=%ssl_lib% openssl-include=%ssl_include% warnings=all warnings-as-errors=on %compiler% address-model=%model% picker-debugging=on invariant-checks=full variant=%variant% link=shared crypto=%crypto% asserts=on export-extra=on windows-api=%api% windows-version=win10
+    )
+
+  - if defined cmake (
+    appveyor-retry ctest
+    )
diff -Naupr a/bindings/Makefile.am b/bindings/Makefile.am
--- a/bindings/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ b/bindings/Makefile.am	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,4 @@
+
+SUBDIRS = python
+
+EXTRA_DIST = README.txt CMakeLists.txt
diff -Naupr a/bindings/README.txt b/bindings/README.txt
--- a/bindings/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ b/bindings/README.txt	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,3 @@
+Documentation covering building and using the python binding for libtorrent
+is located in the main doc directory. See docs/python_binding.html
+
diff -Naupr a/bindings/c/Jamfile b/bindings/c/Jamfile
--- a/bindings/c/Jamfile	1970-01-01 01:00:00.000000000 +0100
+++ b/bindings/c/Jamfile	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,38 @@
+use-project /torrent : ../.. ;
+
+rule libtorrent_linking ( properties * )
+{
+    local result ;
+
+    if <toolset>gcc in $(properties) && <link>shared in $(properties)
+    {
+        result += <fpic>on ;
+    }
+
+#    if <toolset>gcc in $(properties) || <toolset>darwin in $(properties)
+#    {
+#        result += <visibility>hidden ;
+#    }
+
+    return $(result) ;
+}
+
+lib torrentc
+
+    : # sources
+	 library.cpp
+
+	 : # requirements
+    <conditional>@libtorrent_linking
+    <library>/torrent//torrent/<link>static
+	 <include>.
+
+	 : # default build
+	 <link>static
+
+	 : # usage-requirements
+	 <include>.
+;
+
+exe simple_client : simple_client.c torrentc ;
+
diff -Naupr a/bindings/c/library.cpp b/bindings/c/library.cpp
--- a/bindings/c/library.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/bindings/c/library.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,606 @@
+/*
+
+Copyright (c) 2009, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/session.hpp"
+#include "libtorrent/session_status.hpp"
+#include "libtorrent/magnet_uri.hpp"
+#include "libtorrent/torrent_handle.hpp"
+
+#include <libtorrent.h>
+#include <stdarg.h>
+
+namespace
+{
+	std::vector<lt::torrent_handle> handles;
+
+	int find_handle(lt::torrent_handle h)
+	{
+		std::vector<lt::torrent_handle>::const_iterator i
+			= std::find(handles.begin(), handles.end(), h);
+		if (i == handles.end()) return -1;
+		return i - handles.begin();
+	}
+
+	lt::torrent_handle get_handle(int i)
+	{
+		if (i < 0 || i >= int(handles.size())) return lt::torrent_handle();
+		return handles[i];
+	}
+
+	int add_handle(lt::torrent_handle const& h)
+	{
+		std::vector<lt::torrent_handle>::iterator i = std::find_if(handles.begin()
+			, handles.end()
+			, [](lt::torrent_handle const& h) { return !h.is_valid(); });
+		if (i != handles.end())
+		{
+			*i = h;
+			return i - handles.begin();
+		}
+
+		handles.push_back(h);
+		return handles.size() - 1;
+	}
+
+	int set_int_value(void* dst, int* size, int val)
+	{
+		if (*size < sizeof(int)) return -2;
+		*((int*)dst) = val;
+		*size = sizeof(int);
+		return 0;
+	}
+
+	void copy_proxy_setting(lt::proxy_settings* s, proxy_setting const* ps)
+	{
+		s->hostname.assign(ps->hostname);
+		s->port = ps->port;
+		s->username.assign(ps->username);
+		s->password.assign(ps->password);
+		s->type = (lt::proxy_settings::proxy_type)ps->type;
+	}
+}
+
+extern "C"
+{
+
+TORRENT_EXPORT void* session_create(int tag, ...)
+{
+	using namespace lt;
+
+	va_list lp;
+	va_start(lp, tag);
+
+	fingerprint fing("LT", lt::version_major, lt::version_minor, lt::version_tiny, 0);
+	std::pair<int, int> listen_range(-1, -1);
+	char const* listen_interface = "0.0.0.0";
+	int flags = session::start_default_features | session::add_default_plugins;
+	int alert_mask = alert::error_notification;
+
+	while (tag != TAG_END)
+	{
+		switch (tag)
+		{
+			case SES_FINGERPRINT:
+			{
+				char const* f = va_arg(lp, char const*);
+				fing.name[0] = f[0];
+				fing.name[1] = f[1];
+				break;
+			}
+			case SES_LISTENPORT:
+				listen_range.first = va_arg(lp, int);
+				break;
+			case SES_LISTENPORT_END:
+				listen_range.second = va_arg(lp, int);
+				break;
+			case SES_VERSION_MAJOR:
+				fing.major_version = va_arg(lp, int);
+				break;
+			case SES_VERSION_MINOR:
+				fing.minor_version = va_arg(lp, int);
+				break;
+			case SES_VERSION_TINY:
+				fing.revision_version = va_arg(lp, int);
+				break;
+			case SES_VERSION_TAG:
+				fing.tag_version = va_arg(lp, int);
+				break;
+			case SES_FLAGS:
+				flags = va_arg(lp, int);
+				break;
+			case SES_ALERT_MASK:
+				alert_mask = va_arg(lp, int);
+				break;
+			case SES_LISTEN_INTERFACE:
+				listen_interface = va_arg(lp, char const*);
+				break;
+			default:
+				// skip unknown tags
+				va_arg(lp, void*);
+				break;
+		}
+
+		tag = va_arg(lp, int);
+	}
+
+	if (listen_range.first != -1 && (listen_range.second == -1
+		|| listen_range.second < listen_range.first))
+		listen_range.second = listen_range.first;
+
+	return new (std::nothrow) session(fing, listen_range, listen_interface, flags, alert_mask);
+}
+
+TORRENT_EXPORT void session_close(void* ses)
+{
+	delete (lt::session*)ses;
+}
+
+TORRENT_EXPORT int session_add_torrent(void* ses, int tag, ...)
+{
+	using namespace lt;
+
+	va_list lp;
+	va_start(lp, tag);
+	session* s = (session*)ses;
+	add_torrent_params params;
+
+	char const* torrent_data = 0;
+	int torrent_size = 0;
+
+	char const* resume_data = 0;
+	int resume_size = 0;
+
+	char const* magnet_url = 0;
+
+	error_code ec;
+
+	while (tag != TAG_END)
+	{
+		switch (tag)
+		{
+			case TOR_FILENAME:
+				params.ti.reset(new (std::nothrow) torrent_info(va_arg(lp, char const*), ec));
+				break;
+			case TOR_TORRENT:
+				torrent_data = va_arg(lp, char const*);
+				break;
+			case TOR_TORRENT_SIZE:
+				torrent_size = va_arg(lp, int);
+				break;
+			case TOR_INFOHASH:
+				params.ti.reset(new (std::nothrow) torrent_info(sha1_hash(va_arg(lp, char const*))));
+				break;
+			case TOR_INFOHASH_HEX:
+			{
+				sha1_hash ih;
+				from_hex(va_arg(lp, char const*), 40, (char*)&ih[0]);
+				params.ti.reset(new (std::nothrow) torrent_info(ih));
+				break;
+			}
+			case TOR_MAGNETLINK:
+				magnet_url = va_arg(lp, char const*);
+				break;
+			case TOR_TRACKER_URL:
+				params.tracker_url = va_arg(lp, char const*);
+				break;
+			case TOR_RESUME_DATA:
+				resume_data = va_arg(lp, char const*);
+				break;
+			case TOR_RESUME_DATA_SIZE:
+				resume_size = va_arg(lp, int);
+				break;
+			case TOR_SAVE_PATH:
+				params.save_path = va_arg(lp, char const*);
+				break;
+			case TOR_NAME:
+				params.name = va_arg(lp, char const*);
+				break;
+			case TOR_PAUSED:
+				params.paused = va_arg(lp, int) != 0;
+				break;
+			case TOR_AUTO_MANAGED:
+				params.auto_managed = va_arg(lp, int) != 0;
+				break;
+			case TOR_DUPLICATE_IS_ERROR:
+				params.duplicate_is_error = va_arg(lp, int) != 0;
+				break;
+			case TOR_USER_DATA:
+				params.userdata = va_arg(lp, void*);
+				break;
+			case TOR_SEED_MODE:
+				params.seed_mode = va_arg(lp, int) != 0;
+				break;
+			case TOR_OVERRIDE_RESUME_DATA:
+				params.override_resume_data = va_arg(lp, int) != 0;
+				break;
+			case TOR_STORAGE_MODE:
+				params.storage_mode = (lt::storage_mode_t)va_arg(lp, int);
+				break;
+			default:
+				// ignore unknown tags
+				va_arg(lp, void*);
+				break;
+		}
+
+		tag = va_arg(lp, int);
+	}
+
+	if (!params.ti && torrent_data && torrent_size)
+		params.ti.reset(new (std::nothrow) torrent_info(torrent_data, torrent_size));
+
+	std::vector<char> rd;
+	if (resume_data && resume_size)
+	{
+		params.resume_data.assign(resume_data, resume_data + resume_size);
+	}
+	torrent_handle h;
+	if (!params.ti && magnet_url)
+	{
+		h = add_magnet_uri(*s, magnet_url, params, ec);
+	}
+	else
+	{
+		h = s->add_torrent(params, ec);
+	}
+
+	if (!h.is_valid())
+	{
+		return -1;
+	}
+
+	int i = find_handle(h);
+	if (i == -1) i = add_handle(h);
+
+	return i;
+}
+
+TORRENT_EXPORT void session_remove_torrent(void* ses, int tor, int flags)
+{
+	using namespace lt;
+	torrent_handle h = get_handle(tor);
+	if (!h.is_valid()) return;
+
+	session* s = (session*)ses;
+	s->remove_torrent(h, flags);
+}
+
+TORRENT_EXPORT int session_pop_alert(void* ses, char* dest, int len, int* category)
+{
+	using namespace lt;
+
+	session* s = (session*)ses;
+
+	std::auto_ptr<alert> a = s->pop_alert();
+	if (!a.get()) return -1;
+
+	if (category) *category = a->category();
+	strncpy(dest, a->message().c_str(), len - 1);
+	dest[len - 1] = 0;
+
+	return 0; // for now
+}
+
+TORRENT_EXPORT int session_set_settings(void* ses, int tag, ...)
+{
+	using namespace lt;
+
+	session* s = (session*)ses;
+
+	va_list lp;
+	va_start(lp, tag);
+
+	while (tag != TAG_END)
+	{
+		switch (tag)
+		{
+			case SET_UPLOAD_RATE_LIMIT:
+				s->set_upload_rate_limit(va_arg(lp, int));
+				break;
+			case SET_DOWNLOAD_RATE_LIMIT:
+				s->set_download_rate_limit(va_arg(lp, int));
+				break;
+			case SET_LOCAL_UPLOAD_RATE_LIMIT:
+				s->set_local_upload_rate_limit(va_arg(lp, int));
+				break;
+			case SET_LOCAL_DOWNLOAD_RATE_LIMIT:
+				s->set_local_download_rate_limit(va_arg(lp, int));
+				break;
+			case SET_MAX_UPLOAD_SLOTS:
+				s->set_max_uploads(va_arg(lp, int));
+				break;
+			case SET_MAX_CONNECTIONS:
+				s->set_max_connections(va_arg(lp, int));
+				break;
+			case SET_HALF_OPEN_LIMIT:
+				s->set_max_half_open_connections(va_arg(lp, int));
+				break;
+			case SET_PEER_PROXY:
+			{
+				lt::proxy_settings ps;
+				copy_proxy_setting(&ps, va_arg(lp, struct proxy_setting const*));
+				s->set_peer_proxy(ps);
+			}
+			case SET_WEB_SEED_PROXY:
+			{
+				lt::proxy_settings ps;
+				copy_proxy_setting(&ps, va_arg(lp, struct proxy_setting const*));
+				s->set_web_seed_proxy(ps);
+			}
+			case SET_TRACKER_PROXY:
+			{
+				lt::proxy_settings ps;
+				copy_proxy_setting(&ps, va_arg(lp, struct proxy_setting const*));
+				s->set_tracker_proxy(ps);
+			}
+			case SET_ALERT_MASK:
+			{
+				s->set_alert_mask(va_arg(lp, int));
+			}
+#ifndef TORRENT_DISABLE_DHT
+			case SET_DHT_PROXY:
+			{
+				lt::proxy_settings ps;
+				copy_proxy_setting(&ps, va_arg(lp, struct proxy_setting const*));
+				s->set_dht_proxy(ps);
+			}
+#endif
+			case SET_PROXY:
+			{
+				lt::proxy_settings ps;
+				copy_proxy_setting(&ps, va_arg(lp, struct proxy_setting const*));
+				s->set_peer_proxy(ps);
+				s->set_web_seed_proxy(ps);
+				s->set_tracker_proxy(ps);
+#ifndef TORRENT_DISABLE_DHT
+				s->set_dht_proxy(ps);
+#endif
+			}
+			default:
+				// ignore unknown tags
+				va_arg(lp, void*);
+				break;
+		}
+
+		tag = va_arg(lp, int);
+	}
+	return 0;
+}
+
+TORRENT_EXPORT int session_get_setting(void* ses, int tag, void* value, int* value_size)
+{
+	using namespace lt;
+	session* s = (session*)ses;
+
+	switch (tag)
+	{
+		case SET_UPLOAD_RATE_LIMIT:
+			return set_int_value(value, value_size, s->upload_rate_limit());
+		case SET_DOWNLOAD_RATE_LIMIT:
+			return set_int_value(value, value_size, s->download_rate_limit());
+		case SET_LOCAL_UPLOAD_RATE_LIMIT:
+			return set_int_value(value, value_size, s->local_upload_rate_limit());
+		case SET_LOCAL_DOWNLOAD_RATE_LIMIT:
+			return set_int_value(value, value_size, s->local_download_rate_limit());
+		case SET_MAX_UPLOAD_SLOTS:
+			return set_int_value(value, value_size, s->max_uploads());
+		case SET_MAX_CONNECTIONS:
+			return set_int_value(value, value_size, s->max_connections());
+		case SET_HALF_OPEN_LIMIT:
+			return set_int_value(value, value_size, s->max_half_open_connections());
+		default:
+			return -2;
+	}
+}
+
+TORRENT_EXPORT int session_get_status(void* sesptr, struct session_status* s, int struct_size)
+{
+	lt::session* ses = (lt::session*)sesptr;
+
+	lt::session_status ss = ses->status();
+	if (struct_size != sizeof(session_status)) return -1;
+
+	s->has_incoming_connections = ss.has_incoming_connections;
+
+	s->upload_rate = ss.upload_rate;
+	s->download_rate = ss.download_rate;
+	s->total_download = ss.total_download;
+	s->total_upload = ss.total_upload;
+
+	s->payload_upload_rate = ss.payload_upload_rate;
+	s->payload_download_rate = ss.payload_download_rate;
+	s->total_payload_download = ss.total_payload_download;
+	s->total_payload_upload = ss.total_payload_upload;
+
+	s->ip_overhead_upload_rate = ss.ip_overhead_upload_rate;
+	s->ip_overhead_download_rate = ss.ip_overhead_download_rate;
+	s->total_ip_overhead_download = ss.total_ip_overhead_download;
+	s->total_ip_overhead_upload = ss.total_ip_overhead_upload;
+
+	s->dht_upload_rate = ss.dht_upload_rate;
+	s->dht_download_rate = ss.dht_download_rate;
+	s->total_dht_download = ss.total_dht_download;
+	s->total_dht_upload = ss.total_dht_upload;
+
+	s->tracker_upload_rate = ss.tracker_upload_rate;
+	s->tracker_download_rate = ss.tracker_download_rate;
+	s->total_tracker_download = ss.total_tracker_download;
+	s->total_tracker_upload = ss.total_tracker_upload;
+
+	s->total_redundant_bytes = ss.total_redundant_bytes;
+	s->total_failed_bytes = ss.total_failed_bytes;
+
+	s->num_peers = ss.num_peers;
+	s->num_unchoked = ss.num_unchoked;
+	s->allowed_upload_slots = ss.allowed_upload_slots;
+
+	s->up_bandwidth_queue = ss.up_bandwidth_queue;
+	s->down_bandwidth_queue = ss.down_bandwidth_queue;
+
+	s->up_bandwidth_bytes_queue = ss.up_bandwidth_bytes_queue;
+	s->down_bandwidth_bytes_queue = ss.down_bandwidth_bytes_queue;
+
+	s->optimistic_unchoke_counter = ss.optimistic_unchoke_counter;
+	s->unchoke_counter = ss.unchoke_counter;
+
+	s->dht_nodes = ss.dht_nodes;
+	s->dht_node_cache = ss.dht_node_cache;
+	s->dht_torrents = ss.dht_torrents;
+	s->dht_global_nodes = ss.dht_global_nodes;
+	return 0;
+}
+
+TORRENT_EXPORT int torrent_get_status(int tor, torrent_status* s, int struct_size)
+{
+	lt::torrent_handle h = get_handle(tor);
+	if (!h.is_valid()) return -1;
+
+	lt::torrent_status ts = h.status();
+
+	if (struct_size != sizeof(torrent_status)) return -1;
+
+	s->state = (state_t)ts.state;
+	s->paused = ts.paused;
+	s->progress = ts.progress;
+	strncpy(s->error, ts.error.c_str(), 1025);
+	s->next_announce = lt::total_seconds(ts.next_announce);
+	s->announce_interval = lt::total_seconds(ts.announce_interval);
+	strncpy(s->current_tracker, ts.current_tracker.c_str(), 512);
+	s->total_download = ts.total_download = ts.total_download = ts.total_download;
+	s->total_upload = ts.total_upload = ts.total_upload = ts.total_upload;
+	s->total_payload_download = ts.total_payload_download;
+	s->total_payload_upload = ts.total_payload_upload;
+	s->total_failed_bytes = ts.total_failed_bytes;
+	s->total_redundant_bytes = ts.total_redundant_bytes;
+	s->download_rate = ts.download_rate;
+	s->upload_rate = ts.upload_rate;
+	s->download_payload_rate = ts.download_payload_rate;
+	s->upload_payload_rate = ts.upload_payload_rate;
+	s->num_seeds = ts.num_seeds;
+	s->num_peers = ts.num_peers;
+	s->num_complete = ts.num_complete;
+	s->num_incomplete = ts.num_incomplete;
+	s->list_seeds = ts.list_seeds;
+	s->list_peers = ts.list_peers;
+	s->connect_candidates = ts.connect_candidates;
+	s->num_pieces = ts.num_pieces;
+	s->total_done = ts.total_done;
+	s->total_wanted_done = ts.total_wanted_done;
+	s->total_wanted = ts.total_wanted;
+	s->distributed_copies = ts.distributed_copies;
+	s->block_size = ts.block_size;
+	s->num_uploads = ts.num_uploads;
+	s->num_connections = ts.num_connections;
+	s->uploads_limit = ts.uploads_limit;
+	s->connections_limit = ts.connections_limit;
+//	s->storage_mode = (storage_mode_t)ts.storage_mode;
+	s->up_bandwidth_queue = ts.up_bandwidth_queue;
+	s->down_bandwidth_queue = ts.down_bandwidth_queue;
+	s->all_time_upload = ts.all_time_upload;
+	s->all_time_download = ts.all_time_download;
+	s->active_time = ts.active_time;
+	s->seeding_time = ts.seeding_time;
+	s->seed_rank = ts.seed_rank;
+	s->last_scrape = ts.last_scrape;
+	s->has_incoming = ts.has_incoming;
+	s->seed_mode = ts.seed_mode;
+	return 0;
+}
+
+TORRENT_EXPORT int torrent_set_settings(int tor, int tag, ...)
+{
+	using namespace lt;
+	torrent_handle h = get_handle(tor);
+	if (!h.is_valid()) return -1;
+
+	va_list lp;
+	va_start(lp, tag);
+
+	while (tag != TAG_END)
+	{
+		switch (tag)
+		{
+			case SET_UPLOAD_RATE_LIMIT:
+				h.set_upload_limit(va_arg(lp, int));
+				break;
+			case SET_DOWNLOAD_RATE_LIMIT:
+				h.set_download_limit(va_arg(lp, int));
+				break;
+			case SET_MAX_UPLOAD_SLOTS:
+				h.set_max_uploads(va_arg(lp, int));
+				break;
+			case SET_MAX_CONNECTIONS:
+				h.set_max_connections(va_arg(lp, int));
+				break;
+			case SET_SEQUENTIAL_DOWNLOAD:
+				h.set_sequential_download(va_arg(lp, int) != 0);
+				break;
+			case SET_SUPER_SEEDING:
+				h.super_seeding(va_arg(lp, int) != 0);
+				break;
+			default:
+				// ignore unknown tags
+				va_arg(lp, void*);
+				break;
+		}
+
+		tag = va_arg(lp, int);
+	}
+	return 0;
+}
+
+TORRENT_EXPORT int torrent_get_setting(int tor, int tag, void* value, int* value_size)
+{
+	using namespace lt;
+	torrent_handle h = get_handle(tor);
+	if (!h.is_valid()) return -1;
+
+	switch (tag)
+	{
+		case SET_UPLOAD_RATE_LIMIT:
+			return set_int_value(value, value_size, h.upload_limit());
+		case SET_DOWNLOAD_RATE_LIMIT:
+			return set_int_value(value, value_size, h.download_limit());
+		case SET_MAX_UPLOAD_SLOTS:
+			return set_int_value(value, value_size, h.max_uploads());
+		case SET_MAX_CONNECTIONS:
+			return set_int_value(value, value_size, h.max_connections());
+		case SET_SEQUENTIAL_DOWNLOAD:
+			return set_int_value(value, value_size, h.is_sequential_download());
+		case SET_SUPER_SEEDING:
+			return set_int_value(value, value_size, h.super_seeding());
+		default:
+			return -2;
+	}
+}
+
+} // extern "C"
+
diff -Naupr a/bindings/c/libtorrent.h b/bindings/c/libtorrent.h
--- a/bindings/c/libtorrent.h	1970-01-01 01:00:00.000000000 +0100
+++ b/bindings/c/libtorrent.h	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,296 @@
+/*
+
+Copyright (c) 2009, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef LIBTORRENT_H
+#define LIBTORRENT_H
+
+enum tags
+{
+	TAG_END = 0,
+
+	SES_FINGERPRINT, // char const*, 2 character string
+	SES_LISTENPORT, // int
+	SES_LISTENPORT_END, // int
+	SES_VERSION_MAJOR, // int
+	SES_VERSION_MINOR, // int
+	SES_VERSION_TINY, // int
+	SES_VERSION_TAG, // int
+	SES_FLAGS, // int
+	SES_ALERT_MASK, // int
+	SES_LISTEN_INTERFACE, // char const*
+
+	// === add_torrent tags ===
+
+	// identifying the torrent to add
+	TOR_FILENAME = 0x100, // char const*
+	TOR_TORRENT, // char const*, specify size of buffer with TOR_TORRENT_SIZE
+	TOR_TORRENT_SIZE, // int
+	TOR_INFOHASH, // char const*, must point to a 20 byte array
+	TOR_INFOHASH_HEX, // char const*, must point to a 40 byte string
+	TOR_MAGNETLINK, // char const*, url
+
+	TOR_TRACKER_URL, // char const*
+	TOR_RESUME_DATA, // char const*
+	TOR_RESUME_DATA_SIZE, // int
+	TOR_SAVE_PATH, // char const*
+	TOR_NAME, // char const*
+	TOR_PAUSED, // int
+	TOR_AUTO_MANAGED, // int
+	TOR_DUPLICATE_IS_ERROR, // int
+	TOR_USER_DATA, //void*
+	TOR_SEED_MODE, // int
+	TOR_OVERRIDE_RESUME_DATA, // int
+	TOR_STORAGE_MODE, // int
+
+	SET_UPLOAD_RATE_LIMIT = 0x200, // int
+	SET_DOWNLOAD_RATE_LIMIT, // int
+	SET_LOCAL_UPLOAD_RATE_LIMIT, // int
+	SET_LOCAL_DOWNLOAD_RATE_LIMIT, // int
+	SET_MAX_UPLOAD_SLOTS, // int
+	SET_MAX_CONNECTIONS, // int
+	SET_SEQUENTIAL_DOWNLOAD, // int, torrent only
+	SET_SUPER_SEEDING, // int, torrent only
+	SET_HALF_OPEN_LIMIT, // int, session only
+	SET_PEER_PROXY, // proxy_setting const*, session_only
+	SET_WEB_SEED_PROXY, // proxy_setting const*, session_only
+	SET_TRACKER_PROXY, // proxy_setting const*, session_only
+	SET_DHT_PROXY, // proxy_setting const*, session_only
+	SET_PROXY, // proxy_setting const*, session_only
+	SET_ALERT_MASK, // int, session_only
+};
+
+struct proxy_setting
+{
+	char hostname[256];
+	int port;
+
+	char username[256];
+	char password[256];
+
+	int type;
+};
+
+enum category_t
+{
+	cat_error = 0x1,
+	cat_peer = 0x2,
+	cat_port_mapping = 0x4,
+	cat_storage = 0x8,
+	cat_tracker = 0x10,
+	cat_debug = 0x20,
+	cat_status = 0x40,
+	cat_progress = 0x80,
+	cat_ip_block = 0x100,
+	cat_performance_warning = 0x200,
+	cat_dht = 0x400,
+
+	cat_all_categories = 0xffffffff
+};
+
+enum proxy_type_t
+{
+	proxy_none,
+	proxy_socks4,
+	proxy_socks5,
+	proxy_socks5_pw,
+	proxy_http,
+	proxy_http_pw
+};
+
+enum storage_mode_t
+{
+	storage_mode_allocate = 0,
+	storage_mode_sparse
+};
+
+enum state_t
+{
+	queued_for_checking,
+	checking_files,
+	downloading_metadata,
+	downloading,
+	finished,
+	seeding,
+	allocating,
+	checking_resume_data
+};
+
+struct torrent_status
+{
+	enum state_t state;
+	int paused;
+	float progress;
+	char error[1024];
+	int next_announce;
+	int announce_interval;
+	char current_tracker[512];
+	long long total_download;
+	long long total_upload;
+	long long total_payload_download;
+	long long total_payload_upload;
+	long long total_failed_bytes;
+	long long total_redundant_bytes;
+	float download_rate;
+	float upload_rate;
+	float download_payload_rate;
+	float upload_payload_rate;
+	int num_seeds;
+	int num_peers;
+	int num_complete;
+	int num_incomplete;
+	int list_seeds;
+	int list_peers;
+	int connect_candidates;
+
+	// what to do?	
+//	bitfield pieces;
+
+	int num_pieces;
+	long long total_done;
+	long long total_wanted_done;
+	long long total_wanted;
+	float distributed_copies;
+	int block_size;
+	int num_uploads;
+	int num_connections;
+	int uploads_limit;
+	int connections_limit;
+//	enum storage_mode_t storage_mode;
+	int up_bandwidth_queue;
+	int down_bandwidth_queue;
+	long long all_time_upload;
+	long long all_time_download;
+	int active_time;
+	int seeding_time;
+	int seed_rank;
+	int last_scrape;
+	int has_incoming;
+	int seed_mode;
+};
+
+struct session_status
+{
+	int has_incoming_connections;
+
+	float upload_rate;
+	float download_rate;
+	long long total_download;
+	long long total_upload;
+
+	float payload_upload_rate;
+	float payload_download_rate;
+	long long total_payload_download;
+	long long total_payload_upload;
+
+	float ip_overhead_upload_rate;
+	float ip_overhead_download_rate;
+	long long total_ip_overhead_download;
+	long long total_ip_overhead_upload;
+
+	float dht_upload_rate;
+	float dht_download_rate;
+	long long total_dht_download;
+	long long total_dht_upload;
+
+	float tracker_upload_rate;
+	float tracker_download_rate;
+	long long total_tracker_download;
+	long long total_tracker_upload;
+
+	long long total_redundant_bytes;
+	long long total_failed_bytes;
+
+	int num_peers;
+	int num_unchoked;
+	int allowed_upload_slots;
+
+	int up_bandwidth_queue;
+	int down_bandwidth_queue;
+
+	int up_bandwidth_bytes_queue;
+	int down_bandwidth_bytes_queue;
+
+	int optimistic_unchoke_counter;
+	int unchoke_counter;
+
+	int dht_nodes;
+	int dht_node_cache;
+	int dht_torrents;
+	long long dht_global_nodes;
+//	std::vector<dht_lookup> active_requests;
+};
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+// the functions whose signature ends with:
+// , int first_tag, ...);
+// takes a tag list. The tag list is a series
+// of tag-value pairs. The tags are constants
+// identifying which property the value controls.
+// The type of the value varies between tags.
+// The enumeration above specifies which type
+// it expects. All tag lists must always be
+// terminated by TAG_END.
+
+// use SES_* tags in tag list
+void* session_create(int first_tag, ...);
+void session_close(void* ses);
+
+// use TOR_* tags in tag list
+int session_add_torrent(void* ses, int first_tag, ...);
+void session_remove_torrent(void* ses, int tor, int flags);
+
+// return < 0 if there are no alerts. Otherwise returns the
+// type of alert that was returned
+int session_pop_alert(void* ses, char* dest, int len, int* category);
+
+int session_get_status(void* ses, struct session_status* s, int struct_size);
+
+// use SET_* tags in tag list
+int session_set_settings(void* ses, int first_tag, ...);
+int session_get_setting(void* ses, int tag, void* value, int* value_size);
+
+int torrent_get_status(int tor, struct torrent_status* s, int struct_size);
+
+// use SET_* tags in tag list
+int torrent_set_settings(int tor, int first_tag, ...);
+int torrent_get_setting(int tor, int tag, void* value, int* value_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -Naupr a/bindings/c/simple_client.c b/bindings/c/simple_client.c
--- a/bindings/c/simple_client.c	1970-01-01 01:00:00.000000000 +0100
+++ b/bindings/c/simple_client.c	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,123 @@
+/*
+
+Copyright (c) 2009, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <libtorrent.h>
+#include <stdio.h>
+#include <signal.h>
+#include <unistd.h>
+#include <string.h>
+
+int quit = 0;
+
+void stop(int signal)
+{
+	quit = 1;
+}
+
+int main(int argc, char* argv[])
+{
+	if (argc != 2)
+	{
+		fprintf(stderr, "usage: ./simple_client torrent-file\n");
+		return 1;
+	}
+
+	int ret = 0;
+	void* ses = session_create(
+		SES_LISTENPORT, 6881,
+		SES_LISTENPORT_END, 6889,
+		SES_ALERT_MASK, ~(cat_progress | cat_port_mapping | cat_debug | cat_performance_warning | cat_peer),
+		TAG_END);
+
+	int t = session_add_torrent(ses,
+		TOR_FILENAME, argv[1],
+		TOR_SAVE_PATH, "./",
+		TAG_END);
+
+	if (t < 0)
+	{
+		fprintf(stderr, "Failed to add torrent\n");
+		ret = 1;
+		goto exit;
+	}
+
+	struct torrent_status st;
+
+	printf("press ctrl-C to stop\n");
+
+	signal(SIGINT, &stop);
+	signal(SIGABRT, &stop);
+	signal(SIGQUIT, &stop);
+
+	while (quit == 0)
+	{
+		char const* message = "";
+
+		char const* state[] = {"queued", "checking", "downloading metadata"
+			, "downloading", "finished", "seeding", "allocating"
+			, "checking_resume_data"};
+
+		if (torrent_get_status(t, &st, sizeof(st)) < 0) break;
+		printf("\r%3.f%% %d kB (%5.f kB/s) up: %d kB (%5.f kB/s) peers: %d '%s' %s  "
+			, (double)st.progress * 100.
+			, (int)(st.total_payload_download / 1000)
+			, (double)st.download_payload_rate / 1000.
+			, (int)(st.total_payload_upload / 1000)
+			, (double)st.upload_payload_rate / 1000.
+			, st.num_peers
+			, state[st.state]
+			, message);
+
+
+		char msg[400];
+		while (session_pop_alert(ses, msg, sizeof(msg), 0) >= 0)
+		{
+			printf("%s\n", msg);
+		}
+
+		if (strlen(st.error) > 0)
+		{
+			fprintf(stderr, "\nERROR: %s\n", st.error);
+			break;
+		}
+
+		fflush(stdout);
+		usleep(1000000);
+	}
+	printf("\nclosing\n");
+
+exit:
+
+	session_close(ses);
+	return ret;
+}
+
diff -Naupr a/bindings/python/CMakeLists.txt b/bindings/python/CMakeLists.txt
--- a/bindings/python/CMakeLists.txt	2021-06-07 01:41:30.000000000 +0200
+++ b/bindings/python/CMakeLists.txt	2021-08-13 13:03:08.000000000 +0200
@@ -49,6 +49,7 @@ Python3_add_library(python-libtorrent MO
 	src/entry.cpp
 	src/error_code.cpp
 	src/fingerprint.cpp
+	src/info_hash.cpp
 	src/ip_filter.cpp
 	src/magnet_uri.cpp
 	src/module.cpp
@@ -56,6 +57,7 @@ Python3_add_library(python-libtorrent MO
 	src/session.cpp
 	src/session_settings.cpp
 	src/sha1_hash.cpp
+	src/sha256_hash.cpp
 	src/string.cpp
 	src/torrent_handle.cpp
 	src/torrent_info.cpp
diff -Naupr a/bindings/python/dummy_data.py b/bindings/python/dummy_data.py
--- a/bindings/python/dummy_data.py	1970-01-01 01:00:00.000000000 +0100
+++ b/bindings/python/dummy_data.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,34 @@
+import libtorrent as lt
+
+import hashlib
+import random
+
+PIECE_LENGTH = 16384
+NAME = b"test.txt"
+LEN = PIECE_LENGTH * 9 + 1000
+# Use 7-bit data so we can test piece data as either bytes or str
+DATA = bytes(random.getrandbits(7) for _ in range(LEN))
+PIECES = [DATA[i:i + PIECE_LENGTH] for i in range(0, LEN, PIECE_LENGTH)]
+
+INFO_DICT = {
+        b"name": NAME,
+        b"piece length": PIECE_LENGTH,
+        b"length": len(DATA),
+        b"pieces": b"".join(hashlib.sha1(p).digest() for p in PIECES),
+    }
+
+DICT = {
+    b"info": INFO_DICT,
+}
+
+
+def get_infohash_bytes():
+    return hashlib.sha1(lt.bencode(INFO_DICT)).digest()
+
+
+def get_infohash():
+    return get_infohash_bytes().hex()
+
+
+def get_sha1_hash():
+    return lt.sha1_hash(get_infohash_bytes())
diff -Naupr a/bindings/python/src/create_torrent.cpp b/bindings/python/src/create_torrent.cpp
--- a/bindings/python/src/create_torrent.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/bindings/python/src/create_torrent.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -169,9 +169,18 @@ void bind_create_torrent()
         .def("file_path", file_storage_file_path, (arg("idx"), arg("save_path") = ""))
         .def("file_name", file_storage_file_name)
         .def("file_size", file_storage_file_size)
+        .def("root", &file_storage::root)
         .def("file_offset", file_storage_file_offset)
         .def("file_flags", file_storage_file_flags)
 
+        .def("file_index_for_root", &file_storage::file_index_for_root)
+        .def("piece_index_at_file", &file_storage::piece_index_at_file)
+        .def("file_index_at_piece", &file_storage::file_index_at_piece)
+        .def("file_index_at_offset", &file_storage::file_index_at_offset)
+        .def("file_absolute_path", &file_storage::file_absolute_path)
+
+        .def("v2", &file_storage::v2)
+
         .def("total_size", &file_storage::total_size)
         .def("set_num_pieces", &file_storage::set_num_pieces)
         .def("num_pieces", &file_storage::num_pieces)
diff -Naupr a/bindings/python/src/torrent_handle.cpp b/bindings/python/src/torrent_handle.cpp
--- a/bindings/python/src/torrent_handle.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/bindings/python/src/torrent_handle.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -236,11 +236,7 @@ void add_tracker(torrent_handle& h, dict
 
 namespace
 {
-#if defined BOOST_ASIO_HAS_STD_CHRONO
    using std::chrono::system_clock;
-#else
-   using boost::chrono::system_clock;
-#endif
 
    object to_ptime(time_point tpt)
    {
diff -Naupr a/bindings/python/src/torrent_status.cpp b/bindings/python/src/torrent_status.cpp
--- a/bindings/python/src/torrent_status.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/bindings/python/src/torrent_status.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -61,6 +61,7 @@ void bind_torrent_status()
         .add_property("verified_pieces", make_getter(&torrent_status::verified_pieces, by_value()))
         .def_readonly("num_pieces", &torrent_status::num_pieces)
         .def_readonly("total_done", &torrent_status::total_done)
+        .def_readonly("total", &torrent_status::total)
         .def_readonly("total_wanted_done", &torrent_status::total_wanted_done)
         .def_readonly("total_wanted", &torrent_status::total_wanted)
         .def_readonly("distributed_full_copies", &torrent_status::distributed_full_copies)
diff -Naupr a/bindings/python/test.py b/bindings/python/test.py
--- a/bindings/python/test.py	1970-01-01 01:00:00.000000000 +0100
+++ b/bindings/python/test.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,1141 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+
+import libtorrent as lt
+
+import unittest
+import time
+import datetime
+import os
+import shutil
+import binascii
+import subprocess as sub
+import sys
+import pickle
+import threading
+import tempfile
+import socket
+import select
+
+import dummy_data
+
+# include terminal interface for travis parallel executions of scripts which use
+# terminal features: fix multiple stdin assignment at termios.tcgetattr
+if os.name != 'nt':
+    import pty
+
+settings = {
+    'alert_mask': lt.alert.category_t.all_categories,
+    'enable_dht': False, 'enable_lsd': False, 'enable_natpmp': False,
+    'enable_upnp': False, 'listen_interfaces': '0.0.0.0:0', 'file_pool_size': 1}
+
+
+def has_deprecated():
+    return hasattr(lt, 'version')
+
+
+class test_create_torrent(unittest.TestCase):
+
+    def test_from_torrent_info(self):
+        ti = lt.torrent_info('unordered.torrent')
+        print(ti.ssl_cert())
+        ct = lt.create_torrent(ti)
+        entry = ct.generate()
+        content = lt.bencode(entry).strip()
+        with open('unordered.torrent', 'rb') as f:
+            file_content = bytearray(f.read().strip())
+            print(content)
+            print(file_content)
+            print(entry)
+            self.assertEqual(content, file_content)
+
+    def test_from_scratch(self):
+        fs = lt.file_storage()
+        fs.add_file('test/file1', 1000)
+        fs.add_file('test/file2', 2000)
+        self.assertEqual(fs.file_name(0), 'file1')
+        self.assertEqual(fs.file_name(1), 'file2')
+        ct = lt.create_torrent(fs)
+        ct.add_url_seed('foo')
+        ct.add_http_seed('bar')
+        ct.add_tracker('bar')
+        ct.set_root_cert('1234567890')
+        ct.add_collection('1337')
+        for i in range(ct.num_pieces()):
+            ct.set_hash(i, b'abababababababababab')
+        entry = ct.generate()
+        encoded = lt.bencode(entry)
+        print(encoded)
+
+        # zero out the creation date:
+        encoded = encoded.split(b'13:creation datei', 1)
+        encoded[1] = b'0e' + encoded[1].split(b'e', 1)[1]
+        encoded = b'13:creation datei'.join(encoded)
+
+        self.assertEqual(encoded, b'd8:announce3:bar13:creation datei0e9:httpseeds3:bar4:infod11:collectionsl4:1337e5:filesld6:lengthi1000e4:pathl5:file1eed4:attr1:p6:lengthi15384e4:pathl4:.pad5:15384eed6:lengthi2000e4:pathl5:file2eee4:name4:test12:piece lengthi16384e6:pieces40:abababababababababababababababababababab8:ssl-cert10:1234567890e8:url-list3:fooe')
+
+
+class test_session_stats(unittest.TestCase):
+
+    def test_add_torrent_params(self):
+        atp = lt.add_torrent_params()
+
+        for field_name in dir(atp):
+            field = getattr(atp, field_name)
+            print(field_name, field)
+
+        atp.renamed_files = {}
+        atp.merkle_tree = []
+        atp.unfinished_pieces = {}
+        atp.have_pieces = []
+        atp.banned_peers = []
+        atp.verified_pieces = []
+        atp.piece_priorities = []
+        atp.url_seeds = []
+
+    def test_unique(self):
+        metrics = lt.session_stats_metrics()
+        self.assertTrue(len(metrics) > 40)
+        idx = set()
+        for m in metrics:
+            self.assertTrue(m.value_index not in idx)
+            idx.add(m.value_index)
+
+    def test_find_idx(self):
+        self.assertEqual(lt.find_metric_idx("peer.error_peers"), 0)
+
+
+class test_torrent_handle(unittest.TestCase):
+
+    def setup(self):
+        self.ses = lt.session(settings)
+        self.ti = lt.torrent_info('url_seed_multi.torrent')
+        self.h = self.ses.add_torrent({
+            'ti': self.ti, 'save_path': os.getcwd(),
+            'flags': lt.torrent_flags.default_flags})
+
+    def test_add_torrent_error(self):
+        self.ses = lt.session(settings)
+        self.ti = lt.torrent_info('url_seed_multi.torrent')
+        with self.assertRaises(RuntimeError):
+            self.ses.add_torrent({'ti': self.ti, 'save_path': os.getcwd(), 'info_hashes': b'abababababababababab'})
+
+    def test_move_storage(self):
+        self.setup()
+        self.h.move_storage(u'test-dir')
+        self.h.move_storage(b'test-dir2')
+        self.h.move_storage('test-dir3')
+        self.h.move_storage(u'test-dir', flags=lt.move_flags_t.dont_replace)
+        self.h.move_storage(u'test-dir', flags=2)
+        self.h.move_storage(b'test-dir2', flags=2)
+        self.h.move_storage('test-dir3', flags=2)
+
+    def test_torrent_handle(self):
+        self.setup()
+        self.assertEqual(self.h.get_file_priorities(), [4, 4])
+        self.assertEqual(self.h.get_piece_priorities(), [4])
+
+        self.h.prioritize_files([0, 1])
+        # workaround for asynchronous priority update
+        time.sleep(1)
+        self.assertEqual(self.h.get_file_priorities(), [0, 1])
+
+        self.h.prioritize_pieces([0])
+        self.assertEqual(self.h.get_piece_priorities(), [0])
+
+        # also test the overload that takes a list of piece->priority mappings
+        self.h.prioritize_pieces([(0, 1)])
+        self.assertEqual(self.h.get_piece_priorities(), [1])
+        self.h.connect_peer(('127.0.0.1', 6881))
+        self.h.connect_peer(('127.0.0.2', 6881), source=4)
+        self.h.connect_peer(('127.0.0.3', 6881), flags=2)
+        self.h.connect_peer(('127.0.0.4', 6881), flags=2, source=4)
+
+        torrent_files = self.h.torrent_file()
+        print(torrent_files.map_file(0, 0, 0).piece)
+
+        print(self.h.queue_position())
+
+    def test_torrent_handle_in_set(self):
+        self.setup()
+        torrents = set()
+        torrents.add(self.h)
+
+        # get another instance of a torrent_handle that represents the same
+        # torrent. Make sure that when we add it to a set, it just replaces the
+        # existing object
+        t = self.ses.get_torrents()
+        self.assertEqual(len(t), 1)
+        for h in t:
+            torrents.add(h)
+
+        self.assertEqual(len(torrents), 1)
+
+    def test_torrent_handle_in_dict(self):
+        self.setup()
+        torrents = {}
+        torrents[self.h] = 'foo'
+
+        # get another instance of a torrent_handle that represents the same
+        # torrent. Make sure that when we add it to a dict, it just replaces the
+        # existing object
+        t = self.ses.get_torrents()
+        self.assertEqual(len(t), 1)
+        for h in t:
+            torrents[h] = 'bar'
+
+        self.assertEqual(len(torrents), 1)
+        self.assertEqual(torrents[self.h], 'bar')
+
+    def test_replace_trackers(self):
+        self.setup()
+        trackers = []
+        for idx, tracker_url in enumerate(('udp://tracker1.com', 'udp://tracker2.com')):
+            tracker = lt.announce_entry(tracker_url)
+            tracker.tier = idx
+            tracker.fail_limit = 2
+            trackers.append(tracker)
+            self.assertEqual(tracker.url, tracker_url)
+        self.h.replace_trackers(trackers)
+        new_trackers = self.h.trackers()
+        self.assertEqual(new_trackers[0]['url'], 'udp://tracker1.com')
+        self.assertEqual(new_trackers[1]['tier'], 1)
+        self.assertEqual(new_trackers[1]['fail_limit'], 2)
+
+    def test_pickle_trackers(self):
+        """Test lt objects convertors are working and trackers can be pickled"""
+        self.setup()
+        tracker = lt.announce_entry('udp://tracker1.com')
+        tracker.tier = 0
+        tracker.fail_limit = 1
+        trackers = [tracker]
+        self.h.replace_trackers(trackers)
+        # wait a bit until the endpoints list gets populated
+        while len(self.h.trackers()[0]['endpoints']) == 0:
+            time.sleep(0.1)
+
+        trackers = self.h.trackers()
+        self.assertEqual(trackers[0]['url'], 'udp://tracker1.com')
+        # this is not necessarily 0, it could also be (EHOSTUNREACH) if the
+        # local machine doesn't support the address family
+        expect_value = trackers[0]['endpoints'][0]['info_hashes'][0]['last_error']['value']
+        pickled_trackers = pickle.dumps(trackers)
+        unpickled_trackers = pickle.loads(pickled_trackers)
+        self.assertEqual(unpickled_trackers[0]['url'], 'udp://tracker1.com')
+        self.assertEqual(unpickled_trackers[0]['endpoints'][0]['info_hashes'][0]['last_error']['value'], expect_value)
+
+    def test_file_status(self):
+        self.setup()
+        status = self.h.file_status()
+        print(status)
+
+    def test_piece_deadlines(self):
+        self.setup()
+        self.h.clear_piece_deadlines()
+
+    def test_status_last_uploaded_dowloaded(self):
+        # we want to check at seconds precision but can't control session
+        # time, wait for next full second to prevent second increment
+        time.sleep(1 - datetime.datetime.now().microsecond / 1000000.0)
+
+        self.setup()
+        st = self.h.status()
+        for attr in dir(st):
+            print('%s: %s' % (attr, getattr(st, attr)))
+        # last upload and download times are at session start time
+        self.assertEqual(st.last_upload, None)
+        self.assertEqual(st.last_download, None)
+
+    def test_serialize_trackers(self):
+        """Test to ensure the dict contains only python built-in types"""
+        self.setup()
+        self.h.add_tracker({'url': 'udp://tracker1.com'})
+        tr = self.h.trackers()[0]
+        # wait a bit until the endpoints list gets populated
+        while len(tr['endpoints']) == 0:
+            time.sleep(0.1)
+            tr = self.h.trackers()[0]
+        import json
+        print(json.dumps(self.h.trackers()[0]))
+
+    def test_torrent_status(self):
+        self.setup()
+        st = self.h.status()
+        ti = st.handle
+        self.assertEqual(ti.info_hashes(), self.ti.info_hashes())
+        # make sure we can compare torrent_status objects
+        st2 = self.h.status()
+        self.assertEqual(st2, st)
+        print(st2)
+
+    def test_read_resume_data(self):
+
+        resume_data = lt.bencode({
+            'file-format': 'libtorrent resume file',
+            'info-hash': 'abababababababababab',
+            'name': 'test',
+            'save_path': '.',
+            'peers': '\x01\x01\x01\x01\x00\x01\x02\x02\x02\x02\x00\x02',
+            'file_priority': [0, 1, 1]})
+        tp = lt.read_resume_data(resume_data)
+
+        self.assertEqual(tp.name, 'test')
+        self.assertEqual(tp.info_hashes.v1, lt.sha1_hash('abababababababababab'))
+        self.assertEqual(tp.file_priorities, [0, 1, 1])
+        self.assertEqual(tp.peers, [('1.1.1.1', 1), ('2.2.2.2', 2)])
+
+        ses = lt.session(settings)
+        h = ses.add_torrent(tp)
+        for attr in dir(tp):
+            print('%s: %s' % (attr, getattr(tp, attr)))
+
+        h.connect_peer(('3.3.3.3', 3))
+
+        for i in range(0, 10):
+            alerts = ses.pop_alerts()
+            for a in alerts:
+                print(a.message())
+            time.sleep(0.1)
+
+    def test_scrape(self):
+        self.setup()
+        # this is just to make sure this function can be called like this
+        # from python
+        self.h.scrape_tracker()
+
+    def test_unknown_torrent_parameter(self):
+        self.ses = lt.session(settings)
+        try:
+            self.h = self.ses.add_torrent({'unexpected-key-name': ''})
+            self.assertFalse('should have thrown an exception')
+        except KeyError as e:
+            print(e)
+
+    def test_torrent_parameter(self):
+        self.ses = lt.session(settings)
+        self.ti = lt.torrent_info('url_seed_multi.torrent')
+        self.h = self.ses.add_torrent({
+            'ti': self.ti,
+            'save_path': os.getcwd(),
+            'trackers': ['http://test.com/announce'],
+            'dht_nodes': [('1.2.3.4', 6881), ('4.3.2.1', 6881)],
+            'file_priorities': [1, 1],
+            'http_seeds': ['http://test.com/file3'],
+            'url_seeds': ['http://test.com/announce-url'],
+            'peers': [('5.6.7.8', 6881)],
+            'banned_peers': [('8.7.6.5', 6881)],
+            'renamed_files': {0: 'test.txt', 2: 'test.txt'}
+        })
+        self.st = self.h.status()
+        self.assertEqual(self.st.save_path, os.getcwd())
+        trackers = self.h.trackers()
+        self.assertEqual(len(trackers), 1)
+        self.assertEqual(trackers[0].get('url'), 'http://test.com/announce')
+        self.assertEqual(trackers[0].get('tier'), 0)
+        self.assertEqual(self.h.get_file_priorities(), [1, 1])
+        self.assertEqual(self.h.http_seeds(), ['http://test.com/file3'])
+        # url_seeds was already set, test that it did not get overwritten
+        self.assertEqual(self.h.url_seeds(),
+                         ['http://test.com/announce-url/', 'http://test.com/file/'])
+        # piece priorities weren't set explicitly, but they were updated by the
+        # file priorities being set
+        self.assertEqual(self.h.get_piece_priorities(), [1])
+        self.assertEqual(self.st.verified_pieces, [])
+
+
+class TestAddPiece(unittest.TestCase):
+
+    def setUp(self):
+        self.dir = tempfile.TemporaryDirectory()
+        self.session = lt.session(settings)
+        self.ti = lt.torrent_info(dummy_data.DICT)
+        self.atp = lt.add_torrent_params()
+        self.atp.ti = self.ti
+        self.atp.save_path = self.dir.name
+        self.handle = self.session.add_torrent(self.atp)
+        self.wait_for(lambda: self.handle.status().state != lt.torrent_status.checking_files
+                      and self.handle.status().state != lt.torrent_status.checking_resume_data, msg="checking")
+
+    def wait_for(self, condition, msg="condition", timeout=5):
+        deadline = time.time() + timeout
+        while not condition():
+            self.assertLess(time.time(), deadline, msg="%s timed out" % msg)
+            time.sleep(0.1)
+
+    def wait_until_torrent_finished(self):
+        self.wait_for(lambda: self.handle.status().progress == 1.0, msg="progress")
+
+        def file_written():
+            with open(os.path.join(self.dir.name.encode(), dummy_data.NAME), mode="rb") as f:
+                return f.read() == dummy_data.DATA
+
+        self.wait_for(file_written, msg="file write")
+
+    def test_with_str(self):
+        for i, data in enumerate(dummy_data.PIECES):
+            self.handle.add_piece(i, data.decode(), 0)
+
+        self.wait_until_torrent_finished()
+
+    def test_with_bytes(self):
+        for i, data in enumerate(dummy_data.PIECES):
+            self.handle.add_piece(i, data, 0)
+
+        self.wait_until_torrent_finished()
+
+
+class test_torrent_info(unittest.TestCase):
+
+    def test_non_ascii_file(self):
+        try:
+            shutil.copy('base.torrent', 'base-\u745E\u5177.torrent')
+        except shutil.SameFileError:
+            pass
+        ti = lt.torrent_info('base-\u745E\u5177.torrent')
+
+        self.assertTrue(len(ti.info_section()) != 0)
+        self.assertTrue(len(ti.hash_for_piece(0)) != 0)
+
+    def test_bencoded_constructor(self):
+        # things that can be converted to a bencoded entry, will be interpreted
+        # as such and encoded
+        info = lt.torrent_info({'info': {
+            'name': 'test_torrent', 'length': 1234,
+            'piece length': 16 * 1024,
+            'pieces': 'aaaaaaaaaaaaaaaaaaaa'}})
+
+        self.assertEqual(info.num_files(), 1)
+
+        f = info.files()
+        self.assertEqual(f.file_path(0), 'test_torrent')
+        self.assertEqual(f.file_name(0), 'test_torrent')
+        self.assertEqual(f.file_size(0), 1234)
+        self.assertEqual(info.total_size(), 1234)
+        self.assertEqual(info.creation_date(), 0)
+
+    def test_bytearray(self):
+        # a bytearray object is interpreted as a bencoded buffer
+        info = lt.torrent_info(bytearray(lt.bencode({'info': {
+            'name': 'test_torrent', 'length': 1234,
+            'piece length': 16 * 1024,
+            'pieces': 'aaaaaaaaaaaaaaaaaaaa'}})))
+        self.assertEqual(info.num_files(), 1)
+
+    def test_bytes(self):
+        # a bytes object is interpreted as a bencoded buffer
+        info = lt.torrent_info(bytes(lt.bencode({'info': {
+            'name': 'test_torrent', 'length': 1234,
+            'piece length': 16 * 1024,
+            'pieces': 'aaaaaaaaaaaaaaaaaaaa'}})))
+        self.assertEqual(info.num_files(), 1)
+
+    def test_load_decode_depth_limit(self):
+        self.assertRaises(RuntimeError, lambda: lt.torrent_info(
+            {'test': {'test': {'test': {'test': {'test': {}}}}}, 'info': {
+                'name': 'test_torrent', 'length': 1234,
+                'piece length': 16 * 1024,
+                'pieces': 'aaaaaaaaaaaaaaaaaaaa'}}, {'max_decode_depth': 1}))
+
+    def test_load_max_pieces_limit(self):
+        self.assertRaises(RuntimeError, lambda: lt.torrent_info(
+            {'info': {
+                'name': 'test_torrent', 'length': 1234000,
+                'piece length': 16 * 1024,
+                'pieces': 'aaaaaaaaaaaaaaaaaaaa'}}, {'max_pieces': 1}))
+
+    def test_load_max_buffer_size_limit(self):
+        self.assertRaises(RuntimeError, lambda: lt.torrent_info(
+            {'info': {
+                'name': 'test_torrent', 'length': 1234000,
+                'piece length': 16 * 1024,
+                'pieces': 'aaaaaaaaaaaaaaaaaaaa'}}, {'max_buffer_size': 1}))
+
+    def test_info_section(self):
+        ti = lt.torrent_info('base.torrent')
+
+        self.assertTrue(len(ti.info_section()) != 0)
+        self.assertTrue(len(ti.hash_for_piece(0)) != 0)
+
+    def test_torrent_info_bytes_overload(self):
+        # bytes will never be interpreted as a file name. It's interpreted as a
+        # bencoded buffer
+        with self.assertRaises(RuntimeError):
+            ti = lt.torrent_info(b'base.torrent')
+
+    def test_web_seeds(self):
+        ti = lt.torrent_info('base.torrent')
+
+        ws = [{'url': 'http://foo/test', 'auth': '', 'type': 0},
+              {'url': 'http://bar/test', 'auth': '', 'type': 1}]
+        ti.set_web_seeds(ws)
+        web_seeds = ti.web_seeds()
+        self.assertEqual(len(ws), len(web_seeds))
+        for i in range(len(web_seeds)):
+            self.assertEqual(web_seeds[i]["url"], ws[i]["url"])
+            self.assertEqual(web_seeds[i]["auth"], ws[i]["auth"])
+            self.assertEqual(web_seeds[i]["type"], ws[i]["type"])
+
+    def test_announce_entry(self):
+        ae = lt.announce_entry('test')
+        self.assertEqual(ae.url, 'test')
+        self.assertEqual(ae.tier, 0)
+        self.assertEqual(ae.verified, False)
+        self.assertEqual(ae.source, 0)
+
+    def test_torrent_info_sha1_overload(self):
+        ti = lt.torrent_info(lt.info_hash_t(lt.sha1_hash(b'a' * 20)))
+        self.assertEqual(ti.info_hash(), lt.sha1_hash(b'a' * 20))
+        self.assertEqual(ti.info_hashes().v1, lt.sha1_hash(b'a' * 20))
+
+        ti_copy = lt.torrent_info(ti)
+        self.assertEqual(ti_copy.info_hash(), lt.sha1_hash(b'a' * 20))
+        self.assertEqual(ti_copy.info_hashes().v1, lt.sha1_hash(b'a' * 20))
+
+    def test_torrent_info_sha256_overload(self):
+        ti = lt.torrent_info(lt.info_hash_t(lt.sha256_hash(b'a' * 32)))
+        self.assertEqual(ti.info_hashes().v2, lt.sha256_hash(b'a' * 32))
+
+        ti_copy = lt.torrent_info(ti)
+        self.assertEqual(ti_copy.info_hashes().v2, lt.sha256_hash(b'a' * 32))
+
+    def test_url_seed(self):
+        ti = lt.torrent_info('base.torrent')
+
+        ti.add_tracker('foobar1')
+        ti.add_url_seed('foobar2')
+        ti.add_url_seed('foobar3', 'username:password')
+        ti.add_url_seed('foobar4', 'username:password', [])
+
+        seeds = ti.web_seeds()
+        self.assertEqual(seeds, [
+            {'url': 'foobar2', 'type': 0, 'auth': ''},
+            {'url': 'foobar3', 'type': 0, 'auth': 'username:password'},
+            {'url': 'foobar4', 'type': 0, 'auth': 'username:password'},
+        ])
+
+    def test_http_seed(self):
+        ti = lt.torrent_info('base.torrent')
+
+        ti.add_http_seed('foobar2')
+        ti.add_http_seed('foobar3', 'username:password')
+        ti.add_http_seed('foobar4', 'username:password', [])
+
+        seeds = ti.web_seeds()
+        self.assertEqual(seeds, [
+            {'url': 'foobar2', 'type': 1, 'auth': ''},
+            {'url': 'foobar3', 'type': 1, 'auth': 'username:password'},
+            {'url': 'foobar4', 'type': 1, 'auth': 'username:password'},
+        ])
+
+class test_alerts(unittest.TestCase):
+
+    def test_alert(self):
+
+        ses = lt.session(settings)
+        ti = lt.torrent_info('base.torrent')
+        h = ses.add_torrent({'ti': ti, 'save_path': os.getcwd()})
+        st = h.status()
+        time.sleep(1)
+        ses.remove_torrent(h)
+        ses.wait_for_alert(1000)  # milliseconds
+        alerts = ses.pop_alerts()
+        for a in alerts:
+            if a.what() == 'add_torrent_alert':
+                self.assertEqual(a.torrent_name, 'temp')
+            print(a.message())
+            for field_name in dir(a):
+                if field_name.startswith('__'):
+                    continue
+                field = getattr(a, field_name)
+                if callable(field):
+                    print('  ', field_name, ' = ', field())
+                else:
+                    print('  ', field_name, ' = ', field)
+
+        print(st.next_announce)
+        self.assertEqual(st.name, 'temp')
+        print(st.errc.message())
+        print(st.pieces)
+        print(st.last_seen_complete)
+        print(st.completed_time)
+        print(st.progress)
+        print(st.num_pieces)
+        print(st.distributed_copies)
+        print(st.info_hashes)
+        print(st.seeding_duration)
+        print(st.last_upload)
+        print(st.last_download)
+        self.assertEqual(st.save_path, os.getcwd())
+
+    def test_alert_fs(self):
+        ses = lt.session(settings)
+        s1, s2 = socket.socketpair()
+        ses.set_alert_fd(s2.fileno())
+
+        ses.pop_alerts()
+
+        # make sure there's an alert to wake us up
+        ses.post_session_stats()
+
+        read_sockets, write_sockets, error_sockets = select.select([s1], [], [])
+
+        self.assertEqual(len(read_sockets), 1)
+        for s in read_sockets:
+            s.recv(10)
+
+    def test_pop_alerts(self):
+        ses = lt.session(settings)
+        ses.async_add_torrent(
+            {"ti": lt.torrent_info("base.torrent"), "save_path": "."})
+
+# this will cause an error (because of duplicate torrents) and the
+# torrent_info object created here will be deleted once the alert goes out
+# of scope. When that happens, it will decrement the python object, to allow
+# it to release the object.
+# we're trying to catch the error described in this post, with regards to
+# torrent_info.
+# https://mail.python.org/pipermail/cplusplus-sig/2007-June/012130.html
+        ses.async_add_torrent(
+            {"ti": lt.torrent_info("base.torrent"), "save_path": "."})
+        time.sleep(1)
+        for i in range(0, 10):
+            alerts = ses.pop_alerts()
+            for a in alerts:
+                print(a.message())
+            time.sleep(0.1)
+
+    def test_alert_notify(self):
+        ses = lt.session(settings)
+        event = threading.Event()
+
+        def callback():
+            event.set()
+
+        ses.set_alert_notify(callback)
+        ses.async_add_torrent(
+            {"ti": lt.torrent_info("base.torrent"), "save_path": "."})
+        event.wait()
+
+
+class test_bencoder(unittest.TestCase):
+
+    def test_bencode(self):
+        encoded = lt.bencode({'a': 1, 'b': [1, 2, 3], 'c': 'foo'})
+        self.assertEqual(encoded, b'd1:ai1e1:bli1ei2ei3ee1:c3:fooe')
+
+    def test_bdecode(self):
+        encoded = b'd1:ai1e1:bli1ei2ei3ee1:c3:fooe'
+        decoded = lt.bdecode(encoded)
+        self.assertEqual(decoded, {b'a': 1, b'b': [1, 2, 3], b'c': b'foo'})
+
+    def test_string(self):
+        encoded = lt.bencode('foo\u00e5\u00e4\u00f6')
+        self.assertEqual(encoded, b'9:foo\xc3\xa5\xc3\xa4\xc3\xb6')
+
+    def test_bytes(self):
+        encoded = lt.bencode(b'foo')
+        self.assertEqual(encoded, b'3:foo')
+
+    def test_float(self):
+        # TODO: this should throw a TypeError in the future
+        with self.assertWarns(DeprecationWarning):
+            encoded = lt.bencode(1.337)
+            self.assertEqual(encoded, b'0:')
+
+    def test_object(self):
+        class FooBar:
+            dummy = 1
+
+        # TODO: this should throw a TypeError in the future
+        with self.assertWarns(DeprecationWarning):
+            encoded = lt.bencode(FooBar())
+            self.assertEqual(encoded, b'0:')
+
+    def test_preformatted(self):
+        encoded = lt.bencode((1, 2, 3, 4, 5))
+        self.assertEqual(encoded, b'\x01\x02\x03\x04\x05')
+
+class test_sha1hash(unittest.TestCase):
+
+    def test_sha1hash(self):
+        h = 'a0' * 20
+        s = lt.sha1_hash(binascii.unhexlify(h))
+        self.assertEqual(h, str(s))
+
+    def test_hash(self):
+        self.assertNotEqual(hash(lt.sha1_hash(b'b' * 20)), hash(lt.sha1_hash(b'a' * 20)))
+        self.assertEqual(hash(lt.sha1_hash(b'b' * 20)), hash(lt.sha1_hash(b'b' * 20)))
+
+class test_sha256hash(unittest.TestCase):
+
+    def test_sha1hash(self):
+        h = 'a0' * 32
+        s = lt.sha256_hash(binascii.unhexlify(h))
+        self.assertEqual(h, str(s))
+
+    def test_hash(self):
+        self.assertNotEqual(hash(lt.sha256_hash(b'b' * 32)), hash(lt.sha256_hash(b'a' * 32)))
+        self.assertEqual(hash(lt.sha256_hash(b'b' * 32)), hash(lt.sha256_hash(b'b' * 32)))
+
+class test_info_hash(unittest.TestCase):
+
+    def test_info_hash(self):
+        s1 = lt.sha1_hash(b'a' * 20)
+        s2 = lt.sha256_hash(b'b' * 32)
+
+        ih1 = lt.info_hash_t(s1);
+        self.assertTrue(ih1.has_v1())
+        self.assertFalse(ih1.has_v2())
+        self.assertEqual(ih1.v1, s1)
+
+        ih2 = lt.info_hash_t(s2);
+        self.assertFalse(ih2.has_v1())
+        self.assertTrue(ih2.has_v2())
+        self.assertEqual(ih2.v2, s2)
+
+        ih12 = lt.info_hash_t(s1, s2);
+        self.assertTrue(ih12.has_v1())
+        self.assertTrue(ih12.has_v2())
+        self.assertEqual(ih12.v1, s1)
+        self.assertEqual(ih12.v2, s2)
+
+        self.assertNotEqual(hash(ih1), hash(ih2))
+        self.assertNotEqual(hash(ih1), hash(ih12))
+        self.assertEqual(hash(ih1), hash(lt.info_hash_t(s1)))
+        self.assertEqual(hash(ih2), hash(lt.info_hash_t(s2)))
+        self.assertEqual(hash(ih12), hash(lt.info_hash_t(s1, s2)))
+
+class test_magnet_link(unittest.TestCase):
+
+    def test_parse_magnet_uri(self):
+        ses = lt.session({})
+        magnet = 'magnet:?xt=urn:btih:C6EIF4CCYDBTIJVG3APAGM7M4NDONCTI'
+        p = lt.parse_magnet_uri(magnet)
+        self.assertEqual(str(p.info_hashes.v1), '178882f042c0c33426a6d81e0333ece346e68a68')
+        p.save_path = '.'
+        h = ses.add_torrent(p)
+        self.assertEqual(str(h.info_hash()), '178882f042c0c33426a6d81e0333ece346e68a68')
+        self.assertEqual(str(h.info_hashes().v1), '178882f042c0c33426a6d81e0333ece346e68a68')
+
+    def test_parse_magnet_uri_dict(self):
+        ses = lt.session({})
+        magnet = 'magnet:?xt=urn:btih:C6EIF4CCYDBTIJVG3APAGM7M4NDONCTI'
+        p = lt.parse_magnet_uri_dict(magnet)
+        self.assertEqual(binascii.hexlify(p['info_hashes']), b'178882f042c0c33426a6d81e0333ece346e68a68')
+        p['save_path'] = '.'
+        h = ses.add_torrent(p)
+        self.assertEqual(str(h.info_hash()), '178882f042c0c33426a6d81e0333ece346e68a68')
+        self.assertEqual(str(h.info_hashes().v1), '178882f042c0c33426a6d81e0333ece346e68a68')
+
+    def test_add_deprecated_magnet_link(self):
+        ses = lt.session()
+        atp = lt.add_torrent_params()
+        atp.info_hashes = lt.info_hash_t(lt.sha1_hash(b"a" * 20))
+        h = ses.add_torrent(atp)
+
+        self.assertTrue(h.status().info_hashes == lt.info_hash_t(lt.sha1_hash(b"a" * 20)))
+
+    def test_add_magnet_link(self):
+        ses = lt.session()
+        atp = lt.add_torrent_params()
+        atp.info_hash = lt.sha1_hash(b"a" * 20)
+        h = ses.add_torrent(atp)
+
+        self.assertTrue(h.status().info_hashes == lt.info_hash_t(lt.sha1_hash(b"a" * 20)))
+
+
+class test_peer_class(unittest.TestCase):
+
+    def test_peer_class_ids(self):
+        s = lt.session(settings)
+
+        print('global_peer_class_id:', lt.session.global_peer_class_id)
+        print('tcp_peer_class_id:', lt.session.tcp_peer_class_id)
+        print('local_peer_class_id:', lt.session.local_peer_class_id)
+
+        print('global: ', s.get_peer_class(s.global_peer_class_id))
+        print('tcp: ', s.get_peer_class(s.local_peer_class_id))
+        print('local: ', s.get_peer_class(s.local_peer_class_id))
+
+    def test_peer_class(self):
+        s = lt.session(settings)
+
+        c = s.create_peer_class('test class')
+        print('new class: ', s.get_peer_class(c))
+
+        nfo = s.get_peer_class(c)
+        self.assertEqual(nfo['download_limit'], 0)
+        self.assertEqual(nfo['upload_limit'], 0)
+        self.assertEqual(nfo['ignore_unchoke_slots'], False)
+        self.assertEqual(nfo['connection_limit_factor'], 100)
+        self.assertEqual(nfo['download_priority'], 1)
+        self.assertEqual(nfo['upload_priority'], 1)
+        self.assertEqual(nfo['label'], 'test class')
+
+        nfo['download_limit'] = 1337
+        nfo['upload_limit'] = 1338
+        nfo['ignore_unchoke_slots'] = True
+        nfo['connection_limit_factor'] = 42
+        nfo['download_priority'] = 2
+        nfo['upload_priority'] = 3
+
+        s.set_peer_class(c, nfo)
+
+        nfo2 = s.get_peer_class(c)
+        self.assertEqual(nfo, nfo2)
+
+    def test_peer_class_filter(self):
+        filt = lt.peer_class_type_filter()
+        filt.add(lt.peer_class_type_filter.tcp_socket, lt.session.global_peer_class_id)
+        filt.remove(lt.peer_class_type_filter.utp_socket, lt.session.local_peer_class_id)
+
+        filt.disallow(lt.peer_class_type_filter.tcp_socket, lt.session.global_peer_class_id)
+        filt.allow(lt.peer_class_type_filter.utp_socket, lt.session.local_peer_class_id)
+
+    def test_peer_class_ip_filter(self):
+        s = lt.session(settings)
+        s.set_peer_class_type_filter(lt.peer_class_type_filter())
+        s.set_peer_class_filter(lt.ip_filter())
+
+class test_ip_filter(unittest.TestCase):
+
+    def test_export(self):
+
+        f = lt.ip_filter()
+        self.assertEqual(f.access('1.1.1.1'), 0)
+        f.add_rule('1.1.1.1', '1.1.1.2', 1)
+        self.assertEqual(f.access('1.1.1.0'), 0)
+        self.assertEqual(f.access('1.1.1.1'), 1)
+        self.assertEqual(f.access('1.1.1.2'), 1)
+        self.assertEqual(f.access('1.1.1.3'), 0)
+        exp = f.export_filter()
+        self.assertEqual(exp, ([('0.0.0.0', '1.1.1.0'), ('1.1.1.1', '1.1.1.2'), ('1.1.1.3', '255.255.255.255')], [('::', 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff')]))
+
+class test_session(unittest.TestCase):
+
+    def test_settings(self):
+        sett = { 'alert_mask': lt.alert.category_t.all_categories }
+        s = lt.session(sett)
+        sett = s.get_settings()
+        self.assertEqual(sett['alert_mask'] & 0x7fffffff, 0x7fffffff)
+
+    def test_session_params(self):
+        sp = lt.session_params()
+        sp.settings = { 'alert_mask': lt.alert.category_t.all_categories }
+        s = lt.session(sp)
+        sett = s.get_settings()
+        self.assertEqual(sett['alert_mask'] & 0x7fffffff, 0x7fffffff)
+
+    def test_session_params_constructor(self):
+        sp = lt.session_params({ 'alert_mask': lt.alert.category_t.all_categories })
+        s = lt.session(sp)
+        sett = s.get_settings()
+        self.assertEqual(sett['alert_mask'] & 0x7fffffff, 0x7fffffff)
+
+    def test_session_params_ip_filter(self):
+        sp = lt.session_params()
+        sp.ip_filter.add_rule("1.1.1.1", "1.1.1.2", 1337)
+        self.assertEqual(sp.ip_filter.access("1.1.1.1"), 1337)
+        self.assertEqual(sp.ip_filter.access("1.1.1.2"), 1337)
+        self.assertEqual(sp.ip_filter.access("1.1.1.3"), 0)
+
+    def test_session_params_roundtrip_buf(self):
+
+        sp = lt.session_params()
+        sp.settings = { 'alert_mask': lt.alert.category_t.all_categories }
+
+        buf = lt.write_session_params_buf(sp)
+        sp2 = lt.read_session_params(buf)
+        self.assertEqual(sp2.settings['alert_mask'] & 0x7fffffff, 0x7fffffff)
+
+    def test_session_params_roundtrip_entry(self):
+
+        sp = lt.session_params()
+        sp.settings = { 'alert_mask': lt.alert.category_t.all_categories }
+
+        ent = lt.write_session_params(sp)
+        print(ent)
+        sp2 = lt.read_session_params(ent)
+        self.assertEqual(sp2.settings['alert_mask'] & 0x7fffffff, 0x7fffffff)
+
+    def test_add_torrent(self):
+        s = lt.session(settings)
+        h = s.add_torrent({'ti': lt.torrent_info('base.torrent'),
+                       'save_path': '.',
+                       'dht_nodes': [('1.2.3.4', 6881), ('4.3.2.1', 6881)],
+                       'http_seeds': ['http://test.com/seed'],
+                       'peers': [('5.6.7.8', 6881)],
+                       'banned_peers': [('8.7.6.5', 6881)],
+                       'file_priorities': [1, 1, 1, 2, 0]})
+
+    def test_find_torrent(self):
+        s = lt.session(settings)
+        h = s.add_torrent({'info_hash': b"a" * 20,
+                           'save_path': '.'})
+        self.assertTrue(h.is_valid())
+
+        h2 = s.find_torrent(lt.sha1_hash(b"a" * 20))
+        self.assertTrue(h2.is_valid())
+        h3 = s.find_torrent(lt.sha1_hash(b"b" * 20))
+        self.assertFalse(h3.is_valid())
+
+        self.assertEqual(h, h2)
+        self.assertNotEqual(h, h3)
+
+    def test_add_torrent_info_hash(self):
+        s = lt.session(settings)
+        h = s.add_torrent({
+                           'info_hash': b'a' * 20,
+                           'info_hashes': b'a' * 32,
+                           'save_path': '.'})
+
+        time.sleep(1)
+        alerts = s.pop_alerts()
+
+        while len(alerts) > 0:
+            a = alerts.pop(0)
+            print(a)
+
+        self.assertTrue(h.is_valid())
+        self.assertEqual(h.status().info_hashes, lt.info_hash_t(lt.sha256_hash(b'a' * 32)))
+
+    def test_session_status(self):
+        if not has_deprecated():
+            return
+
+        s = lt.session()
+        st = s.status()
+        print(st)
+        print(st.active_requests)
+        print(st.dht_nodes)
+        print(st.dht_node_cache)
+        print(st.dht_torrents)
+        print(st.dht_global_nodes)
+        print(st.dht_total_allocations)
+
+    def test_apply_settings(self):
+
+        s = lt.session(settings)
+        s.apply_settings({'num_want': 66, 'user_agent': 'test123'})
+        self.assertEqual(s.get_settings()['num_want'], 66)
+        self.assertEqual(s.get_settings()['user_agent'], 'test123')
+
+    def test_post_session_stats(self):
+        s = lt.session({'alert_mask': 0, 'enable_dht': False})
+        s.post_session_stats()
+        alerts = []
+        # first the stats headers log line. but not if logging is disabled
+        while len(alerts) == 0:
+            s.wait_for_alert(1000)
+            alerts = s.pop_alerts()
+
+        while len(alerts) > 0:
+            a = alerts.pop(0)
+            print(a)
+            if isinstance(a, lt.session_stats_header_alert):
+                break
+        self.assertTrue(isinstance(a, lt.session_stats_header_alert))
+        # then the actual stats values
+        while len(alerts) == 0:
+            s.wait_for_alert(1000)
+            alerts = s.pop_alerts()
+        a = alerts.pop(0)
+        print(a)
+        self.assertTrue(isinstance(a, lt.session_stats_alert))
+        self.assertTrue(isinstance(a.values, dict))
+        self.assertTrue(len(a.values) > 0)
+
+    def test_post_dht_stats(self):
+        s = lt.session({'alert_mask': 0, 'enable_dht': False})
+        s.post_dht_stats()
+        alerts = []
+        cnt = 0
+        while len(alerts) == 0:
+            s.wait_for_alert(1000)
+            alerts = s.pop_alerts()
+            cnt += 1
+            if cnt > 60:
+                print('no dht_stats_alert in 1 minute!')
+                sys.exit(1)
+        a = alerts.pop(0)
+        self.assertTrue(isinstance(a, lt.dht_stats_alert))
+        self.assertTrue(isinstance(a.active_requests, list))
+        self.assertTrue(isinstance(a.routing_table, list))
+
+    def test_unknown_settings(self):
+        try:
+            lt.session({'unexpected-key-name': 42})
+            self.assertFalse('should have thrown an exception')
+        except KeyError as e:
+            print(e)
+
+    def test_fingerprint(self):
+        self.assertEqual(lt.generate_fingerprint('LT', 0, 1, 2, 3), '-LT0123-')
+        self.assertEqual(lt.generate_fingerprint('..', 10, 1, 2, 3), '-..A123-')
+
+    def test_min_memory_preset(self):
+        min_mem = lt.min_memory_usage()
+        print(min_mem)
+
+        self.assertTrue('connection_speed' in min_mem)
+        self.assertTrue('file_pool_size' in min_mem)
+
+    def test_seed_mode_preset(self):
+        seed_mode = lt.high_performance_seed()
+        print(seed_mode)
+
+        self.assertTrue('alert_queue_size' in seed_mode)
+        self.assertTrue('connection_speed' in seed_mode)
+        self.assertTrue('file_pool_size' in seed_mode)
+
+    def test_default_settings(self):
+
+        default = lt.default_settings()
+        print(default)
+
+
+class test_example_client(unittest.TestCase):
+
+    def test_execute_client(self):
+        if os.name == 'nt':
+            # TODO: fix windows includes of client.py
+            return
+        my_stdin = sys.stdin
+        if os.name != 'nt':
+            master_fd, slave_fd = pty.openpty()
+            # slave_fd fix multiple stdin assignment at termios.tcgetattr
+            my_stdin = slave_fd
+
+        process = sub.Popen(
+            [sys.executable, "client.py", "url_seed_multi.torrent"],
+            stdin=my_stdin, stdout=sub.PIPE, stderr=sub.PIPE)
+        # python2 has no Popen.wait() timeout
+        time.sleep(5)
+        returncode = process.poll()
+        if returncode is None:
+            # this is an expected use-case
+            process.kill()
+        err = process.stderr.read().decode("utf-8")
+        self.assertEqual('', err, 'process throw errors: \n' + err)
+        # check error code if process did unexpected end
+        if returncode is not None:
+            # in case of error return: output stdout if nothing was on stderr
+            if returncode != 0:
+                print("stdout:\n" + process.stdout.read().decode("utf-8"))
+            self.assertEqual(returncode, 0, "returncode: " + str(returncode) + "\n"
+                             + "stderr: empty\n"
+                             + "some configuration does not output errors like missing module members,"
+                             + "try to call it manually to get the error message\n")
+
+    def test_execute_simple_client(self):
+        process = sub.Popen(
+            [sys.executable, "simple_client.py", "url_seed_multi.torrent"],
+            stdout=sub.PIPE, stderr=sub.PIPE)
+        # python2 has no Popen.wait() timeout
+        time.sleep(5)
+        returncode = process.poll()
+        if returncode is None:
+            # this is an expected use-case
+            process.kill()
+        err = process.stderr.read().decode("utf-8")
+        self.assertEqual('', err, 'process throw errors: \n' + err)
+        # check error code if process did unexpected end
+        if returncode is not None:
+            # in case of error return: output stdout if nothing was on stderr
+            if returncode != 0:
+                print("stdout:\n" + process.stdout.read().decode("utf-8"))
+            self.assertEqual(returncode, 0, "returncode: " + str(returncode) + "\n"
+                             + "stderr: empty\n"
+                             + "some configuration does not output errors like missing module members,"
+                             + "try to call it manually to get the error message\n")
+
+    def test_execute_make_torrent(self):
+        process = sub.Popen(
+            [sys.executable, "make_torrent.py", "url_seed_multi.torrent",
+             "http://test.com/test"], stdout=sub.PIPE, stderr=sub.PIPE)
+        returncode = process.wait()
+        # python2 has no Popen.wait() timeout
+        err = process.stderr.read().decode("utf-8")
+        self.assertEqual('', err, 'process throw errors: \n' + err)
+        # in case of error return: output stdout if nothing was on stderr
+        if returncode != 0:
+            print("stdout:\n" + process.stdout.read().decode("utf-8"))
+        self.assertEqual(returncode, 0, "returncode: " + str(returncode) + "\n"
+                         + "stderr: empty\n"
+                         + "some configuration does not output errors like missing module members,"
+                         + "try to call it manually to get the error message\n")
+
+    def test_default_settings(self):
+
+        default = lt.default_settings()
+        self.assertNotIn('', default)
+        print(default)
+
+
+class test_operation_t(unittest.TestCase):
+
+    def test_enum(self):
+        self.assertEqual(lt.operation_name(lt.operation_t.sock_accept), "sock_accept")
+        self.assertEqual(lt.operation_name(lt.operation_t.unknown), "unknown")
+        self.assertEqual(lt.operation_name(lt.operation_t.mkdir), "mkdir")
+        self.assertEqual(lt.operation_name(lt.operation_t.partfile_write), "partfile_write")
+        self.assertEqual(lt.operation_name(lt.operation_t.hostname_lookup), "hostname_lookup")
+
+
+class test_error_code(unittest.TestCase):
+
+    def test_error_code(self):
+
+        a = lt.error_code()
+        a = lt.error_code(10, lt.libtorrent_category())
+        self.assertEqual(a.category().name(), 'libtorrent')
+
+        self.assertEqual(lt.libtorrent_category().name(), 'libtorrent')
+        self.assertEqual(lt.upnp_category().name(), 'upnp')
+        self.assertEqual(lt.http_category().name(), 'http')
+        self.assertEqual(lt.socks_category().name(), 'socks')
+        self.assertEqual(lt.bdecode_category().name(), 'bdecode')
+        self.assertEqual(lt.generic_category().name(), 'generic')
+        self.assertEqual(lt.system_category().name(), 'system')
+
+
+class test_peer_info(unittest.TestCase):
+
+    def test_peer_info_members(self):
+
+        p = lt.peer_info()
+
+        print(p.client)
+        print(p.pieces)
+        print(p.pieces)
+        print(p.last_request)
+        print(p.last_active)
+        print(p.flags)
+        print(p.source)
+        print(p.pid)
+        print(p.downloading_piece_index)
+        print(p.ip)
+        print(p.local_endpoint)
+        print(p.read_state)
+        print(p.write_state)
+
+
+if __name__ == '__main__':
+    print(lt.__version__)
+    try:
+        shutil.copy(os.path.join('..', '..', 'test', 'test_torrents',
+                                 'url_seed_multi.torrent'), '.')
+    except shutil.SameFileError:
+        pass
+    try:
+        shutil.copy(os.path.join('..', '..', 'test', 'test_torrents',
+                                 'base.torrent'), '.')
+    except shutil.SameFileError:
+        pass
+    try:
+        shutil.copy(os.path.join('..', '..', 'test', 'test_torrents',
+                                 'unordered.torrent'), '.')
+    except shutil.SameFileError:
+        pass
+    unittest.main()
diff -Naupr a/clang_tidy.jam b/clang_tidy.jam
--- a/clang_tidy.jam	1970-01-01 01:00:00.000000000 +0100
+++ b/clang_tidy.jam	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,105 @@
+#  Copyright (c) 2018 Arvid Norberg (arvid@libtorrent.org)
+#
+#  Use, modification and distribution is subject to the Boost Software
+#  License Version 1.0. (See accompanying file LICENSE_1_0.txt or
+#  http://www.boost.org/LICENSE_1_0.txt)
+
+import common ;
+import toolset ;
+import feature ;
+
+feature.extend toolset : clang_tidy ;
+
+generators.register-c-compiler clang_tidy.compile.c++ : CPP : OBJ : <toolset>clang_tidy ;
+generators.register-c-compiler clang_tidy.compile.c : C : OBJ : <toolset>clang_tidy ;
+generators.register-archiver clang_tidy.archive : OBJ : STATIC_LIB : <toolset>clang_tidy ;
+generators.register-linker clang_tidy.link : OBJ SEARCHED_LIB STATIC_LIB : EXE : <toolset>clang_tidy ;
+generators.register-linker clang_tidy.link.dll : OBJ SEARCHED_LIB STATIC_LIB : SHARED_LIB : <toolset>clang_tidy ;
+
+rule init ( version ? :  command * : options * ) {
+  command = [ common.get-invocation-command clang_tidy : clang-tidy
+    : $(command) ] ;
+
+  # Determine the version
+  if $(command) {
+    local command-string = \"$(command)\" ;
+    command-string = $(command-string:J=" ") ;
+    version ?= [ MATCH "version ([0-9.]+)"
+      : [ SHELL "$(command-string) --version" ] ] ;
+  }
+
+  local condition = [ common.check-init-parameters clang_tidy
+    : version $(version) ] ;
+
+  common.handle-options clang_tidy : $(condition) : $(command) : $(options) ;
+}
+
+###############################################################################
+# Flags
+
+toolset.flags clang_tidy.compile OPTIONS <cflags> ;
+toolset.flags clang_tidy.compile.c++ OPTIONS <cxxflags> ;
+
+toolset.flags clang_tidy.compile DEFINES <define> ;
+toolset.flags clang_tidy.compile INCLUDES <include> ;
+
+toolset.flags clang_tidy.compile OPTIONS <optimization>off   : ;
+toolset.flags clang_tidy.compile OPTIONS <optimization>speed : -O3 ;
+toolset.flags clang_tidy.compile OPTIONS <optimization>space : -Os ;
+
+toolset.flags clang_tidy.compile OPTIONS <inlining>off  : -fno-inline ;
+# For clang, 'on' and 'full' are identical.
+toolset.flags clang_tidy.compile OPTIONS <inlining>on   : -Wno-inline ;
+toolset.flags clang_tidy.compile OPTIONS <inlining>full : -Wno-inline ;
+
+toolset.flags clang_tidy.compile OPTIONS <warnings>off : -w ;
+toolset.flags clang_tidy.compile OPTIONS <warnings>on  : -Wall ;
+toolset.flags clang_tidy.compile OPTIONS <warnings>all : -Wall -pedantic ;
+toolset.flags clang_tidy.compile OPTIONS <warnings-as-errors>on : -Werror ;
+
+toolset.flags clang_tidy.compile OPTIONS <debug-symbols>on : -g ;
+toolset.flags clang_tidy.compile OPTIONS <profiling>on : -pg ;
+toolset.flags clang_tidy.compile OPTIONS <rtti>off : -fno-rtti ;
+
+local rule cxxstd-flags ( toolset : condition * : options * )
+{
+    toolset.flags $(toolset).compile.c++ OPTIONS $(condition) : $(options) : unchecked ;
+    toolset.flags $(toolset).link OPTIONS $(condition) : $(options) : unchecked ;
+}
+
+cxxstd-flags clang_tidy : <cxxstd>11/<cxxstd-dialect>iso : -std=c++11 ;
+cxxstd-flags clang_tidy : <cxxstd>11/<cxxstd-dialect>gnu : -std=gnu++11 ;
+cxxstd-flags clang_tidy : <cxxstd>14/<cxxstd-dialect>iso : -std=c++14 ;
+cxxstd-flags clang_tidy : <cxxstd>14/<cxxstd-dialect>gnu : -std=gnu++14 ;
+cxxstd-flags clang_tidy : <cxxstd>17/<cxxstd-dialect>iso : -std=c++17 ;
+cxxstd-flags clang_tidy : <cxxstd>17/<cxxstd-dialect>gnu : -std=gnu++17 ;
+
+###############################################################################
+# C and C++ compilation
+
+TOUCH = [ common.file-creation-command ] ;
+
+actions compile.c++ {
+  "$(CONFIG_COMMAND)" -quiet -header-filter=* -warnings-as-errors=* "$(>)" -- -x c++ $(OPTIONS) -D$(DEFINES) -I"$(INCLUDES)" \
+    && $(TOUCH) "$(<)"
+}
+
+actions compile.c {
+  "$(CONFIG_COMMAND)" -quiet -header-filter=* -warnings-as-errors=* "$(>)" -- -x c $(OPTIONS) -D$(DEFINES) -I"$(INCLUDES)" \
+    && $(TOUCH) "$(<)"
+}
+
+###############################################################################
+# Linking
+
+actions archive {
+  $(TOUCH) "$(<)"
+}
+
+actions link {
+  $(TOUCH) "$(<)"
+}
+
+actions link.dll {
+  $(TOUCH) "$(<)"
+}
diff -Naupr a/fuzzers/Jamfile b/fuzzers/Jamfile
--- a/fuzzers/Jamfile	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/Jamfile	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,102 @@
+# to fuzz libtorrent, you need a recent version of clang.
+
+# if you have a favourite component to fuzz, you can run that specific binary
+# without specifying the "-runs=" argument, it's probably a good idea to seed
+# the fuzzing with the included corpus though
+
+import feature : feature ;
+
+use-project /torrent : .. ;
+
+feature fuzz : off external on : composite propagated link-incompatible ;
+feature.compose <fuzz>on : <cflags>-fsanitize=fuzzer <linkflags>-fsanitize=fuzzer ;
+
+feature sanitize : off on : composite propagated link-incompatible ;
+feature.compose <sanitize>on : <address-sanitizer>norecover <undefined-sanitizer>norecover ;
+
+# this is a build configuration that only does limited validation (i.e. no
+# sanitizers, invariant-checks, asserts etc.). The purpose is to quickly iterate
+# on inputs to build code coverage
+variant build_coverage : release : <sanitize>off <debug-symbols>on <asserts>off <invariant-checks>off ;
+
+project fuzzers
+	: requirements
+	<export-extra>on
+	<define>TORRENT_USE_IPV6=1
+	<define>_SCL_SECURE=1
+	<define>_GLIBCXX_DEBUG
+	<cxxflags>-fno-omit-frame-pointer
+	<linkflags>-fno-omit-frame-pointer
+	<library>/torrent//torrent
+	: default-build
+	<cxxstd>14
+	<fuzz>on
+	<threading>multi
+	<sanitize>on
+	<link>static
+	<variant>release
+	<debug-symbols>on
+	<debug-iterators>on
+	<export-extra>on
+	<asserts>on
+	<debug-symbols>on
+	;
+
+local TARGETS ;
+
+rule fuzzer ( name )
+{
+	exe $(name) : src/$(name).cpp : <fuzz>off:<source>main.cpp ;
+	TARGETS += $(name) ;
+}
+
+fuzzer torrent_info ;
+fuzzer parse_magnet_uri ;
+fuzzer bdecode_node ;
+fuzzer parse_int ;
+fuzzer sanitize_path ;
+fuzzer escape_path ;
+fuzzer file_storage_add_file ;
+fuzzer base32decode ;
+fuzzer base32encode ;
+fuzzer base64encode ;
+fuzzer escape_string ;
+fuzzer gzip ;
+fuzzer verify_encoding ;
+fuzzer convert_to_native ;
+fuzzer convert_from_native ;
+fuzzer utf8_codepoint ;
+fuzzer http_parser ;
+fuzzer upnp ;
+fuzzer dht_node ;
+fuzzer utp ;
+fuzzer resume_data ;
+fuzzer peer_conn ;
+fuzzer idna ;
+fuzzer parse_url ;
+fuzzer http_tracker ;
+fuzzer session_params ;
+fuzzer add_torrent ;
+
+local LARGE_TARGETS =
+	torrent_info
+	bdecode_node
+	http_parser
+	dht_node
+	utp
+	resume_data
+	file_storage_add_file
+	sanitize_path
+	upnp
+	peer_conn
+	http_tracker
+	session_params
+	add_torrent
+	;
+
+install stage : $(TARGETS) : <install-type>EXE <location>fuzzers ;
+install stage-large : $(LARGE_TARGETS) : <install-type>EXE <location>fuzzers ;
+
+explicit stage ;
+explicit stage-large ;
+
diff -Naupr a/fuzzers/LICENSE b/fuzzers/LICENSE
--- a/fuzzers/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/LICENSE	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,29 @@
+BSD 3-Clause License
+
+Copyright (c) 2017, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -Naupr a/fuzzers/README.rst b/fuzzers/README.rst
--- a/fuzzers/README.rst	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/README.rst	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,64 @@
+libtorrent fuzzing
+==================
+
+Fuzzing of various libtorrent APIs (both internal and external),
+inspired by Kostya Serebryany's `cppcon 2017 presentation`_
+
+This project requires:
+
+.. _`cppcon 2017 presentation`: https://www.youtube.com/watch?v=k-Cv8Q3zWNQ&index=36&list=PLHTh1InhhwT6bwIpRk0ZbCA0N2p1taxd6
+
+clang
+.....
+
+A very recent version of clang that supports libFuzzer.
+clang-5.0 may not be recent enough, you may have to build head from source.
+
+boost-build
+...........
+
+Also known as ``b2``. To configure boost build with your fresh clang build,
+create a ``~/user-config.jam`` with something like this in it (example for macOS)::
+
+	using darwin : 6.0 : ~/Documents/dev/clang/build/bin/clang++ ;
+
+Or on Linux::
+
+	using clang ;
+
+corpus
+......
+
+The corpus is the set of inputs that has been built by libFuzzer. It's the seed
+for testing more mutations. The corpus is not checked into the repository,
+before running the fuzzer it is advised to download and unzip the corpus
+associated with the latest release on github.
+
+	https://github.com/arvidn/libtorrent/releases/download/libtorrent_1_2_0/corpus.zip
+
+Uzip the corpus in the fuzzers directory::
+
+	unzip corpus.zip
+
+building
+........
+
+To build the fuzzers::
+
+	b2 clang stage
+
+The fuzzers binaries are placed in a directory called `fuzzers`.
+
+running
+.......
+
+To run the fuzzers, there's a convenience `run.sh` script that launches all
+fuzzers in parallel. By default, each fuzzer runs for 48 hours. This can be
+adjusted in the `run.sh` script.
+
+contribute
+..........
+
+Please consider contributing back any updated corpuses (amended by more seed
+inputs) or fuzzers for more APIs in libtorrent.
+
diff -Naupr a/fuzzers/main.cpp b/fuzzers/main.cpp
--- a/fuzzers/main.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/main.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+#include <iostream>
+#include <cstdint>
+#include <vector>
+#include <fstream>
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const*, size_t);
+
+int main(int const argc, char const** argv)
+{
+	if (argc < 2)
+	{
+		std::cout << "usage: " << argv[0] << " test-case-file\n";
+		return 1;
+	}
+
+	std::fstream f(argv[1], std::ios_base::in | std::ios_base::binary);
+	f.seekg(0, std::ios_base::end);
+	auto const s = f.tellg();
+	f.seekg(0, std::ios_base::beg);
+	std::vector<std::uint8_t> v(static_cast<std::size_t>(s));
+	f.read(reinterpret_cast<char*>(v.data()), v.size());
+
+	return LLVMFuzzerTestOneInput(v.data(), v.size());
+}
+
diff -Naupr a/fuzzers/minimize.sh b/fuzzers/minimize.sh
--- a/fuzzers/minimize.sh	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/minimize.sh	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,18 @@
+#!/bin/bash
+set -e
+
+function minimize
+{
+mkdir corpus/${1}
+./fuzzers/${1} -artifact_prefix=./${1}- -merge=1 corpus/${1} prev-corpus/${1}
+}
+
+mv corpus prev-corpus
+mkdir corpus
+
+for file in fuzzers/*; do
+	minimize $(basename $file) &
+done
+
+wait
+
diff -Naupr a/fuzzers/run.sh b/fuzzers/run.sh
--- a/fuzzers/run.sh	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/run.sh	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+function run
+{
+# run for 48 hours
+nice ./fuzzers/${1} -max_total_time=172800 -timeout=10 -artifact_prefix=./${1}- corpus/${1}
+}
+
+for file in fuzzers/*; do
+	run $(basename $file) &
+done
+
+wait
diff -Naupr a/fuzzers/src/add_torrent.cpp b/fuzzers/src/add_torrent.cpp
--- a/fuzzers/src/add_torrent.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/add_torrent.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,243 @@
+/*
+
+Copyright (c) 2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <memory>
+#include <iostream>
+#include <boost/optional.hpp>
+
+#include "libtorrent/session.hpp"
+#include "libtorrent/session_params.hpp"
+#include "libtorrent/settings_pack.hpp"
+#include "libtorrent/create_torrent.hpp"
+#include "libtorrent/torrent_info.hpp"
+#include "libtorrent/alert_types.hpp"
+#include "libtorrent/random.hpp"
+#include "libtorrent/deadline_timer.hpp"
+#include "libtorrent/disk_interface.hpp" // for default_block_size
+#include "libtorrent/aux_/merkle.hpp"
+#include "libtorrent/hasher.hpp"
+#include "libtorrent/disabled_disk_io.hpp"
+#include "read_bits.hpp"
+
+using namespace lt;
+
+lt::session_params g_params;
+io_context g_ioc;
+std::shared_ptr<lt::torrent_info> g_torrent;
+std::vector<sha256_hash> g_tree;
+
+int const piece_size = 1024 * 1024;
+int const blocks_per_piece = piece_size / lt::default_block_size;
+int const num_pieces = 10;
+int const num_leafs = merkle_num_leafs(num_pieces * blocks_per_piece);
+int const num_nodes = merkle_num_nodes(num_leafs);
+int const first_leaf = merkle_first_leaf(num_leafs);
+
+extern "C" int LLVMFuzzerInitialize(int *argc, char ***argv)
+{
+	lt::settings_pack& pack = g_params.settings;
+	// set up settings pack we'll be using
+	pack.set_int(settings_pack::tick_interval, 1);
+	pack.set_int(settings_pack::alert_mask, 0);
+	pack.set_int(settings_pack::out_enc_policy, settings_pack::pe_disabled);
+	pack.set_int(settings_pack::in_enc_policy, settings_pack::pe_disabled);
+	pack.set_int(settings_pack::aio_threads, 0);
+
+	// don't waste time making outbound connections
+	pack.set_bool(settings_pack::enable_outgoing_tcp, false);
+	pack.set_bool(settings_pack::enable_outgoing_utp, false);
+	pack.set_bool(settings_pack::enable_upnp, false);
+	pack.set_bool(settings_pack::enable_natpmp, false);
+	pack.set_bool(settings_pack::enable_dht, false);
+	pack.set_bool(settings_pack::enable_lsd, false);
+	pack.set_bool(settings_pack::enable_ip_notifier, false);
+	pack.set_str(settings_pack::listen_interfaces, "127.0.0.1:0");
+
+	g_params.disk_io_constructor = lt::disabled_disk_io_constructor;
+
+	// create a torrent
+	file_storage fs;
+	std::int64_t const total_size = std::int64_t(piece_size) * num_pieces;
+	fs.add_file("test_file", total_size);
+
+	g_tree.resize(num_nodes);
+
+	create_torrent t(fs, piece_size);
+
+	std::vector<char> piece(piece_size, 0);
+	lt::span<char const> piece_span(piece);
+	std::vector<sha256_hash> piece_tree(merkle_num_nodes(blocks_per_piece));
+	for (piece_index_t i : fs.piece_range())
+	{
+		std::memset(piece.data(), char(static_cast<int>(i) & 0xff), piece.size());
+		t.set_hash(piece_index_t(i), lt::hasher(piece).final());
+
+		for (int k = 0; k < blocks_per_piece; ++k)
+		{
+			auto const h = lt::hasher256(piece_span.subspan(
+				k * lt::default_block_size, lt::default_block_size)).final();
+			piece_tree[std::size_t(k)] = h;
+			g_tree[std::size_t(first_leaf + static_cast<int>(i) * blocks_per_piece + k)] = h;
+		}
+
+		auto const r = merkle_root(piece_tree);
+		t.set_hash2(file_index_t{0}, piece_index_t::diff_type(i), r);
+	}
+
+	merkle_fill_tree(g_tree, num_leafs);
+
+	std::vector<char> buf;
+	bencode(std::back_inserter(buf), t.generate());
+	g_torrent = std::make_shared<torrent_info>(buf, from_span);
+
+	return 0;
+}
+
+lt::add_torrent_params generate_atp(std::uint8_t const* data, size_t size)
+{
+	read_bits bits(data, size);
+	lt::add_torrent_params ret;
+	ret.ti = g_torrent;
+	ret.info_hashes = g_torrent->info_hashes();
+	ret.save_path = ".";
+	ret.file_priorities.resize(bits.read(2));
+	for (auto& p : ret.file_priorities)
+		p = lt::download_priority_t(bits.read(3));
+	ret.flags = lt::torrent_flags_t(bits.read(24));
+	int const num_unfinished = bits.read(4);
+	for (int i = 0; i < num_unfinished; ++i)
+	{
+		auto& mask = ret.unfinished_pieces[piece_index_t(bits.read(32))];
+		mask.resize(bits.read(5));
+		for (int i = 0; i < mask.size(); ++i)
+			if (bits.read(1)) mask.set_bit(i); else mask.set_bit(i);
+	}
+	ret.have_pieces.resize(bits.read(6));
+	for (int i = 0; i < ret.have_pieces.size(); ++i)
+		if (bits.read(1)) ret.have_pieces.set_bit(i); else ret.have_pieces.set_bit(i);
+
+	ret.verified_pieces.resize(bits.read(6));
+	for (int i = 0; i < ret.verified_pieces.size(); ++i)
+		if (bits.read(1)) ret.verified_pieces.set_bit(i); else ret.verified_pieces.set_bit(i);
+
+	ret.piece_priorities.resize(bits.read(6));
+	for (auto& p : ret.piece_priorities)
+		p = lt::download_priority_t(bits.read(1));
+
+	// if we read a 1 here, initialize the merkle tree fields correctly
+	if (bits.read(1))
+	{
+		ret.merkle_trees.resize(1);
+		ret.merkle_tree_mask.resize(1);
+		ret.verified_leaf_hashes.resize(1);
+		ret.verified_leaf_hashes[0].resize(num_leafs, true);
+
+		auto& t = ret.merkle_trees[0];
+		auto& mask = ret.merkle_tree_mask[0];
+		mask.resize(num_nodes, false);
+		int idx = -1;
+		for (auto const& h : g_tree)
+		{
+			++idx;
+			if (h.is_all_zeros()) continue;
+			mask[std::size_t(idx)] = true;
+			t.push_back(g_tree[std::size_t(idx)]);
+		}
+	}
+	else
+	{
+		ret.merkle_trees.resize(bits.read(2));
+		for (auto& t : ret.merkle_trees)
+		{
+			std::size_t block = 0;
+			t.resize(bits.read(13));
+			for (auto& h : t)
+			{
+				h = g_tree[block++];
+				if (block >= g_tree.size()) block = 0;
+			}
+		}
+		ret.merkle_tree_mask.resize(bits.read(2));
+		for (auto& m : ret.merkle_tree_mask)
+		{
+			m.resize(bits.read(13));
+			for (std::size_t i = 0; i < m.size(); ++i)
+				m[i] = bits.read(1);
+		}
+		ret.verified_leaf_hashes.resize(bits.read(2));
+		for (auto& m : ret.verified_leaf_hashes)
+		{
+			m.resize(bits.read(4));
+			for (std::size_t i = 0; i < m.size(); ++i)
+				m[i] = bits.read(1);
+		}
+	}
+
+	ret.max_uploads = bits.read(32);
+	ret.max_connections = bits.read(32);
+	ret.upload_limit = bits.read(32);
+	ret.download_limit = bits.read(32);
+	ret.active_time = bits.read(32);
+	ret.finished_time = bits.read(32);
+	ret.seeding_time = bits.read(32);
+	ret.last_seen_complete = bits.read(32);
+	ret.num_complete = bits.read(32);
+	ret.num_incomplete = bits.read(32);
+	ret.num_downloaded = bits.read(32);
+
+	return ret;
+}
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	g_ioc.restart();
+	boost::optional<lt::session> ses(lt::session{g_params, g_ioc});
+
+	lt::add_torrent_params atp = generate_atp(data, size);
+
+	ses->async_add_torrent(atp);
+	auto proxy = ses->abort();
+	post(g_ioc, [&]{ ses.reset(); });
+
+	g_ioc.run_for(seconds(2));
+
+#if defined TORRENT_ASIO_DEBUGGING
+	lt::log_async();
+	lt::_async_ops.clear();
+	lt::_async_ops_nthreads = 0;
+	lt::_wakeups.clear();
+#endif
+
+	return 0;
+}
+
+
diff -Naupr a/fuzzers/src/base32decode.cpp b/fuzzers/src/base32decode.cpp
--- a/fuzzers/src/base32decode.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/base32decode.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/aux_/escape_string.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::base32decode({reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/base32encode.cpp b/fuzzers/src/base32encode.cpp
--- a/fuzzers/src/base32encode.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/base32encode.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/aux_/escape_string.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::base32encode({reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/base64encode.cpp b/fuzzers/src/base64encode.cpp
--- a/fuzzers/src/base64encode.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/base64encode.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/aux_/escape_string.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::base64encode({reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/bdecode_node.cpp b/fuzzers/src/bdecode_node.cpp
--- a/fuzzers/src/bdecode_node.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/bdecode_node.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/bdecode.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::error_code ec;
+	lt::bdecode({reinterpret_cast<char const*>(data), int(size)}, ec);
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/convert_from_native.cpp b/fuzzers/src/convert_from_native.cpp
--- a/fuzzers/src/convert_from_native.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/convert_from_native.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/aux_/escape_string.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::convert_from_native({reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/convert_to_native.cpp b/fuzzers/src/convert_to_native.cpp
--- a/fuzzers/src/convert_to_native.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/convert_to_native.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/aux_/escape_string.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::convert_to_native({reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/dht_node.cpp b/fuzzers/src/dht_node.cpp
--- a/fuzzers/src/dht_node.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/dht_node.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,102 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/kademlia/dht_tracker.hpp"
+#include "libtorrent/performance_counters.hpp"
+#include "libtorrent/kademlia/dht_observer.hpp"
+#include "libtorrent/ip_filter.hpp"
+#include "libtorrent/aux_/session_impl.hpp"
+
+#include <memory>
+
+using namespace lt;
+
+aux::session_settings sett;
+dht::dht_state state;
+std::unique_ptr<lt::dht::dht_storage_interface> dht_storage(dht::dht_default_storage_constructor(sett));
+
+counters cnt;
+
+struct obs : dht::dht_observer
+{
+	void set_external_address(lt::aux::listen_socket_handle const&, lt::address const& /* addr */
+		, lt::address const&) override
+	{}
+	int get_listen_port(aux::transport ssl, aux::listen_socket_handle const& s) override
+	{ return 6881; }
+
+	void get_peers(lt::sha1_hash const&) override {}
+	void outgoing_get_peers(sha1_hash const&
+		, sha1_hash const&, lt::udp::endpoint const&) override {}
+	void announce(sha1_hash const&, lt::address const&, int) override {}
+	bool on_dht_request(string_view
+		, dht::msg const&, entry&) override
+	{ return false; }
+
+#ifndef TORRENT_DISABLE_LOGGING
+
+	void log(dht_logger::module_t, char const*, ...) override {}
+
+	bool should_log(module_t) const override { return true; }
+	void log_packet(message_direction_t
+		, span<char const>
+		, lt::udp::endpoint const&) override {}
+#endif // TORRENT_DISABLE_LOGGING
+};
+
+obs o;
+io_context ios;
+dht::dht_tracker dht_node(&o
+	, ios
+	, [](aux::listen_socket_handle const&, udp::endpoint const&
+		, span<char const>, error_code&, udp_send_flags_t) {}
+	, sett
+	, cnt
+	, *dht_storage
+	, std::move(state));
+auto listen_socket = std::make_shared<aux::listen_socket_t>();
+aux::listen_socket_handle s(listen_socket);
+
+error_code ignore;
+lt::address_v4 src = make_address_v4("2.2.2.2", ignore);
+udp::endpoint ep(src, 6881);
+std::once_flag once_flag;
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	ep.address(src);
+	src = lt::address_v4(aux::plus_one(src.to_bytes()));
+	std::call_once(once_flag, []{ dht_node.new_socket(s); });
+	dht_node.incoming_packet(s, ep, {reinterpret_cast<char const*>(data), int(size)});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/escape_path.cpp b/fuzzers/src/escape_path.cpp
--- a/fuzzers/src/escape_path.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/escape_path.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/aux_/escape_string.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::escape_path({reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/escape_string.cpp b/fuzzers/src/escape_string.cpp
--- a/fuzzers/src/escape_string.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/escape_string.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/aux_/escape_string.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::escape_string({reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/file_storage_add_file.cpp b/fuzzers/src/file_storage_add_file.cpp
--- a/fuzzers/src/file_storage_add_file.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/file_storage_add_file.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+
+Copyright (c) 2019-2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/file_storage.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::file_storage fs;
+	// we expect this call to fail sometimes
+	try {
+		fs.add_file({reinterpret_cast<char const*>(data), size}, 1);
+	}
+	catch (...) {}
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/gzip.cpp b/fuzzers/src/gzip.cpp
--- a/fuzzers/src/gzip.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/gzip.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/gzip.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::error_code ec;
+	std::vector<char> out;
+	lt::inflate_gzip({reinterpret_cast<char const*>(data), int(size)}, out
+		, 100000, ec);
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/http_parser.cpp b/fuzzers/src/http_parser.cpp
--- a/fuzzers/src/http_parser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/http_parser.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,60 @@
+/*
+
+Copyright (c) 2019-2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/http_parser.hpp"
+#include "libtorrent/string_view.hpp"
+
+void feed_bytes(lt::http_parser& parser, lt::string_view str)
+{
+	for (int chunks = 1; chunks < 70; ++chunks)
+	{
+		parser.reset();
+		lt::string_view recv_buf;
+		for (;;)
+		{
+			int const chunk_size = std::min(chunks, int(str.size() - recv_buf.size()));
+			if (chunk_size == 0) break;
+			recv_buf = str.substr(0, recv_buf.size() + std::size_t(chunk_size));
+			bool error = false;
+			parser.incoming(recv_buf, error);
+			if (error) break;
+		}
+	}
+}
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::http_parser p;
+	feed_bytes(p, {reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/http_tracker.cpp b/fuzzers/src/http_tracker.cpp
--- a/fuzzers/src/http_tracker.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/http_tracker.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+
+Copyright (c) 2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/http_tracker_connection.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::error_code ec;
+	lt::sha1_hash const ih("abababababababababab");
+	lt::span<char const> const input(reinterpret_cast<char const*>(data), size);
+
+	parse_tracker_response(input, ec, lt::tracker_request_flags_t{}, ih);
+	parse_tracker_response(input, ec, lt::tracker_request::scrape_request, ih);
+#if TORRENT_USE_I2P
+	parse_tracker_response(input, ec, lt::tracker_request::i2p, ih);
+#endif
+
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/idna.cpp b/fuzzers/src/idna.cpp
--- a/fuzzers/src/idna.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/idna.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+
+Copyright (c) 2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/parse_url.hpp"
+#include "libtorrent/string_view.hpp"
+
+#include <cstdint>
+
+extern "C" int LLVMFuzzerTestOneInput(std::uint8_t const* data, size_t size)
+{
+    lt::is_idna(lt::string_view(reinterpret_cast<char const*>(data), size));
+    return 0;
+}
diff -Naupr a/fuzzers/src/parse_int.cpp b/fuzzers/src/parse_int.cpp
--- a/fuzzers/src/parse_int.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/parse_int.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+#include "libtorrent/bdecode.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::bdecode_errors::error_code_enum ec;
+	std::int64_t val = 0;
+	lt::parse_int(reinterpret_cast<char const*>(data), reinterpret_cast<char const*>(data) + size, ':', val, ec);
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/parse_magnet_uri.cpp b/fuzzers/src/parse_magnet_uri.cpp
--- a/fuzzers/src/parse_magnet_uri.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/parse_magnet_uri.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/magnet_uri.hpp"
+#include "libtorrent/add_torrent_params.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::error_code ec;
+	lt::add_torrent_params params;
+	lt::parse_magnet_uri({reinterpret_cast<char const*>(data), size}
+		, params, ec);
+	return 0;
+}
+
+
diff -Naupr a/fuzzers/src/parse_url.cpp b/fuzzers/src/parse_url.cpp
--- a/fuzzers/src/parse_url.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/parse_url.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+
+Copyright (c) 2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/parse_url.hpp"
+
+#include <cstdint>
+#include <string>
+
+extern "C" int LLVMFuzzerTestOneInput(std::uint8_t const* data, size_t size)
+{
+	lt::error_code ec;
+	lt::parse_url_components(std::string(reinterpret_cast<char const*>(data), size), ec);
+	return 0;
+}
diff -Naupr a/fuzzers/src/peer_conn.cpp b/fuzzers/src/peer_conn.cpp
--- a/fuzzers/src/peer_conn.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/peer_conn.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,222 @@
+/*
+
+Copyright (c) 2019-2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <memory>
+#include <iostream>
+#include "libtorrent/session.hpp"
+#include "libtorrent/session_params.hpp"
+#include "libtorrent/settings_pack.hpp"
+#include "libtorrent/create_torrent.hpp"
+#include "libtorrent/torrent_info.hpp"
+#include "libtorrent/alert_types.hpp"
+#include "libtorrent/random.hpp"
+
+#include "libtorrent/io_context.hpp"
+
+using namespace lt;
+
+std::unique_ptr<session> g_ses;
+info_hash_t g_info_hash;
+int g_listen_port = 0;
+io_context g_ios;
+
+//#define DEBUG_LOGGING 1
+
+extern "C" int LLVMFuzzerInitialize(int *argc, char ***argv)
+{
+	// set up a session
+	settings_pack pack;
+	pack.set_int(settings_pack::piece_timeout, 1);
+	pack.set_int(settings_pack::request_timeout, 1);
+	pack.set_int(settings_pack::peer_timeout, 1);
+	pack.set_int(settings_pack::peer_connect_timeout, 1);
+	pack.set_int(settings_pack::inactivity_timeout, 1);
+	pack.set_int(settings_pack::handshake_timeout, 1);
+
+#ifdef DEBUG_LOGGING
+	pack.set_int(settings_pack::alert_mask, 0xffffff);
+#else
+	pack.set_int(settings_pack::alert_mask, alert_category::connect
+		| alert_category::error
+		| alert_category::status
+		| alert_category::peer);
+#endif
+
+	pack.set_int(settings_pack::out_enc_policy, settings_pack::pe_disabled);
+	pack.set_int(settings_pack::in_enc_policy, settings_pack::pe_disabled);
+
+	// don't waste time making outbound connections
+	pack.set_bool(settings_pack::enable_outgoing_tcp, false);
+	pack.set_bool(settings_pack::enable_outgoing_utp, false);
+	pack.set_bool(settings_pack::enable_upnp, false);
+	pack.set_bool(settings_pack::enable_natpmp, false);
+	pack.set_bool(settings_pack::enable_dht, false);
+	pack.set_bool(settings_pack::enable_lsd, false);
+	pack.set_bool(settings_pack::enable_ip_notifier, false);
+
+	// pick an available listen port and only listen on loopback
+	pack.set_str(settings_pack::listen_interfaces, "127.0.0.1:0");
+
+	g_ses = std::unique_ptr<session>(new lt::session(pack));
+
+	// create a torrent
+	file_storage fs;
+	int const piece_size = 1024 * 1024;
+	std::int64_t const total_size = std::int64_t(piece_size) * 100;
+	fs.add_file("test_file", total_size);
+
+	create_torrent t(fs, piece_size);
+
+	for (piece_index_t i : fs.piece_range())
+		t.set_hash(i, sha1_hash("abababababababababab"));
+
+	for (file_index_t const f : fs.file_range())
+		for (piece_index_t::diff_type i : fs.file_piece_range(f))
+			t.set_hash2(f, i, sha256_hash("abababababababababababababababababababababababababababababababab"));
+
+	std::vector<char> buf;
+	bencode(std::back_inserter(buf), t.generate());
+	auto ti = std::make_shared<torrent_info>(buf, from_span);
+
+	// remember the info-hash to give the fuzzer a chance to connect to it
+	g_info_hash = ti->info_hashes();
+
+	// add the torrent to the session
+	add_torrent_params atp;
+	atp.ti = std::move(ti);
+	atp.save_path = ".";
+
+	g_ses->add_torrent(std::move(atp));
+
+	// pull the alerts for the listen socket we ended up using
+	time_point const end_time = clock_type::now() + seconds(5);
+	bool started = false;
+	while (g_listen_port == 0 || !started)
+	{
+		std::vector<alert*> alerts;
+		auto const now = clock_type::now();
+		if (now > end_time) return -1;
+
+		g_ses->wait_for_alert(end_time - now);
+		g_ses->pop_alerts(&alerts);
+
+		for (auto const a : alerts)
+		{
+			std::cout << a->message() << '\n';
+			if (auto la = alert_cast<listen_succeeded_alert>(a))
+			{
+				if (la->socket_type == socket_type_t::tcp)
+				{
+					g_listen_port = la->port;
+					std::cout << "listening on " << g_listen_port << '\n';
+				}
+			}
+			if (alert_cast<torrent_resumed_alert>(a))
+			{
+				started = true;
+			}
+		}
+	}
+
+	// we have to destruct the session before global destructors, such as the
+	// system error code category. The session objects rely on error_code during
+	// its destruction
+	std::atexit([]{ g_ses.reset(); });
+
+	return 0;
+}
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	if (size < 8) return 0;
+
+#ifdef DEBUG_LOGGING
+	time_point const start_time = clock_type::now();
+#endif
+	// connect
+	tcp::socket s(g_ios);
+	error_code ec;
+	do {
+		ec.clear();
+		error_code ignore;
+		s.connect(tcp::endpoint(make_address("127.0.0.1", ignore), g_listen_port), ec);
+	} while (ec == boost::system::errc::interrupted);
+
+	// bittorrent handshake
+
+	std::vector<char> handshake(1 + 19 + 8 + 20 + 20 + size - 8);
+	std::memcpy(handshake.data(), "\x13" "BitTorrent protocol", 20);
+	std::memcpy(handshake.data() + 20, data, 8);
+	std::memcpy(handshake.data() + 28, g_info_hash.get_best().data(), 20);
+	lt::aux::random_bytes({handshake.data() + 48, 20});
+	data += 8;
+	size -= 8;
+	std::memcpy(handshake.data() + 68, data, size);
+
+	// we're likely to fail to write entire (garbage) messages, as libtorrent may
+	// disconnect us half-way through. This may fail with broken_pipe for
+	// instance
+	error_code ignore;
+	boost::asio::write(s, boost::asio::buffer(handshake), ignore);
+
+	s.close();
+
+	// wait for the alert saying the connection was closed
+
+	time_point const end_time = clock_type::now() + seconds(3);
+	for (;;)
+	{
+		std::vector<alert*> alerts;
+		auto const now = clock_type::now();
+		if (now > end_time) return -1;
+
+		g_ses->wait_for_alert(end_time - now);
+		g_ses->pop_alerts(&alerts);
+
+		for (auto const a : alerts)
+		{
+#ifdef DEBUG_LOGGING
+			std::cout << duration_cast<milliseconds>(a->timestamp() - start_time).count()
+				<< ": " << a->message() << '\n';
+#endif
+			if (alert_cast<peer_error_alert>(a)
+				|| alert_cast<peer_disconnected_alert>(a))
+			{
+				goto done;
+			}
+		}
+	}
+done:
+
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/read_bits.hpp b/fuzzers/src/read_bits.hpp
--- a/fuzzers/src/read_bits.hpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/read_bits.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+
+Copyright (c) 2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+struct read_bits
+{
+	read_bits(std::uint8_t const* d, std::size_t s)
+		: m_data(d), m_size(s)
+	{}
+
+	int read(int bits)
+	{
+		if (m_size == 0) return 0;
+		int ret = 0;
+		while (bits > 0 && m_size > 0)
+		{
+			int const bits_to_copy = std::min(8 - m_bit, bits);
+			ret <<= bits_to_copy;
+			ret |= ((*m_data) >> m_bit) & ((1 << bits_to_copy) - 1);
+			m_bit += bits_to_copy;
+			bits -= bits_to_copy;
+			if (m_bit == 8)
+			{
+				--m_size;
+				++m_data;
+				m_bit = 0;
+			}
+		}
+		return ret;
+	}
+private:
+	std::uint8_t const* m_data;
+	std::size_t m_size;
+	int m_bit = 0;
+};
+
+
diff -Naupr a/fuzzers/src/resume_data.cpp b/fuzzers/src/resume_data.cpp
--- a/fuzzers/src/resume_data.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/resume_data.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+
+Copyright (c) 2019-2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <cstdint>
+#include "libtorrent/read_resume_data.hpp"
+#include "libtorrent/write_resume_data.hpp"
+#include "libtorrent/add_torrent_params.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::error_code ec;
+	auto ret = lt::read_resume_data({reinterpret_cast<char const*>(data), int(size)}, ec);
+	auto buf = write_resume_data_buf(ret);
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/sanitize_path.cpp b/fuzzers/src/sanitize_path.cpp
--- a/fuzzers/src/sanitize_path.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/sanitize_path.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/torrent_info.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	std::string out;
+	lt::aux::sanitize_append_path_element(out, {reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/session_params.cpp b/fuzzers/src/session_params.cpp
--- a/fuzzers/src/session_params.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/session_params.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <cstdint>
+#include "libtorrent/session_params.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	try {
+	auto ret = lt::read_session_params({reinterpret_cast<char const*>(data), int(size)});
+	} catch (...) {}
+	return 0;
+}
+
+
diff -Naupr a/fuzzers/src/torrent_info.cpp b/fuzzers/src/torrent_info.cpp
--- a/fuzzers/src/torrent_info.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/torrent_info.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/torrent_info.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	lt::error_code ec;
+	lt::torrent_info ti({reinterpret_cast<char const*>(data), int(size)}, ec, lt::from_span);
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/upnp.cpp b/fuzzers/src/upnp.cpp
--- a/fuzzers/src/upnp.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/upnp.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/upnp.hpp"
+#include "libtorrent/xml_parse.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	using namespace std::placeholders;
+
+	lt::parse_state s;
+	lt::xml_parse({reinterpret_cast<char const*>(data), size}
+		, std::bind(&lt::find_control_url, _1, _2, std::ref(s)));
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/utf8_codepoint.cpp b/fuzzers/src/utf8_codepoint.cpp
--- a/fuzzers/src/utf8_codepoint.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/utf8_codepoint.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+
+Copyright (c) 2019-2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/utf8.hpp"
+
+#include <cstdint>
+
+extern "C" int LLVMFuzzerTestOneInput(std::uint8_t const* data, size_t size)
+{
+	if (size == 0) return 0;
+	lt::parse_utf8_codepoint({reinterpret_cast<char const*>(data), size});
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/utp.cpp b/fuzzers/src/utp.cpp
--- a/fuzzers/src/utp.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/utp.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,70 @@
+/*
+
+Copyright (c) 2019, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/aux_/utp_socket_manager.hpp"
+#include "libtorrent/aux_/session_settings.hpp"
+#include "libtorrent/performance_counters.hpp"
+#include "libtorrent/aux_/utp_stream.hpp"
+#include "libtorrent/udp_socket.hpp"
+
+using namespace lt;
+
+io_context ios;
+lt::aux::session_settings sett;
+counters cnt;
+
+aux::utp_socket_manager man(
+	[](std::weak_ptr<aux::utp_socket_interface>, udp::endpoint const&, span<char const>, error_code&, udp_send_flags_t){}
+	, [](aux::socket_type){}
+	, ios
+	, sett
+	, cnt
+	, nullptr);
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	std::unique_ptr<aux::utp_socket_impl> sock;
+	{
+		aux::utp_stream str(ios);
+		sock = std::make_unique<aux::utp_socket_impl>(1, 0, &str, man);
+		str.set_impl(sock.get());
+		udp::endpoint ep;
+		time_point ts(seconds(100));
+		span<char const> buf(reinterpret_cast<char const*>(data), size);
+		sock->incoming_packet(buf, ep, ts);
+
+		// clear any deferred acks
+		man.socket_drained();
+	}
+	return 0;
+}
+
diff -Naupr a/fuzzers/src/verify_encoding.cpp b/fuzzers/src/verify_encoding.cpp
--- a/fuzzers/src/verify_encoding.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/src/verify_encoding.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+
+Copyright (c) 2019-2020, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/torrent_info.hpp"
+
+extern "C" int LLVMFuzzerTestOneInput(uint8_t const* data, size_t size)
+{
+	if (size == 0) return 0;
+	std::string str{reinterpret_cast<char const*>(data), size};
+	lt::aux::verify_encoding(str);
+	return 0;
+}
+
diff -Naupr a/fuzzers/tools/generate_initial_corpus.py b/fuzzers/tools/generate_initial_corpus.py
--- a/fuzzers/tools/generate_initial_corpus.py	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/tools/generate_initial_corpus.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,214 @@
+import os
+import shutil
+import hashlib
+import struct
+import random
+
+corpus_dirs = [
+    'torrent_info', 'upnp', 'gzip', 'base32decode', 'base32encode',
+    'base64encode', 'bdecode_node', 'convert_from_native', 'convert_to_native',
+    'dht_node', 'escape_path', 'escape_string', 'file_storage_add_file',
+    'http_parser', 'lazy_bdecode', 'parse_int', 'parse_magnet_uri', 'resume_data',
+    'sanitize_path', 'utf8_codepoint', 'utp',
+    'verify_encoding', 'peer_conn', 'add_torrent', 'idna', 'parse_url', 'http_tracker']
+
+for p in corpus_dirs:
+    try:
+        os.makedirs(os.path.join('corpus', p))
+    except Exception as e:
+        print(e)
+
+torrent_dir = '../test/test_torrents'
+for f in os.listdir(torrent_dir):
+    shutil.copy(os.path.join(torrent_dir, f), os.path.join('corpus', 'torrent_info'))
+
+xml_tests = [
+    '<a blah="b"></a>', '<a b=c></a>', '<a b"c"></a>', '<a b="c></a>',
+    '<![CDATA[<sender>John Smith</sender>]]>', '<![CDATA[<sender>John S',
+    '<!-- comment -->', '<empty></empty>', '<tag',
+    '''<?xml version="1.0" encoding="ISO-8859-1" ?>
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"></xs:schema>''',
+    '<selfclosing />']
+
+for x in xml_tests:
+    name = hashlib.sha1(x.encode('ascii')).hexdigest()
+    with open(os.path.join('corpus', 'upnp', name), 'w+') as f:
+        f.write(x)
+
+gzip_dir = '../test'
+for f in ['zeroes.gz', 'corrupt.gz', 'invalid1.gz']:
+    shutil.copy(os.path.join(gzip_dir, f), os.path.join('corpus', 'gzip'))
+
+idna = ['....', 'xn--foo-.bar', 'foo.xn--bar-.com', 'Xn--foobar-', 'XN--foobar-', '..xnxn--foobar-']
+
+counter = 0
+for i in idna:
+    open(os.path.join('corpus', 'idna', '%d' % counter), 'w+').write(i)
+    counter += 1
+
+urls = ['https://user:password@example.com:8080/path?query']
+
+counter = 0
+for i in urls:
+    open(os.path.join('corpus', 'parse_url', '%d' % counter), 'w+').write(i)
+    counter += 1
+
+counter = 0
+tracker_fields = ['interval', 'min interval', 'tracker id', 'failure reason',
+    'warning message', 'complete', 'incomplete', 'downloaded', 'downloaders', 'external ip']
+tracker_values = ['i-1e', 'i0e', 'i1800e', '6:foobar', 'de', '0:', 'le']
+peer_fields = ['peer id', 'ip', 'port']
+peer_values = ['i-1e', 'i0e', 'i1800e', '6:foobar', 'de', '0:', 'le', '9:127.0.0.1']
+
+for i in range(1000):
+    tracker_msg = 'd'
+    for f in tracker_fields:
+        tracker_msg += '%d:' % len(f) + f
+        tracker_msg += random.choice(tracker_values)
+
+    tracker_msg += '5:filesd20:ababababababababababd'
+    for f in tracker_fields:
+        tracker_msg += '%d:' % len(f) + f
+        tracker_msg += random.choice(tracker_values)
+    tracker_msg += 'ee'
+
+    tracker_msg += '5:peers'
+    if random.getrandbits(1) == 0:
+        tracker_msg += 'l'
+        for k in range(10):
+            tracker_msg += 'd'
+            for f in peer_fields:
+                tracker_msg += '%d:' % len(f) + f
+                tracker_msg += random.choice(peer_values)
+            tracker_msg += 'e'
+        tracker_msg += 'e'
+    else:
+        tracker_msg += '60:'
+        for k in range(6*10):
+            tracker_msg += chr(random.getrandbits(8))
+
+    tracker_msg += '6:peers6'
+    tracker_msg += '180:'
+    for k in range(18*10):
+        tracker_msg += chr(random.getrandbits(8))
+
+    tracker_msg += 'e'
+    open(os.path.join('corpus', 'http_tracker', '%d' % counter), 'w+').write(tracker_msg)
+    counter += 1
+
+# generate peer protocol messages
+messages = []
+
+
+def add_length(msg):
+    return struct.pack('>I', len(msg)) + msg
+
+
+def add_reserved(msg):
+    return b'\0\0\0\0\0\x18\0\x05' + msg
+
+
+# extended handshake
+def add_extended_handshake(msg):
+    ext_handshake = b'd1:md11:ut_metadatai1e11:lt_donthavei2e12:ut_holepunch' + \
+        b'i3e11:upload_onlyi4ee11:upload_onlyi1e10:share_modei1e4:reqqi1234e6:yourip4:0000e'
+    return add_length(struct.pack('BB', 20, 0) + ext_handshake) + msg
+
+
+# request
+for i in range(101):
+    for j in range(-1, 1):
+        messages.append(add_length(struct.pack('>Biii', 6, i, j, 0x4000)))
+
+# cancel
+for i in range(101):
+    for j in range(-1, 1):
+        messages.append(add_length(struct.pack('>Biii', 8, i, j, 0x4000)))
+
+# piece
+for i in range(101):
+    messages.append(add_length(struct.pack('>Bii', 7, i, 0) + (b'a' * 0x4000)))
+
+# single-byte
+for i in range(256):
+    messages.append(add_length(struct.pack('B', i)))
+
+# reject
+for i in range(101):
+    messages.append(add_length(struct.pack('>Biii', 16, i, 0, 0x4000)))
+
+# suggest
+for i in range(101):
+    messages.append(add_length(struct.pack('>Bi', 13, i)))
+
+# allow-fast
+for i in range(101):
+    messages.append(add_length(struct.pack('>Bi', 17, i)))
+
+# have
+for i in range(101):
+    messages.append(add_length(struct.pack('>Bi', 4, i)))
+
+# DHT-port
+for i in range(101):
+    messages.append(add_length(struct.pack('>BH', 9, i * 10)))
+
+# hash request
+for i in range(-10, 200, 20):
+    for j in range(-1, 1):
+        for k in range(-1, 1):
+            for m in range(-1, 1):
+                for n in range(-1, 1):
+                    messages.append(add_length(struct.pack('>Biiiii', 21, i, j, k, m, n)))
+
+# hash reject
+for i in range(-10, 200, 20):
+    for j in range(-1, 1):
+        for k in range(-1, 1):
+            for m in range(-1, 1):
+                for n in range(-1, 1):
+                    messages.append(add_length(struct.pack('>Biiiii', 23, i, j, k, m, n)))
+
+# hash
+for i in range(-10, 200, 20):
+    for j in range(-1, 1):
+        messages.append(add_length(struct.pack('>Biiiii', 22, i, j, 0, 2, 0) + (b'0' * 32 * 5)))
+
+# lt_dont_have
+messages.append(add_extended_handshake(add_length(struct.pack('>BBi', 20, 7, -1))))
+messages.append(add_extended_handshake(add_length(struct.pack('>BBi', 20, 7, 0))))
+messages.append(add_extended_handshake(add_length(struct.pack('>BBi', 20, 7, 0x7fffffff))))
+
+# share mode
+messages.append(add_extended_handshake(add_length(struct.pack('BBB', 20, 8, 255))))
+messages.append(add_extended_handshake(add_length(struct.pack('BBB', 20, 8, 0))))
+messages.append(add_extended_handshake(add_length(struct.pack('BBB', 20, 8, 1))))
+
+# holepunch
+for i in range(0, 2):
+    for j in range(0, 1):
+        messages.append(add_extended_handshake(add_length(struct.pack('>BBBBiH', 20, 4, i, j, 0, 0))))
+        messages.append(add_extended_handshake(add_length(struct.pack('>BBBBiiH', 20, 4, i, j, 0, 0, 0))))
+
+# upload only
+for i in range(0, 1):
+    messages.append(add_extended_handshake(add_length(struct.pack('BBB', 20, 3, i))))
+
+# bitfields
+bitfield_len = (100 + 7) // 8
+
+for i in range(256):
+    messages.append(add_length(struct.pack('B', 5) + (struct.pack('B', i) * bitfield_len)))
+
+mixes = []
+
+for i in range(200):
+    random.shuffle(messages)
+    mixes.append(b''.join(messages[1:20]))
+
+messages += mixes
+
+for m in messages:
+    f = open('corpus/peer_conn/%s' % hashlib.sha1(m).hexdigest(), 'wb+')
+    f.write(add_reserved(m))
+    f.close()
diff -Naupr a/fuzzers/tools/unify_corpus_names.py b/fuzzers/tools/unify_corpus_names.py
--- a/fuzzers/tools/unify_corpus_names.py	1970-01-01 01:00:00.000000000 +0100
+++ b/fuzzers/tools/unify_corpus_names.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,24 @@
+import sys
+import os
+import string
+import hashlib
+
+if len(sys.argv) < 2:
+    print('usage: unify_corpus_names.py <corpus-directory>\n')
+    sys.exit(1)
+
+root = sys.argv[1]
+for name in os.listdir(root):
+    f = os.path.join(root, name)
+
+    # ignore directories
+    if not os.path.isfile(f):
+        continue
+
+    # if the name already looks like a SHA-1 hash, ignore it
+    if len(name) == 40 and all(c in string.hexdigits for c in name):
+        continue
+
+    new_name = hashlib.sha1(open(f, 'rb').read()).hexdigest()
+    print('%s -> %s' % (f, new_name))
+    os.rename(f, os.path.join(root, new_name))
diff -Naupr a/include/libtorrent/aux_/apply_pad_files.hpp b/include/libtorrent/aux_/apply_pad_files.hpp
--- a/include/libtorrent/aux_/apply_pad_files.hpp	1970-01-01 01:00:00.000000000 +0100
+++ b/include/libtorrent/aux_/apply_pad_files.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,105 @@
+/*
+
+Copyright (c) 2021, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef TORRENT_APPLY_PAD_FILES_HPP_INCLUDED
+#define TORRENT_APPLY_PAD_FILES_HPP_INCLUDED
+
+#include "libtorrent/file_storage.hpp"
+#include "libtorrent/units.hpp"
+
+namespace libtorrent {
+namespace aux {
+
+// calls fun for every piece that overlaps a pad file, passing in the number
+// of bytes, in that piece, that's a padfile
+template <typename Fun>
+void apply_pad_files(file_storage const& fs, Fun&& fun)
+{
+	for (auto const i : fs.file_range())
+	{
+		if (!fs.pad_file_at(i) || fs.file_size(i) == 0) continue;
+
+		// pr points to the last byte of the pad file
+		peer_request const pr = fs.map_file(i, fs.file_size(i) - 1, 0);
+
+		int const piece_size = fs.piece_length();
+
+		// This pad file may be the last file in the torrent, and the
+		// last piece may have an odd size.
+		if ((pr.start + 1) % piece_size != 0 && i < prev(fs.end_file()))
+		{
+			// this is a pre-requisite of the piece picker. Pad files
+			// that don't align with pieces are kind of useless anyway.
+			// They probably aren't real padfiles, treat them as normal
+			// files.
+			continue;
+		}
+
+		// A pad file may span multiple pieces. This is especially
+		// likely in v2 torrents where file sizes are aligned to powers
+		// of two pieces. We loop from the end of the pad file
+		//
+		// For example, we may have this situation:
+		//
+		//                  pr.start
+		//                   |
+		//                   v
+		// +-----+-----+-----+
+		// |   ##|#####|#####|
+		// +-----+-----+-----+
+		//     \             /
+		//      - file_size -
+		//
+		// We need to declare all #-parts of the pieces as pad bytes to
+		// the piece picker.
+
+		piece_index_t piece = pr.piece;
+		std::int64_t pad_bytes_left = fs.file_size(i);
+
+		while (pad_bytes_left > 0)
+		{
+			// The last piece may have an odd size, that's why
+			// we ask for the piece size for every piece. (it would be
+			// odd, but it's still possible).
+			int const bytes = int(std::min(pad_bytes_left, std::int64_t(fs.piece_size(piece))));
+			TORRENT_ASSERT(bytes > 0);
+			fun(piece, bytes);
+			pad_bytes_left -= bytes;
+			--piece;
+		}
+	}
+}
+
+} // namespace aux
+} // namespace libtorrent
+
+#endif
diff -Naupr a/include/libtorrent/aux_/file_progress.hpp b/include/libtorrent/aux_/file_progress.hpp
--- a/include/libtorrent/aux_/file_progress.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/aux_/file_progress.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -68,6 +68,11 @@ namespace aux {
 
 		void export_progress(vector<std::int64_t, file_index_t> &fp);
 
+		std::int64_t total_on_disk() const
+		{
+			return m_total_on_disk;
+		}
+
 		bool empty() const { return m_file_progress.empty(); }
 		void clear();
 
@@ -76,6 +81,9 @@ namespace aux {
 
 	private:
 
+		// the total number of bytes downloaded to non-pad files
+		std::int64_t m_total_on_disk = 0;
+
 		// this vector contains the number of bytes completely
 		// downloaded (as in passed-hash-check) in each file.
 		// this lets us trigger on individual files completing
@@ -93,6 +101,7 @@ namespace aux {
 		// to make sure we never say we've downloaded more bytes of a file than
 		// its file size
 		vector<std::int64_t, file_index_t> m_file_sizes;
+		vector<bool, file_index_t> m_pad_file;
 #endif
 	};
 } }
diff -Naupr a/include/libtorrent/create_torrent.hpp b/include/libtorrent/create_torrent.hpp
--- a/include/libtorrent/create_torrent.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/create_torrent.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -41,6 +41,7 @@ POSSIBILITY OF SUCH DAMAGE.
 #include "libtorrent/config.hpp"
 #include "libtorrent/hasher.hpp"
 #include "libtorrent/string_view.hpp"
+#include "libtorrent/session_params.hpp" // for disk_io_constructor_type
 #include "libtorrent/aux_/vector.hpp"
 #include "libtorrent/aux_/path.hpp" // for combine_path etc.
 #include "libtorrent/fwd.hpp"
@@ -474,6 +475,9 @@ namespace aux {
 	TORRENT_EXPORT void set_piece_hashes(create_torrent& t, std::string const& p
 		, settings_interface const& settings
 		, std::function<void(piece_index_t)> const& f, error_code& ec);
+	TORRENT_EXPORT void set_piece_hashes(create_torrent& t, std::string const& p
+		, settings_interface const& settings, disk_io_constructor_type disk_io
+		, std::function<void(piece_index_t)> const& f, error_code& ec);
 	inline void set_piece_hashes(create_torrent& t, std::string const& p, error_code& ec)
 	{
 		set_piece_hashes(t, p, aux::nop, ec);
diff -Naupr a/include/libtorrent/enum_net.hpp b/include/libtorrent/enum_net.hpp
--- a/include/libtorrent/enum_net.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/enum_net.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -150,6 +150,11 @@ enum class if_state : std::uint8_t {
 	TORRENT_EXTRA_EXPORT bool has_internet_route(string_view device, int family
 		, span<ip_route const> routes);
 
+	// returns whether there are *any* routes to the internet in the routing
+	// table. This can be used to determine if the routing table is fully
+	// populated or not.
+	TORRENT_EXTRA_EXPORT bool has_any_internet_route(span<ip_route const> routes);
+
 	// attempt to bind socket to the device with the specified name. For systems
 	// that don't support SO_BINDTODEVICE the socket will be bound to one of the
 	// IP addresses of the specified device. In this case it is necessary to
diff -Naupr a/include/libtorrent/file_storage.hpp b/include/libtorrent/file_storage.hpp
--- a/include/libtorrent/file_storage.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/file_storage.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -233,9 +233,9 @@ namespace aux {
 		// We use int to index into file merkle trees, so a file may not contain more
 		// than INT_MAX entries. That means INT_MAX / 2 blocks (leafs) in each
 		// tree.
-		static constexpr std::int64_t max_file_size = std::min(
+		static constexpr std::int64_t max_file_size = (std::min)(
 			(std::int64_t(1) << 48) - 1
-			, std::int64_t(std::numeric_limits<int>::max() / 2) * default_block_size);
+			, std::int64_t((std::numeric_limits<int>::max)() / 2) * default_block_size);
 		static constexpr std::int64_t max_file_offset = (std::int64_t(1) << 48) - 1;
 
 		// returns true if the piece length has been initialized
@@ -287,6 +287,16 @@ namespace aux {
 		// ``symlink_path`` is the path the file is a symlink to. To make this a
 		// symlink you also need to set the file_storage::flag_symlink file flag.
 		//
+		// ``root_hash`` is an optional pointer to a 32 byte SHA-256 hash, being
+		// the merkle tree root hash for this file. This is only used for v2
+		// torrents. If the ``root hash`` is specified for one file, it has to
+		// be specified for all, otherwise this function will fail.
+		// Note that the buffer ``root_hash`` points to must out-live the
+		// file_storage object, it will not be copied. This parameter is only
+		// used when *loading* torrents, that already have their file hashes
+		// computed. When creating torrents, the file hashes will be computed by
+		// the piece hashes.
+		//
 		// If more files than one are added, certain restrictions to their paths
 		// apply. In a multi-file file storage (torrent), all files must share
 		// the same root directory.
@@ -703,6 +713,9 @@ namespace aux {
 	TORRENT_EXTRA_EXPORT std::tuple<piece_index_t, piece_index_t>
 	file_piece_range_inclusive(file_storage const& fs, file_index_t file);
 
+	TORRENT_EXTRA_EXPORT
+	std::int64_t size_on_disk(file_storage const& fs);
+
 } // namespace aux
 } // namespace libtorrent
 
diff -Naupr a/include/libtorrent/hash_picker.hpp b/include/libtorrent/hash_picker.hpp
--- a/include/libtorrent/hash_picker.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/hash_picker.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -159,6 +159,10 @@ namespace libtorrent
 
 		int piece_layer() const { return m_piece_layer; }
 
+#if TORRENT_USE_INVARIANT_CHECKS
+		void check_invariant(file_index_t idx) const;
+#endif
+
 	private:
 		// returns the number of proof layers needed to verify the node's hash
 		int layers_to_verify(node_index idx) const;
@@ -192,7 +196,7 @@ namespace libtorrent
 			file_index_t file;
 			// the piece from the start of the file
 			piece_index_t::diff_type piece;
-			time_point last_request;
+			time_point last_request = min_time();
 			int num_requests = 0;
 			bool operator==(piece_block_request const& o) const
 			{ return file == o.file && piece == o.piece; }
diff -Naupr a/include/libtorrent/http_stream.hpp b/include/libtorrent/http_stream.hpp
--- a/include/libtorrent/http_stream.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/http_stream.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -163,7 +163,7 @@ private:
 		// look for \n\n and \r\n\r\n
 		// both of which means end of http response header
 		bool found_end = false;
-		if (m_buffer[read_pos - 1] == '\n' && read_pos > 2)
+		if (read_pos > 2 && m_buffer[read_pos - 1] == '\n')
 		{
 			if (m_buffer[read_pos - 2] == '\n')
 			{
diff -Naupr a/include/libtorrent/peer_info.hpp b/include/libtorrent/peer_info.hpp
--- a/include/libtorrent/peer_info.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/peer_info.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -77,11 +77,12 @@ TORRENT_VERSION_NAMESPACE_2
 		peer_info(peer_info&&);
 		peer_info& operator=(peer_info const&);
 
-		// a string describing the software at the other end of the connection.
-		// In some cases this information is not available, then it will contain
-		// a string that may give away something about which software is running
-		// in the other end. In the case of a web seed, the server type and
-		// version will be a part of this string.
+		// A human readable string describing the software at the other end of
+		// the connection. In some cases this information is not available, then
+		// it will contain a string that may give away something about which
+		// software is running in the other end. In the case of a web seed, the
+		// server type and version will be a part of this string. This is UTF-8
+		// encoded.
 		std::string client;
 
 		// a bitfield, with one bit per piece in the torrent. Each bit tells you
diff -Naupr a/include/libtorrent/piece_picker.hpp b/include/libtorrent/piece_picker.hpp
--- a/include/libtorrent/piece_picker.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/piece_picker.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -80,9 +80,9 @@ namespace libtorrent {
 	{
 		// the number of pieces included in the "set"
 		int num_pieces;
-		// the number of blocks, out of those pieces, that are pad
-		// blocks (i.e. entirely part of pad files)
-		int pad_blocks;
+		// the number of bytes, out of those pieces, that are pad
+		// files
+		int pad_bytes;
 		// true if the last piece is part of the set
 		bool last_piece;
 	};
@@ -141,10 +141,7 @@ namespace libtorrent {
 		// pick pieces in sequential order
 		static constexpr picker_options_t sequential = 4_bit;
 
-		// treat pieces with priority 6 and below as filtered
-		// to trigger end-game mode until all prio 7 pieces are
-		// completed
-		static constexpr picker_options_t time_critical_mode = 5_bit;
+		// 5_bit is available
 
 		// only expands pieces (when prefer contiguous blocks is set)
 		// within properly aligned ranges, not the largest possible
@@ -172,8 +169,8 @@ namespace libtorrent {
 			piece_index_t index{(std::numeric_limits<std::int32_t>::max)()};
 
 			// info about each block in this piece. this is an index into the
-			// m_block_info array, when multiplied by m_blocks_per_piece.
-			// The m_blocks_per_piece following entries contain information about
+			// m_block_info array, when multiplied by blocks_per_piece.
+			// The blocks_per_piece following entries contain information about
 			// all blocks in this piece.
 			std::uint16_t info_idx{(std::numeric_limits<std::uint16_t>::max)()};
 
@@ -220,7 +217,7 @@ namespace libtorrent {
 #endif
 		};
 
-		piece_picker(int blocks_per_piece, int blocks_in_last_piece, int total_num_pieces);
+		piece_picker(std::int64_t total_size, int piece_size);
 
 		void get_availability(aux::vector<int, piece_index_t>& avail) const;
 		int get_availability(piece_index_t piece) const;
@@ -263,7 +260,7 @@ namespace libtorrent {
 		piece_index_t reverse_cursor() const { return m_reverse_cursor; }
 
 		// sets all pieces to dont-have
-		void resize(int blocks_per_piece, int blocks_in_last_piece, int total_num_pieces);
+		void resize(std::int64_t total_size, int piece_size);
 		int num_pieces() const { return int(m_piece_map.size()); }
 
 		bool have_piece(piece_index_t) const;
@@ -365,7 +362,7 @@ namespace libtorrent {
 		void mark_as_canceled(piece_block block, torrent_peer* peer);
 		void mark_as_finished(piece_block block, torrent_peer* peer);
 
-		void mark_as_pad(piece_block block);
+		void set_pad_bytes(piece_index_t p, int bytes);
 
 		// prevent blocks from being picked from this piece.
 		// to unlock the piece, call restore_piece() on it
@@ -455,7 +452,7 @@ namespace libtorrent {
 
 		piece_count all_pieces() const;
 
-		int pad_blocks_in_piece(piece_index_t const index) const;
+		int pad_bytes_in_piece(piece_index_t const index) const;
 
 		// number of pieces whose hash has passed (but haven't necessarily
 		// been flushed to disk yet)
@@ -513,7 +510,7 @@ namespace libtorrent {
 		std::pair<int, int> distributed_copies() const;
 
 		// return the array of block_info objects for a given downloading_piece.
-		// this array has m_blocks_per_piece elements in it
+		// this array has blocks_per_piece elements in it
 		span<block_info const> blocks_for_piece(downloading_piece const& dp) const;
 
 	private:
@@ -528,12 +525,21 @@ namespace libtorrent {
 			, torrent_peer* peer
 			, picker_options_t options) const;
 
+		int block_size() const
+		{
+			TORRENT_ASSERT(m_piece_size > 0);
+			TORRENT_ASSERT(default_block_size > 0);
+			return (std::min)(m_piece_size, default_block_size);
+		}
+		int blocks_per_piece() const;
+		int piece_size(piece_index_t p) const;
+
 		piece_extent_t extent_for(piece_index_t) const;
 		index_range<piece_index_t> extent_for(piece_extent_t) const;
 
 		void record_downloading_piece(piece_index_t const p);
 
-		int num_pad_blocks() const { return m_num_pad_blocks; }
+		int num_pad_bytes() const { return m_num_pad_bytes; }
 
 		span<block_info> mutable_blocks_for_piece(downloading_piece const& dp);
 
@@ -795,14 +801,9 @@ namespace libtorrent {
 		// TODO: should this be allocated lazily?
 		mutable aux::vector<piece_pos, piece_index_t> m_piece_map;
 
-		// this indicates whether a block has been marked as a pad
-		// block or not. It's indexed by block index, i.e. piece_index
-		// * blocks_per_piece + block. These blocks should not be
-		// picked and are considered to be had
-		// TODO: this could be a much more efficient data structure
-		bitfield m_pad_blocks;
-
-		// tracks the number of blocks in a specific piece that are pad blocks
+		// tracks the number of bytes in a specific piece that are part of a pad
+		// file. The padding is assumed to be at the end of the piece, and the
+		// blocks covered by the pad bytes are not picked by the piece picker
 		std::unordered_map<piece_index_t, int> m_pads_in_piece;
 
 		// when the adjecent_piece affinity is enabled, this contains the most
@@ -812,18 +813,17 @@ namespace libtorrent {
 		// traversed already.
 		mutable std::vector<piece_extent_t> m_recent_extents;
 
-		// the number of bits set in the m_pad_blocks bitfield, i.e.
-		// the number of blocks marked as pads
-		int m_num_pad_blocks = 0;
+		// the number of bytes of pad file set in this piece picker
+		int m_num_pad_bytes = 0;
 
 		// the number of pad blocks that we already have
-		int m_have_pad_blocks = 0;
+		int m_have_pad_bytes = 0;
 
 		// the number of pad blocks part of filtered pieces we don't have
-		int m_filtered_pad_blocks = 0;
+		int m_filtered_pad_bytes = 0;
 
 		// the number of pad blocks we have that are also filtered
-		int m_have_filtered_pad_blocks = 0;
+		int m_have_filtered_pad_bytes = 0;
 
 		// the number of seeds. These are not added to
 		// the availability counters of the pieces
@@ -860,13 +860,14 @@ namespace libtorrent {
 		aux::vector<block_info> m_block_info;
 
 		// these are block ranges in m_block_info that are free. The numbers
-		// in here, when multiplied by m_blocks_per_piece is the index to the
+		// in here, when multiplied by blocks_per_piece is the index to the
 		// first block in the range that's free to use by a new downloading_piece.
 		// this is a free-list.
 		std::vector<std::uint16_t> m_free_block_infos;
 
-		std::uint16_t m_blocks_per_piece = 0;
 		std::uint16_t m_blocks_in_last_piece = 0;
+		int m_piece_size = 0;
+		std::int64_t m_total_size = 0;
 
 		// the number of filtered pieces that we don't already
 		// have. total_number_of_pieces - number_of_pieces_we_have
diff -Naupr a/include/libtorrent/torrent.hpp b/include/libtorrent/torrent.hpp
--- a/include/libtorrent/torrent.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/torrent.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -271,6 +271,10 @@ namespace libtorrent {
 		// around further down the object to maintain an owner
 		std::shared_ptr<torrent_info> m_torrent_file;
 
+		// This is the sum of all non-pad file sizes. In the next major version
+		// this is stored in file_storage and no longer need to be kept here.
+		std::int64_t m_size_on_disk = 0;
+
 		// a back reference to the session
 		// this torrent belongs to.
 		aux::session_interface& m_ses;
@@ -1130,7 +1134,7 @@ namespace libtorrent {
 		bool are_files_checked() const
 		{ return m_files_checked; }
 
-		void initialize_merkle_trees();
+		error_code initialize_merkle_trees();
 
 		// parses the info section from the given
 		// bencoded tree and moves the torrent
@@ -1302,6 +1306,9 @@ namespace libtorrent {
 		std::int64_t m_total_uploaded = 0;
 		std::int64_t m_total_downloaded = 0;
 
+		// the number of bytes of pad files
+		std::int64_t m_padding_bytes = 0;
+
 		// this is a handle that keeps the storage object in the disk io subsystem
 		// alive, as well as the index referencing the storage/torrent in the disk
 		// I/O. When this destructs, the torrent will be removed from the disk
@@ -1665,10 +1672,6 @@ namespace libtorrent {
 
 // ----
 
-		// the number of (16kiB) blocks that fall entirely in pad files
-		// i.e. blocks that we consider we have on start-up
-		std::uint16_t m_padding_blocks = 0;
-
 		// this is set to the connect boost quota for this torrent.
 		// After having received this many priority peer connection attempts, it
 		// falls back onto the steady state peer connection logic, driven by the
diff -Naupr a/include/libtorrent/write_resume_data.hpp b/include/libtorrent/write_resume_data.hpp
--- a/include/libtorrent/write_resume_data.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/include/libtorrent/write_resume_data.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -45,6 +45,14 @@ namespace libtorrent {
 	// into a bencoded structure
 	TORRENT_EXPORT entry write_resume_data(add_torrent_params const& atp);
 	TORRENT_EXPORT std::vector<char> write_resume_data_buf(add_torrent_params const& atp);
+
+	// writes only the fields to create a .torrent file. This function may fail
+	// with a ``std::system_error`` exception if:
+	//
+	// * The add_torrent_params object passed to this function does not contain the
+	//   info dictionary (the ``ti`` field)
+	// * The piece layers are not complete for all files that need them
+	TORRENT_EXPORT entry write_torrent_file(add_torrent_params const& atp);
 }
 
 #endif
diff -Naupr a/simulation/disk_io.cpp b/simulation/disk_io.cpp
--- a/simulation/disk_io.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/disk_io.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -37,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 #include "libtorrent/error_code.hpp"
 #include "libtorrent/deadline_timer.hpp"
 #include "libtorrent/disk_observer.hpp"
+#include "libtorrent/aux_/apply_pad_files.hpp"
 
 #include <utility> // for exchange()
 
@@ -54,38 +55,57 @@ namespace {
 
 } // anonymous namespace
 
-std::array<char, 4> generate_block_fill(lt::piece_index_t const p, int const block)
+std::array<char, 0x4000> generate_block_fill(lt::piece_index_t const p, int const block)
 {
 	int const v = (static_cast<int>(p) << 8) | (block & 0xff);
-	std::array<char, 4> ret;
-	std::memcpy(ret.data(), reinterpret_cast<char const*>(&v), 4);
+	std::array<char, 0x4000> ret;
+	for (int i = 0; i < 0x4000; i += 4)
+	{
+		std::memcpy(ret.data() + i, reinterpret_cast<char const*>(&v), 4);
+	}
 	return ret;
 }
 
-lt::sha1_hash generate_hash1(lt::piece_index_t const p, lt::file_storage const& fs)
+lt::sha1_hash generate_hash1(lt::piece_index_t const p, lt::file_storage const& fs, int const pad_bytes)
 {
 	lt::hasher ret;
 	int const piece_size = fs.piece_size(p);
+	int const payload_size = piece_size - pad_bytes;
 	int offset = 0;
-	for (int block = 0; offset < piece_size; ++block)
+	for (int block = 0; offset < payload_size; ++block)
 	{
 		auto const fill = generate_block_fill(p, block);
-		for (int i = 0; i < lt::default_block_size; i += fill.size(), offset += fill.size())
-			ret.update(fill.data(), std::min(int(fill.size()), piece_size - offset));
+		for (int i = 0; i < lt::default_block_size;)
+		{
+			int const bytes = std::min(int(fill.size()), payload_size - offset);
+			ret.update(fill.data(), bytes);
+			offset += bytes;
+			i += bytes;
+		}
+	}
+	std::array<char, 8> const pad{{0, 0, 0, 0, 0, 0, 0, 0}};
+	while (offset < piece_size)
+	{
+		int const bytes = std::min(int(pad.size()), piece_size - offset);
+		ret.update(pad.data(), bytes);
+		offset += bytes;
 	}
 	return ret.final();
 }
 
 lt::sha1_hash generate_hash2(lt::piece_index_t p, lt::file_storage const& fs
-	, lt::span<lt::sha256_hash> const hashes)
+	, lt::span<lt::sha256_hash> const hashes, int const pad_bytes)
 {
 	int const piece_size = fs.piece_size(p);
+	int const payload_size = piece_size - pad_bytes;
 	int const piece_size2 = fs.piece_size2(p);
 	int const blocks_in_piece = (piece_size + lt::default_block_size - 1) / lt::default_block_size;
 	int const blocks_in_piece2 = fs.blocks_in_piece2(p);
 	TORRENT_ASSERT(int(hashes.size()) >= blocks_in_piece2);
 	int const blocks_to_read = std::max(blocks_in_piece, blocks_in_piece2);
 
+	TORRENT_ASSERT(piece_size - pad_bytes == piece_size2);
+
 	lt::hasher ret;
 	int offset = 0;
 	for (int block = 0; block < blocks_to_read; ++block)
@@ -95,18 +115,27 @@ lt::sha1_hash generate_hash2(lt::piece_i
 
 		bool const v2 = piece_size2 - offset > 0;
 
-		int const block_size = std::min(lt::default_block_size, std::max(piece_size, piece_size2) - offset);
-		for (int i = 0; i < block_size; i += fill.size(), offset += fill.size())
+		int const block_size = std::min(lt::default_block_size, payload_size - offset);
+		for (int i = 0; i < block_size;)
 		{
-			if (piece_size - offset > 0)
-				ret.update(fill.data(), std::min(int(fill.size()), piece_size - offset));
+			int const bytes = std::min(int(fill.size()), payload_size - offset);
+			TORRENT_ASSERT(bytes > 0);
+			ret.update(fill.data(), bytes);
+
 			if (piece_size2 - offset > 0)
 				v2_hash.update(fill.data(), std::min(int(fill.size()), piece_size2 - offset));
+
+			offset += bytes;
+			i += bytes;
 		}
+		if (offset < piece_size)
+		{
+			std::vector<char> padding(piece_size - offset, 0);
+			ret.update(padding);
+		}
+
 		if (v2)
 			hashes[block] = v2_hash.final();
-		else
-			hashes[block].clear();
 	}
 	return ret.final();
 }
@@ -121,14 +150,49 @@ lt::sha256_hash generate_block_hash(lt::
 	return ret.final();
 }
 
-void generate_block(char* b, lt::peer_request const& r)
+void generate_block(char* b, lt::peer_request const& r, int const pad_bytes)
 {
 	auto const fill = generate_block_fill(r.piece, (r.start / lt::default_block_size));
-	for (int i = 0; i < lt::default_block_size; i += fill.size())
-	{
-		std::memcpy(b, fill.data(), fill.size());
-		b += fill.size();
+
+	// for now we don't support unaligned start address
+	TORRENT_ASSERT((r.start % fill.size()) == 0);
+	char* end = b + r.length - pad_bytes;
+	while (b < end)
+	{
+		int const bytes = std::min(int(fill.size()), int(end - b));
+		std::memcpy(b, fill.data(), bytes);
+		b += bytes;
 	}
+
+	if (pad_bytes > 0)
+		std::memset(b, 0, pad_bytes);
+}
+
+std::unordered_map<lt::piece_index_t, int> compute_pad_bytes(lt::file_storage const& fs)
+{
+	std::unordered_map<lt::piece_index_t, int> ret;
+	lt::aux::apply_pad_files(fs, [&](lt::piece_index_t p, int bytes)
+	{
+		ret.emplace(p, bytes);
+	});
+	return ret;
+}
+
+int pads_in_piece(std::unordered_map<lt::piece_index_t, int> const& pb, lt::piece_index_t const p)
+{
+	auto it = pb.find(p);
+	return (it == pb.end()) ? 0 : it->second;
+}
+
+int pads_in_req(std::unordered_map<lt::piece_index_t, int> const& pb
+	, lt::peer_request const& r, int const piece_size)
+{
+	auto it = pb.find(r.piece);
+	if (it == pb.end()) return 0;
+
+	int const pad_start = piece_size - it->second;
+	int const req_end = r.start + r.length;
+	return std::max(0, std::min(req_end - pad_start, r.length));
 }
 
 std::shared_ptr<lt::torrent_info> create_test_torrent(int const piece_size
@@ -139,10 +203,12 @@ std::shared_ptr<lt::torrent_info> create
 	fs.add_file("file-1", total_size);
 	lt::create_torrent t(fs, piece_size, flags);
 
+	auto const pad_bytes = compute_pad_bytes(fs);
+
 	if (flags & lt::create_torrent::v1_only)
 	{
 		for (auto const i : fs.piece_range())
-			t.set_hash(i, generate_hash1(i, fs));
+			t.set_hash(i, generate_hash1(i, fs, pads_in_piece(pad_bytes, i)));
 	}
 	else
 	{
@@ -155,7 +221,7 @@ std::shared_ptr<lt::torrent_info> create
 
 		for (auto const i : fs.piece_range())
 		{
-			auto const hash = generate_hash2(i, fs, blocks);
+			auto const hash = generate_hash2(i, fs, blocks, pads_in_piece(pad_bytes, i));
 			lt::merkle_fill_tree(v2tree, num_leafs);
 			t.set_hash2(lt::file_index_t{0}, i - 0_piece, v2tree[0]);
 
@@ -212,6 +278,8 @@ struct test_disk_io final : lt::disk_int
 		m_files = &fs;
 		m_blocks_per_piece = fs.piece_length() / lt::default_block_size;
 		m_have.resize(m_files->num_pieces() * m_blocks_per_piece, m_state.seed);
+		m_pad_bytes = compute_pad_bytes(fs);
+
 		return lt::storage_holder(lt::storage_index_t{0}, *this);
 	}
 
@@ -249,7 +317,7 @@ struct test_disk_io final : lt::disk_int
 
 		queue_event(seek_time + m_state.read_time, [this,r, h=std::move(h)] () mutable {
 			lt::disk_buffer_holder buf(*this, new char[lt::default_block_size], r.length);
-			generate_block(buf.data(), r);
+			generate_block(buf.data(), r, pads_in_req(m_pad_bytes, r, m_files->piece_size(r.piece)));
 
 			post(m_ioc, [h=std::move(h), b=std::move(buf)] () mutable { h(std::move(b), lt::storage_error{}); });
 		});
@@ -282,7 +350,7 @@ struct test_disk_io final : lt::disk_int
 			return false;
 		}
 
-		bool const valid = validate_block(buf, r);
+		bool const valid = validate_block(*m_files, buf, r);
 
 		auto const seek_time = disk_seek(std::int64_t(static_cast<int>(r.piece)) * m_files->piece_length() + r.start
 			, lt::default_block_size);
@@ -329,8 +397,11 @@ struct test_disk_io final : lt::disk_int
 
 		queue_event(delay, [this, piece, block_hashes, h=std::move(handler)] () mutable {
 
+			int const piece_size = m_files->piece_size(piece);
+			int const pad_bytes = pads_in_piece(m_pad_bytes, piece);
+			int const payload_blocks = piece_size / lt::default_block_size - pad_bytes / lt::default_block_size;
 			int const block_idx = piece * m_blocks_per_piece;
-			for (int i = 0; i < m_blocks_per_piece; ++i)
+			for (int i = 0; i < payload_blocks; ++i)
 			{
 				if (!m_have.get_bit(block_idx + i))
 				{
@@ -342,9 +413,9 @@ struct test_disk_io final : lt::disk_int
 
 			lt::sha1_hash hash;
 			if (block_hashes.empty())
-				hash = generate_hash1(piece, *m_files);
+				hash = generate_hash1(piece, *m_files, pads_in_piece(m_pad_bytes, piece));
 			else
-				hash = generate_hash2(piece, *m_files, block_hashes);
+				hash = generate_hash2(piece, *m_files, block_hashes, pads_in_piece(m_pad_bytes, piece));
 			post(m_ioc, [h=std::move(h), piece, hash]{ h(piece, hash, lt::storage_error{}); });
 		});
 	}
@@ -474,13 +545,24 @@ private:
 		return r.piece * m_blocks_per_piece + r.start / lt::default_block_size;
 	}
 
-	bool validate_block(char const* b, lt::peer_request const& r) const
+	bool validate_block(lt::file_storage const& fs, char const* b, lt::peer_request const& r) const
 	{
 		auto const fill = generate_block_fill(r.piece, r.start / lt::default_block_size);
-		for (int i = 0; i < lt::default_block_size; i += fill.size())
+		int const piece_size = fs.piece_size(r.piece);
+		int payload_bytes = (piece_size - pads_in_piece(m_pad_bytes, r.piece)) - r.start;
+		int offset = 0;
+		while (offset < r.length && payload_bytes > 0)
+		{
+			int const to_compare = std::min(payload_bytes, int(fill.size()));
+			if (std::memcmp(b, fill.data(), to_compare) != 0) return false;
+			b += to_compare;
+			offset += to_compare;
+			payload_bytes -= to_compare;
+		}
+		if (offset < r.length)
 		{
-			if (std::memcmp(b, fill.data(), fill.size()) != 0) return false;
-			b += fill.size();
+			// the pad bytes must be zero
+			return std::all_of(b, b + r.length - offset, [](char const c) { return c == 0; });
 		}
 		return true;
 	}
@@ -508,7 +590,7 @@ private:
 		{
 			auto f = std::move(m_event_queue.front().second);
 			m_event_queue.pop_front();
-			f();
+			if (f) f();
 		}
 
 		if (m_event_queue.empty())
@@ -557,6 +639,8 @@ private:
 
 	// callbacks are posted on this
 	lt::io_context& m_ioc;
+
+	std::unordered_map<lt::piece_index_t, int> m_pad_bytes;
 };
 
 std::unique_ptr<lt::disk_interface> test_disk::operator()(
diff -Naupr a/simulation/disk_io.hpp b/simulation/disk_io.hpp
--- a/simulation/disk_io.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/disk_io.hpp	2021-08-13 13:03:08.000000000 +0200
@@ -41,7 +41,7 @@ POSSIBILITY OF SUCH DAMAGE.
 #include <array>
 #include <limits>
 
-std::array<char, 4> generate_block_fill(lt::piece_index_t const p, int const block);
+std::array<char, 0x4000> generate_block_fill(lt::piece_index_t const p, int const block);
 lt::sha1_hash generate_hash1(lt::piece_index_t const p, lt::file_storage const& fs);
 lt::sha1_hash generate_hash2(lt::piece_index_t p, lt::file_storage const& fs
 	, lt::span<lt::sha256_hash> const hashes);
diff -Naupr a/simulation/libsimulator/CMakeLists.txt b/simulation/libsimulator/CMakeLists.txt
--- a/simulation/libsimulator/CMakeLists.txt	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-project(libsimulator)
-cmake_minimum_required(VERSION 2.8.7)
-
-set(SRC_DIR src)
-set(TEST_SRC_DIR test)
-set(INCLUDE_DIR include)
-set(CMAKE_CXX_STANDARD 14)
-set(CMAKE_CXX_STANDARD_REQUIRED ON)
-
-find_package(Boost COMPONENTS system REQUIRED)
-find_package(Threads REQUIRED)
-
-set(SIMULATOR_SRC_FILES
-  ${SRC_DIR}/acceptor.cpp
-  ${SRC_DIR}/high_resolution_timer.cpp
-  ${SRC_DIR}/io_service.cpp
-  ${SRC_DIR}/resolver.cpp
-  ${SRC_DIR}/sink_forwarder.cpp
-  ${SRC_DIR}/udp_socket.cpp
-  ${SRC_DIR}/default_config.cpp
-  ${SRC_DIR}/http_proxy.cpp
-  ${SRC_DIR}/pcap.cpp
-  ${SRC_DIR}/simulation.cpp
-  ${SRC_DIR}/socks_server.cpp
-  ${SRC_DIR}/high_resolution_clock.cpp
-  ${SRC_DIR}/http_server.cpp
-  ${SRC_DIR}/queue.cpp
-  ${SRC_DIR}/simulator.cpp
-  ${SRC_DIR}/tcp_socket.cpp
-  ${SRC_DIR}/nat.cpp
-)
-
-add_library(simulator ${SIMULATOR_SRC_FILES})
-include_directories(${Boost_INCLUDE_DIR} ${INCLUDE_DIR})
-
-if(WIN32)
-  target_link_libraries(simulator PRIVATE ws2_32)
-endif()
-
-enable_testing()
-
-function(define_test)
-  set(NAME ${ARGV0})
-  add_executable(${NAME} ${TEST_SRC_DIR}/${NAME}.cpp ${TEST_SRC_DIR}/main.cpp)
-  target_link_libraries(${NAME} simulator ${Boost_LIBRARIES})
-  target_link_libraries(${NAME} Threads::Threads)
-  add_test(NAME ${NAME} COMMAND ${NAME})
-endfunction()
-
-define_test(acceptor)
-define_test(multi_accept)
-define_test(multi_homed)
-define_test(null_buffers)
-define_test(parse_request)
-define_test(resolver)
-define_test(timer)
-define_test(udp_socket)
diff -Naupr a/simulation/libsimulator/Jamfile b/simulation/libsimulator/Jamfile
--- a/simulation/libsimulator/Jamfile	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/Jamfile	1970-01-01 01:00:00.000000000 +0100
@@ -1,134 +0,0 @@
-# This Jamfile requires boost-build v2 to build.
-
-import path ;
-import modules ;
-import os ;
-import testing ;
-
-BOOST_ROOT = [ modules.peek : BOOST_ROOT ] ;
-
-ECHO "BOOST_ROOT =" $(BOOST_ROOT) ;
-ECHO "OS =" [ os.name ] ;
-
-lib wsock32 : : <name>wsock32 <link>shared ;
-lib ws2_32 : : <name>ws2_32 <link>shared ;
-
-if $(BOOST_ROOT)
-{
-	use-project /boost : $(BOOST_ROOT) ;
-	alias boost_system : /boost/system//boost_system ;
-}
-else
-{
-
-	local boost-lib-search-path =
-		<search>/opt/local/lib
-		<search>/usr/lib
-		<search>/usr/local/lib
-		<search>/sw/lib
-		<search>/usr/g++/lib
-		;
-
-	local boost-include-path =
-		<include>/opt/local/include
-		<include>/usr/local/include
-		<include>/usr/sfw/include
-	;
-
-	lib boost_system : : <name>boost_system $(boost-lib-search-path)
-		: : $(boost-include-path) ;
-}
-
-SOURCES =
-	simulator
-	simulation
-	io_service
-	high_resolution_timer
-	high_resolution_clock
-	tcp_socket
-	udp_socket
-	queue
-	acceptor
-	default_config
-	http_server
-	socks_server
-	resolver
-	http_proxy
-	sink_forwarder
-	pcap
-	nat
-	;
-
-lib simulator
-	: # sources
-	src/$(SOURCES).cpp
-
-	: # requirements
-	<include>include
-	<library>boost_system
-	<target-os>windows:<library>ws2_32
-	<target-os>windows:<library>wsock32
-	<threading>multi
-
-	<link>shared:<define>SIMULATOR_BUILDING_SHARED
-	<define>_CRT_SECURE_NO_WARNINGS
-
-	# https://github.com/chriskohlhoff/asio/issues/290#issuecomment-377727614
-	<define>_SILENCE_CXX17_ALLOCATOR_VOID_DEPRECATION_WARNING
-
-	<define>BOOST_ASIO_DISABLE_BOOST_DATE_TIME
-	<define>BOOST_ASIO_HAS_MOVE
-	<define>BOOST_ASIO_ENABLE_CANCELIO
-
-	# make sure asio uses std::chrono
-	<define>BOOST_ASIO_HAS_STD_CHRONO
-
-	# disable auto-link
-	<define>BOOST_ALL_NO_LIB
-
-	: # default build
-	<warnings>all
-	<warnings-as-errors>on
-	# boost.asio has a global tss_ptr which is the head of a
-	# linked list of all invocations of run on that thread. This
-	# determines whether dispatch() will run the handler immediately
-	# not. The simulator relies on this. On windows each DLL will have
-	# its own copy of this variable, effectively causing a deadlock
-	# in the simulator. So, default to static linking
-	<link>static
-
-	: # usage requirements
-	<define>BOOST_ASIO_DISABLE_BOOST_DATE_TIME
-	<define>BOOST_ASIO_HAS_MOVE
-	<define>BOOST_ASIO_ENABLE_CANCELIO
-	<threading>multi
-	<include>include
-	<link>shared:<define>SIMULATOR_LINKING_SHARED
-
-	# https://github.com/chriskohlhoff/asio/issues/290#issuecomment-377727614
-	<define>_SILENCE_CXX17_ALLOCATOR_VOID_DEPRECATION_WARNING
-	;
-
-project
-	: requirements
-	<library>simulator
-	# disable auto-link
-	<define>BOOST_ALL_NO_LIB
-	: default-build
-	<link>static
-	<threading>multi
-	<cxxstd>14
-	;
-
-test-suite simulator-tests : [ run
-	test/main.cpp
-	test/resolver.cpp
-	test/multi_homed.cpp
-	test/timer.cpp
-	test/acceptor.cpp
-	test/multi_accept.cpp
-	test/null_buffers.cpp
-	test/udp_socket.cpp
-	test/parse_request.cpp
-	] ;
-
diff -Naupr a/simulation/libsimulator/LICENSE b/simulation/libsimulator/LICENSE
--- a/simulation/libsimulator/LICENSE	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/LICENSE	1970-01-01 01:00:00.000000000 +0100
@@ -1,675 +0,0 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    {one line to give the program's name and a brief idea of what it does.}
-    Copyright (C) {year}  {name of author}
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    {project}  Copyright (C) {year}  {fullname}
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
-
diff -Naupr a/simulation/libsimulator/README.rst b/simulation/libsimulator/README.rst
--- a/simulation/libsimulator/README.rst	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/README.rst	1970-01-01 01:00:00.000000000 +0100
@@ -1,202 +0,0 @@
-libsimulator
-============
-
-.. image:: https://travis-ci.org/arvidn/libsimulator.svg?branch=master
-    :target: https://travis-ci.org/arvidn/libsimulator
-
-.. image:: https://ci.appveyor.com/api/projects/status/0857n4g3f6mui90i/branch/master
-    :target: https://ci.appveyor.com/project/arvidn/libsimulator/branch/master
-
-*This is still in initial development, some of this README represents ambitions
-rather than the current state*
-
-libsimulator is a library for running discrete event simulations, implementing
-the ``boost.asio`` API (or a somewhat faithful emulation of a subset of it,
-patches are welcome). This makes it practical to be used as a testing tool of
-real implementations of network software as well as for writing simulators that
-later turn into live production applications.
-
-The simulation has to have a single time-line to be deterministic, meaning it
-must be single threaded and use a single ``io_service`` as the message queue.
-These requirements may affect how the program to be tested is written. It may
-for instance require that an external io_service can be provided rather than one
-being wrapped in an internal thread.
-
-However, ``boost.asio`` programs may generally benefit from being transformed to
-this form, as the become *composable*, i.e. agnostic to which io_service they
-run on or how many threads are running it.
-
-features
---------
-
-The currently (partially) supported classes are:
-
-* chrono::high_resolution_clock
-* asio::high_resolution_timer
-* asio::ip::tcp::acceptor
-* asio::ip::tcp::endpoint
-* asio::ip::address (v4 and v6 variants, these just defer to the actual
-  boost.asio types)
-* asio::ip::tcp::socket
-* asio::ip::udp::socket
-* asio::io_service
-* asio::ip::udp::resolver
-* asio::ip::tcp::resolver
-
-The ``high_resolution_clock`` in the ``chrono`` namespace implements the timer
-concept from the chrono library.
-
-usage
------
-
-The ``io_service`` object is significantly different from the one in boost.asio.
-This is because one simulation may only have a single message loop and a single
-ordering of events. This single message loop is provided by the ``simulation``
-class. Each simulation should have only one such object. An ``io_service``
-object represents a single node on the network. When creating an io_service, you
-have to pass in the simulation it belongs to as well as the IP address it should
-have. It is also possible to pass in multiple addresses to form a multi-homed
-node. For instance, one with both an IPv4 and IPv6 interface.
-
-When creating sockets, binding and connecting them, the io_service object
-determines what ``INADDR_ANY`` resolves to (the first IP assigned to that node).
-
-The only aspects of the io_service interface that's preserved are ``post()``,
-``dispatch()`` and constructing timers and sockets. In short, the ``run()`` and
-``poll()`` family of functions do not exist. Every io_service object is assumed
-to be run, and all of their events are handled by the simulation object.
-
-None of the synchronous APIs are supported, because that would require
-integration with OS threads and scheduler.
-
-example
--------
-
-Here's a simple example illustrating the asio timer::
-
-	#include "simulator/simulator.hpp"
-	#include <functional>
-	#include <boost/system.hpp>
-
-	void print_time(sim::asio::high_resolution_timer& timer
-		, boost::system::error_code const& ec)
-	{
-		using namespace sim::chrono;
-		static int counter = 0;
-
-		printf("[%d] timer fired at: %d milliseconds. error: %s\n"
-			, counter
-			, int(duration_cast<milliseconds>(high_resolution_clock::now()
-					.time_since_epoch()).count())
-			, ec.message().c_str());
-
-		++counter;
-		if (counter < 5)
-		{
-			timer.expires_from_now(seconds(counter));
-			timer.async_wait(std::bind(&print_time, std::ref(timer), _1));
-		}
-	}
-
-	int main()
-	{
-		using namespace sim::chrono;
-
-		default_config cfg;
-		simulation sim(cfg);
-		io_service ios(sim, ip::address_v4::from_string("1.2.3.4"));
-		sim::asio::high_resolution_timer timer(ios);
-
-		timer.expires_from_now(seconds(1));
-		timer.async_wait(std::bind(&print_time, std::ref(timer), _1));
-
-		boost::system::error_code ec;
-		sim.run(ec);
-
-		printf("sim::run() returned: %s at: %d\n"
-			, ec.message().c_str()
-			, int(duration_cast<milliseconds>(high_resolution_clock::now()
-					.time_since_epoch()).count()));
-	}
-
-The output from this program is::
-
-	[0] timer fired at: 1000 milliseconds. error: Undefined error: 0
-	[1] timer fired at: 2000 milliseconds. error: Undefined error: 0
-	[2] timer fired at: 4000 milliseconds. error: Undefined error: 0
-	[3] timer fired at: 7000 milliseconds. error: Undefined error: 0
-	[4] timer fired at: 11000 milliseconds. error: Undefined error: 0
-	io_service::run() returned: Undefined error: 0 at: 11000
-
-And obviously it doesn't take 11 wall-clock seconds to run (it returns
-instantly).
-
-configuration
--------------
-
-The simulated network can be configured with per-node pair bandwidth, round-trip
-latency and queue sizes. This is controlled via a callback interface that
-libsimulator will ask for these properties when nodes get connected.
-
-The resolution of hostnames is also configurable by providing a callback on the
-configuration object along with the latency of individual lookups.
-
-To configure the network for the simulation, pass in a reference to an object
-implementing the ``sim::configuration`` interface::
-
-	struct configuration
-	{
-		// build the network
-		virtual void build(simulation& sim) = 0;
-
-		// return the hops on the network packets from src to dst need to traverse
-		virtual route channel_route(asio::ip::address src
-			, asio::ip::address dst) = 0;
-
-		// return the hops an incoming packet to ep need to traverse before
-		// reaching the socket (for instance a NAT)
-		virtual route incoming_route(asio::ip::address ip) = 0;
-
-		// return the hops an outgoing packet from ep need to traverse before
-		// reaching the network (for instance a DSL modem)
-		virtual route outgoing_route(asio::ip::address ip) = 0;
-
-		// return the path MTU between the two IP addresses
-		// For TCP sockets, this will be called once when the connection is
-		// established. For UDP sockets it's called for every burst of packets
-		// that are sent
-		virtual int path_mtu(asio::ip::address ip1, asio::ip::address ip2) = 0;
-
-		// called for every hostname lookup made by the client. ``reqyestor`` is
-		// the node performing the lookup, ``hostname`` is the name being looked
-		// up. Resolve the name into addresses and fill in ``result`` or set
-		// ``ec`` if the hostname is not found or some other error occurs. The
-		// return value is the latency of the lookup. The client's callback won't
-		// be called until after waiting this long.
-		virtual chrono::high_resolution_clock::duration hostname_lookup(
-			asio::ip::address const& requestor
-			, std::string hostname
-			, std::vector<asio::ip::address>& result
-			, boost::system::error_code& ec) = 0;
-	};
-
-``build()`` is called right after the simulation is constructed. It gives the
-configuration object an opportunity to construct the core queues, since they
-need access to the simulator.
-
-``channel_route()`` is expected to return a *route* of network hops from the
-source IP to the destination IP. A route is a series of ``sink`` objects. The
-typical sink is a ``sim::queue``, which is a network node with a specific rate
-limit, propagation delay and queue size.
-
-*TODO: finish document configuration interface*
-
-history
--------
-
-libsimulator grew out of libtorrent's unit tests, as a tool to make them reliable
-and deterministic (i.e. not depend on external systems like sockets and timers)
-and also easier to debug. The subset of the asio API initially supported by this
-library is the subset used by libtorrent. Patches are welcome to improve
-fidelity and support.
-
diff -Naupr a/simulation/libsimulator/include/simulator/chrono.hpp b/simulation/libsimulator/include/simulator/chrono.hpp
--- a/simulation/libsimulator/include/simulator/chrono.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/chrono.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef CHRONO_HPP_INCLUDED
-#define CHRONO_HPP_INCLUDED
-
-#include <boost/config.hpp>
-#include "simulator/config.hpp"
-
-#if defined BOOST_ASIO_HAS_STD_CHRONO
-#include <chrono>
-#else
-#include "simulator/push_warnings.hpp"
-
-#include <boost/chrono/duration.hpp>
-#include <boost/chrono/time_point.hpp>
-#include <boost/ratio.hpp>
-
-#include "simulator/pop_warnings.hpp"
-#endif
-
-namespace sim { namespace chrono
-{
-#if defined BOOST_ASIO_HAS_STD_CHRONO
-	using std::chrono::seconds;
-	using std::chrono::milliseconds;
-	using std::chrono::microseconds;
-	using std::chrono::nanoseconds;
-	using std::chrono::minutes;
-	using std::chrono::hours;
-	using std::chrono::duration_cast;
-	using std::chrono::time_point;
-	using std::chrono::duration;
-#else
-	using boost::chrono::seconds;
-	using boost::chrono::milliseconds;
-	using boost::chrono::microseconds;
-	using boost::chrono::nanoseconds;
-	using boost::chrono::minutes;
-	using boost::chrono::hours;
-	using boost::chrono::duration_cast;
-	using boost::chrono::time_point;
-	using boost::chrono::duration;
-#endif
-
-	// std.chrono / boost.chrono compatible high_resolution_clock using a simulated time
-	struct SIMULATOR_DECL high_resolution_clock
-	{
-		using rep = std::int64_t;
-#if defined BOOST_ASIO_HAS_STD_CHRONO
-		using period = std::nano;
-		using time_point = std::chrono::time_point<high_resolution_clock, nanoseconds>;
-		using duration = std::chrono::duration<boost::int64_t, std::nano>;
-#else
-		using period = boost::nano;
-		using time_point = time_point<high_resolution_clock, nanoseconds>;
-		using duration = duration<boost::int64_t, boost::nano>;
-#endif
-		static const bool is_steady = true;
-		static time_point now();
-
-		// private interface
-		static void fast_forward(high_resolution_clock::duration d);
-	};
-
-	// private interface
-	void reset_clock();
-
-} // chrono
-} // sim
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/config.hpp b/simulation/libsimulator/include/simulator/config.hpp
--- a/simulation/libsimulator/include/simulator/config.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/config.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef CONFIG_HPP_INCLUDED
-#define CONFIG_HPP_INCLUDED
-
-#include "simulator/push_warnings.hpp"
-#include <boost/config.hpp>
-#include "simulator/pop_warnings.hpp"
-
-#ifdef SIMULATOR_BUILDING_SHARED
-#define SIMULATOR_DECL BOOST_SYMBOL_EXPORT
-#elif defined SIMULATOR_LINKING_SHARED
-#define SIMULATOR_DECL BOOST_SYMBOL_IMPORT
-#else
-#define SIMULATOR_DECL
-#endif
-
-#if defined __clang__ || defined __GNUC__
-#define LIBSIMULATOR_NO_RETURN __attribute((noreturn))
-#elif _MSC_VER
-#define LIBSIMULATOR_NO_RETURN __declspec(noreturn)
-#else
-#define LIBSIMULATOR_NO_RETURN
-#endif
-
-#ifdef _MSC_VER
-#pragma warning(push)
-// warning C4251: X: class Y needs to have dll-interface to be used by clients of struct
-#pragma warning( disable : 4251)
-// warning C4661: X: no suitable definition provided for explicit template instantiation request
-#pragma warning( disable : 4661)
-#endif
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/function.hpp b/simulation/libsimulator/include/simulator/function.hpp
--- a/simulation/libsimulator/include/simulator/function.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/function.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,220 +0,0 @@
-/*
-
-Copyright (c) 2017, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef SIMULATOR_FUNCTION_HPP_INCLUDED
-#define SIMULATOR_FUNCTION_HPP_INCLUDED
-
-#include <utility>
-#include <memory> // for allocator_traits
-
-#include "simulator/mallocator.hpp"
-
-namespace sim {
-namespace aux {
-
-	template <typename T, typename U>
-	T exchange_(T& var, U&& new_val)
-	{
-		T temp = std::move(var);
-		var = std::forward<U>(new_val);
-		return temp;
-	}
-
-	template <typename T, typename Fun>
-	T* allocate_handler(Fun h)
-	{
-		using alloc = typename boost::asio::associated_allocator<typename std::remove_reference<Fun>::type>::type;
-		using our_alloc = typename std::allocator_traits<alloc>::template rebind_alloc<T>;
-		our_alloc al(boost::asio::get_associated_allocator(h));
-		void* ptr = al.allocate(1);
-		if (ptr == nullptr) throw std::bad_alloc();
-		try {
-			return new (ptr) T(std::move(h));
-		}
-		catch (...) {
-			al.deallocate(reinterpret_cast<T*>(ptr), 1);
-			throw;
-		}
-	}
-
-	// this is a std::function-like class that supports move-only function
-	// objects
-	template <typename R, typename... A>
-	struct callable
-	{
-		using call_fun_t = R (*)(void*, A&&...);
-		using deallocate_fun_t = void (*)(void*);
-		call_fun_t call_fun;
-		deallocate_fun_t deallocate_fun;
-	};
-
-	template <typename Handler, typename R, typename... A>
-	R call_impl(void* mem, A&&... a);
-
-	template <typename Handler, typename R, typename... A>
-	void dealloc_impl(void* mem);
-
-	template <typename Handler, typename R, typename... A>
-	struct function_impl : callable<R, A...>
-	{
-		function_impl(Handler h)
-			: handler(std::move(h))
-		{
-			this->call_fun = call_impl<Handler, R, A&&...>;
-			this->deallocate_fun = dealloc_impl<Handler, R, A&&...>;
-		}
-		Handler handler;
-	};
-
-	template <typename Handler, typename R, typename... A>
-	R call_impl(void* mem, A&&... a)
-	{
-		auto* obj = static_cast<function_impl<Handler, R, A...>*>(mem);
-		Handler handler = std::move(obj->handler);
-
-		obj->~function_impl();
-		using alloc = typename boost::asio::associated_allocator<Handler>::type;
-		using our_alloc = typename std::allocator_traits<alloc>::
-			template rebind_alloc<typename std::remove_reference<decltype(*obj)>::type>;
-		our_alloc al(boost::asio::get_associated_allocator(handler));
-		al.deallocate(obj, 1);
-
-		return handler(std::forward<A>(a)...);
-	}
-
-	template <typename Handler, typename R, typename... A>
-	void dealloc_impl(void* mem)
-	{
-		auto* obj = static_cast<function_impl<Handler, R, A...>*>(mem);
-		Handler h = std::move(obj->handler);
-
-		obj->~function_impl();
-		using alloc = typename boost::asio::associated_allocator<Handler>::type;
-		using our_alloc = typename std::allocator_traits<alloc>::
-			template rebind_alloc<typename std::remove_reference<decltype(*obj)>::type>;
-		our_alloc al(boost::asio::get_associated_allocator(h));
-		al.deallocate(obj, 1);
-	}
-
-	template <typename Fun>
-	struct function;
-
-	template <typename R, typename... A>
-	struct function<R(A...)>
-	{
-		using result_type = R;
-
-		using allocator_type = aux::mallocator<R(A...)>;
-		allocator_type get_allocator() const { return allocator_type{}; }
-
-		template <typename C>
-		function(C c)
-			: m_callable(allocate_handler<function_impl<C, R, A...>>(std::move(c)))
-		{}
-		function(function&& other) noexcept
-			: m_callable(exchange_(other.m_callable, nullptr))
-		{}
-		function& operator=(function&& other) noexcept
-		{
-			if (&other == this) return *this;
-			clear();
-			m_callable = exchange_(other.m_callable, nullptr);
-			return *this;
-		}
-
-		~function() { clear(); }
-
-		// boost.asio requires handlers to be copy-constructible, but it will move
-		// them, if they're movable. So we trick asio into accepting this handler.
-		// If it attempts to copy, it will cause a link error
-		function(function const&) { assert(false && "functions should not be copied"); }
-		function& operator=(function const&) = delete;
-
-		function() = default;
-		explicit operator bool() const { return m_callable != nullptr; }
-		function& operator=(std::nullptr_t) { clear(); return *this; }
-		void clear()
-		{
-			if (m_callable == nullptr) return;
-			auto fun = m_callable->deallocate_fun;
-			fun(m_callable);
-			m_callable = nullptr;
-		}
-		template <typename... Args>
-		R operator()(Args&&... a)
-		{
-			assert(m_callable);
-			auto fun = m_callable->call_fun;
-			return fun(exchange_(m_callable, nullptr), std::forward<A>(a)...);
-		}
-	private:
-		callable<R, A...>* m_callable = nullptr;
-	};
-
-	// index sequence, to unpack tuple
-	template<std::size_t...> struct seq {};
-	template<std::size_t N, std::size_t... S> struct gens : gens<N-1, N-1, S...> {};
-	template<std::size_t... S> struct gens<0, S...> { using type = seq<S...>; };
-
-	// a binder for move-only types, and movable arguments. It's not a general
-	// binder as it doesn't support partial application, it just binds all
-	// arguments and ignores any arguments passed to the call
-	template <typename Callable, typename R, typename... A>
-	struct move_binder
-	{
-		move_binder(Callable c, A&&... a)
-			: m_args(std::move(a)...)
-			, m_callable(std::move(c))
-		{}
-
-		move_binder(move_binder const&) = delete;
-		move_binder& operator=(move_binder const&) = delete;
-
-		move_binder(move_binder&&) = default;
-		move_binder& operator=(move_binder&&) = default;
-
-		// ignore any arguments passed in. This is used to ignore an error_code
-		// argument for instance
-		template <typename... Args>
-		R operator()(Args...)
-		{
-			return call(typename gens<sizeof...(A)>::type());
-		}
-
-	private:
-
-		template<std::size_t... I>
-		R call(seq<I...>)
-		{
-			return m_callable(std::move(std::get<I>(m_args))...);
-		}
-		std::tuple<A...> m_args;
-		Callable m_callable;
-	};
-
-	template <typename R, typename C, typename... A>
-	move_binder<C, R, A...> move_bind(C c, A&&... a)
-	{
-		return move_binder<C, R, A...>(std::move(c), std::forward<A>(a)...);
-	}
-
-}
-}
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/handler_allocator.hpp b/simulation/libsimulator/include/simulator/handler_allocator.hpp
--- a/simulation/libsimulator/include/simulator/handler_allocator.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/handler_allocator.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef HANDLER_ALLOCATOR_HPP_INCLUDED
-#define HANDLER_ALLOCATOR_HPP_INCLUDED
-
-namespace sim
-{
-namespace aux
-{
-
-template <typename T>
-struct malloc_allocator
-{
-	using value_type = T;
-	using size_type = std::size_t;
-
-	friend bool operator==(malloc_allocator, malloc_allocator) { return true; }
-	friend bool operator!=(malloc_allocator, malloc_allocator) { return false; }
-
-	template <class U>
-	struct rebind { using other = malloc_allocator<U>; };
-
-	malloc_allocator() = default;
-	template <typename U>
-	malloc_allocator(malloc_allocator<U> const&) {}
-
-	T* allocate(std::size_t size) { return static_cast<T*>(std::malloc(size * sizeof(T))); }
-	void deallocate(T* pointer, std::size_t) { std::free(pointer); }
-	using is_always_equal = std::true_type;
-};
-
-// this is a handler wrapper that customizes the asio handler allocator to use
-// malloc instead of new. The purpose is to distinguish allocations that are
-// internal to the simulator and allocations part of the program under test.
-template <typename Handler>
-struct malloc_wrapper
-{
-	malloc_wrapper(Handler h) : m_handler(std::move(h)) {}
-
-	template <typename... Args>
-	void operator()(Args&&... a)
-	{
-		m_handler(std::forward<Args>(a)...);
-	}
-
-	using allocator_type = malloc_allocator<malloc_wrapper<Handler>>;
-
-	allocator_type get_allocator() const noexcept
-	{ return allocator_type{}; }
-
-private:
-	Handler m_handler;
-};
-
-template <typename T>
-malloc_wrapper<T> make_malloc(T h)
-{
-	return malloc_wrapper<T>(std::move(h));
-}
-
-}
-}
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/http_proxy.hpp b/simulation/libsimulator/include/simulator/http_proxy.hpp
--- a/simulation/libsimulator/include/simulator/http_proxy.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/http_proxy.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,103 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef HTTP_PROXY_HPP_INCLUDED
-#define HTTP_PROXY_HPP_INCLUDED
-
-#include "simulator/simulator.hpp"
-
-#ifdef _MSC_VER
-#pragma warning(push)
-// warning C4251: X: class Y needs to have dll-interface to be used by clients of struct
-#pragma warning( disable : 4251)
-#endif
-
-namespace sim
-{
-	struct http_request;
-
-// This is a very simple http proxy that only supports a single
-// concurrent connection
-struct SIMULATOR_DECL http_proxy
-{
-	http_proxy(asio::io_context& ios, unsigned short listen_port);
-
-	void stop();
-
-private:
-
-	void on_accept(boost::system::error_code const& ec);
-	void on_read_request(boost::system::error_code const& ec, size_t bytes_transferred);
-
-	void forward_request(http_request const& req);
-	void open_forward_connection(const asio::ip::tcp::endpoint& target);
-	void on_connected(boost::system::error_code const& ec);
-
-	void on_domain_lookup(boost::system::error_code const& ec
-		, const asio::ip::tcp::resolver::results_type ips);
-
-	void write_server_send_buffer();
-	void on_server_write(boost::system::error_code const& ec, size_t bytes_transferred);
-
-	void on_server_receive(boost::system::error_code const& ec
-		, std::size_t bytes_transferred);
-	void on_server_forward(boost::system::error_code const& ec, size_t bytes_transferred);
-
-	void error(int code, char const* message);
-	void close_connection();
-
-	asio::ip::tcp::resolver m_resolver;
-	asio::ip::tcp::acceptor m_listen_socket;
-
-	// this is the client connection, i.e. the client connecting to us, sending
-	// HTTP requests that we forward
-	asio::ip::tcp::socket m_client_connection;
-	// client endpoint
-	asio::ip::tcp::endpoint m_ep;
-
-	// this is the connection to the server the client's requests are forwarded
-	// to
-	asio::ip::tcp::socket m_server_connection;
-	// true while there is an outstanding write operation to the server
-	bool m_writing_to_server;
-
-	// receive buffer for requests from the client. i.e. client -> proxy (us) -> server
-	char m_client_in_buffer[65536];
-	// buffer size
-	int m_num_client_in_bytes;
-
-	char m_server_out_buffer[65536];
-	int m_num_server_out_bytes;
-
-	// receive buffer for incoming responses, i.e. server -> proxy (us) -> client
-	char m_in_buffer[65536];
-	// buffer size
-	int m_num_in_bytes;
-
-	// set to true when shutting down
-	bool m_close;
-};
-
-}
-
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/http_server.hpp b/simulation/libsimulator/include/simulator/http_server.hpp
--- a/simulation/libsimulator/include/simulator/http_server.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/http_server.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef HTTP_SERVER_HPP_INCLUDED
-#define HTTP_SERVER_HPP_INCLUDED
-
-#include "simulator/simulator.hpp"
-#include <string>
-
-#ifdef _MSC_VER
-#pragma warning(push)
-// warning C4251: X: class Y needs to have dll-interface to be used by clients of struct
-#pragma warning( disable : 4251)
-#endif
-
-namespace sim
-{
-	std::string SIMULATOR_DECL trim(std::string s);
-
-	std::string SIMULATOR_DECL lower_case(std::string s);
-
-	std::string SIMULATOR_DECL normalize(const std::string& s);
-
-	// returns the index to the last byte of the request, or -1 if the buffer
-	// does not contain a full http request
-	int SIMULATOR_DECL find_request_len(char const* buf, int len);
-
-	struct http_request
-	{
-		std::string method;
-		std::string req;
-		std::string path;
-		std::map<std::string, std::string> headers;
-	};
-
-	http_request parse_request(char const* start, int len);
-
-	// builds an HTTP response buffer
-	std::string SIMULATOR_DECL send_response(int code, char const* status_message
-		, int len = 0, char const** extra_header = NULL);
-
-// This is a very simple http server that only supports a single concurrent
-// connection
-struct SIMULATOR_DECL http_server
-{
-	enum flags_t
-	{
-		keep_alive = 1
-	};
-
-	http_server(asio::io_context& ios, unsigned short listen_port
-		, int flags = http_server::keep_alive);
-
-	void stop();
-
-	using handler_t = std::function<std::string (std::string, std::string
-		, std::map<std::string, std::string>&)>;
-	using generator_t = std::function<std::string (std::int64_t, std::int64_t)>;
-
-	void register_handler(std::string const& path, handler_t h);
-	void register_content(std::string const& path
-		, std::int64_t const size, generator_t gen);
-	void register_redirect(std::string const& path, std::string const& target);
-	void register_stall_handler(std::string const& path);
-
-private:
-
-	void on_accept(boost::system::error_code const& ec);
-	void read();
-	void on_read(boost::system::error_code const& ec, size_t bytes_transferred);
-	void on_write(boost::system::error_code const& ec, size_t bytes_transferred
-		, bool close);
-	void close_connection();
-
-	asio::io_context& m_ios;
-
-	asio::ip::tcp::acceptor m_listen_socket;
-
-	asio::ip::tcp::socket m_connection;
-	asio::ip::tcp::endpoint m_ep;
-
-	std::unordered_map<std::string, handler_t> m_handlers;
-	std::set<std::string> m_stall_handlers;
-
-	// read buffer, we receive bytes into this buffer for the connection
-	std::string m_recv_buffer;
-
-	// the number of bytes of m_recv_buffer that we've actually read data into.
-	// The remaining is uninitialized, possibly being read into in an async call
-	int m_bytes_used;
-
-	std::string m_send_buffer;
-
-	// set to true when shutting down
-	bool m_close;
-
-	int m_flags;
-};
-
-}
-
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/noexcept_movable.hpp b/simulation/libsimulator/include/simulator/noexcept_movable.hpp
--- a/simulation/libsimulator/include/simulator/noexcept_movable.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/noexcept_movable.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-/*
-
-Copyright (c) 2017, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef NOEXCEPT_MOVABLE_HPP_INCLUDED
-#define NOEXCEPT_MOVABLE_HPP_INCLUDED
-
-namespace sim {
-namespace aux {
-
-	template <typename T>
-	struct noexcept_movable : T
-	{
-		noexcept_movable() noexcept {}
-		noexcept_movable(noexcept_movable<T>&& rhs) noexcept
-			: T(std::forward<T>(rhs))
-		{}
-		noexcept_movable(noexcept_movable<T> const& rhs)
-			: T(static_cast<T const&>(rhs))
-		{}
-		noexcept_movable(T&& rhs) noexcept : T(std::forward<T>(rhs)) {} // NOLINT
-		noexcept_movable(T const& rhs) : T(rhs) {} // NOLINT
-		noexcept_movable& operator=(noexcept_movable&& rhs) noexcept
-		{
-			this->T::operator=(std::forward<T>(rhs));
-			return *this;
-		}
-		noexcept_movable& operator=(noexcept_movable const& rhs)
-		{
-			this->T::operator=(rhs);
-			return *this;
-		}
-
-		using T::T;
-		using T::operator=;
-	};
-
-}
-}
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/packet.hpp b/simulation/libsimulator/include/simulator/packet.hpp
--- a/simulation/libsimulator/include/simulator/packet.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/packet.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,94 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PACKET_HPP_INCLUDED
-#define PACKET_HPP_INCLUDED
-
-#include "simulator/config.hpp"
-#include "simulator/simulator.hpp" // for route, endpoint
-
-namespace sim { namespace aux {
-
-	struct channel;
-
-	struct packet
-	{
-		packet() = default;
-
-		// this is move-only
-		packet(packet const&) = delete;
-		packet& operator=(packet const&) = delete;
-		packet(packet&&) = default;
-		packet& operator=(packet&&) = default;
-
-		// to keep things simple, don't drop ACKs or errors
-		bool ok_to_drop() const
-		{
-			return type != type_t::syn_ack
-				&& type != type_t::ack
-				&& type != type_t::error;
-		}
-
-		enum class type_t
-		{
-			uninitialized, // invalid type (used for debugging)
-			syn, // TCP connect
-			syn_ack, // TCP connection accepted
-			ack, // the seq_nr is interpreted as "we received this"
-			error, // the error_code (ec) is set
-			payload // the buffer is filled
-		};
-
-		type_t type = type_t::uninitialized;
-
-		boost::system::error_code ec;
-
-		// actual payload
-		std::vector<boost::uint8_t> buffer;
-
-		// used for UDP packets
-		asio::ip::udp::endpoint from;
-
-		// the number of bytes of overhead for this packet. The total packet
-		// size is the number of bytes in the buffer + this number
-		int overhead = 20;
-
-		// each hop in the route will pop itself off and forward the packet to
-		// the next hop
-		route hops;
-
-		// for SYN packets, this is set to the channel we're trying to
-		// establish
-		std::shared_ptr<aux::channel> channel;
-
-		// sequence number of this packet (used for debugging)
-		std::uint64_t seq_nr = 0;
-
-		// the number of (payload) bytes sent over this channel so far. This is
-		// meant to map to the TCP sequence number
-		std::uint32_t byte_counter = 0;
-
-		// this function must be called with this packet in case the packet is
-		// dropped.
-		aux::function<void(aux::packet)> drop_fun;
-	};
-
-}} // sim
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/pcap.hpp b/simulation/libsimulator/include/simulator/pcap.hpp
--- a/simulation/libsimulator/include/simulator/pcap.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/pcap.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-/*
-
-Copyright (c) 2017, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PCAP_HPP_INCLUDED
-#define PCAP_HPP_INCLUDED
-
-#include <fstream>
-#include "simulator/simulator.hpp" // for endpoint
-
-namespace sim { namespace aux
-{
-	struct packet;
-
-	struct pcap
-	{
-		pcap(char const* filename);
-		void log_tcp(packet const& p, asio::ip::tcp::endpoint src
-			, asio::ip::tcp::endpoint dst);
-		void log_udp(packet const& p, asio::ip::udp::endpoint src
-			, asio::ip::udp::endpoint dst);
-	private:
-		std::fstream m_file;
-	};
-}}
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/pop_warnings.hpp b/simulation/libsimulator/include/simulator/pop_warnings.hpp
--- a/simulation/libsimulator/include/simulator/pop_warnings.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/pop_warnings.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the distribution.
-    * Neither the name of the author nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-
-*/
-
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif
-
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
-
-#ifdef __GNUC__
-#pragma GCC diagnostic pop
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/push_warnings.hpp b/simulation/libsimulator/include/simulator/push_warnings.hpp
--- a/simulation/libsimulator/include/simulator/push_warnings.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/push_warnings.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the distribution.
-    * Neither the name of the author nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-
-*/
-
-#ifdef __GNUC__
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wall"
-#pragma GCC diagnostic ignored "-Wsign-conversion"
-#pragma GCC diagnostic ignored "-Wconversion"
-#pragma GCC diagnostic ignored "-Wswitch-enum"
-#pragma GCC diagnostic ignored "-Wold-style-cast"
-#pragma GCC diagnostic ignored "-Wundef"
-#pragma GCC diagnostic ignored "-Wmissing-noreturn"
-#pragma GCC diagnostic ignored "-Wdeprecated"
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-#pragma GCC diagnostic ignored "-Wshadow"
-#pragma GCC diagnostic ignored "-Wunused-variable"
-#pragma GCC diagnostic ignored "-Wpedantic"
-#if __GNUC__ >= 6
-#pragma GCC diagnostic ignored "-Wshift-overflow"
-#pragma GCC diagnostic ignored "-Wshift-count-overflow"
-#pragma GCC diagnostic ignored "-Wshift-count-negative"
-#endif
-#endif
-
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wall"
-#pragma clang diagnostic ignored "-Weverything"
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#pragma clang diagnostic ignored "-Wconversion"
-#pragma clang diagnostic ignored "-Wswitch-enum"
-#pragma clang diagnostic ignored "-Wcovered-switch-default"
-#pragma clang diagnostic ignored "-Wold-style-cast"
-#pragma clang diagnostic ignored "-Wundef"
-#pragma clang diagnostic ignored "-Wweak-vtables"
-#pragma clang diagnostic ignored "-Wmissing-noreturn"
-#pragma clang diagnostic ignored "-Wdeprecated"
-#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-#pragma clang diagnostic ignored "-Wcast-align"
-#pragma clang diagnostic ignored "-Wweak-vtable"
-#pragma clang diagnostic ignored "-Wundef"
-#pragma clang diagnostic ignored "-Wshadow"
-#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
-#pragma clang diagnostic ignored "-Wc++11-long-long"
-#pragma clang diagnostic ignored "-Wc++11-extensions"
-#pragma clang diagnostic ignored "-Wextra-semi"
-#pragma clang diagnostic ignored "-Wunused-parameter"
-#pragma clang diagnostic ignored "-Wreserved-id-macro"
-#pragma clang diagnostic ignored "-Wunused-local-typedef"
-#pragma clang diagnostic ignored "-Wgnu-folding-constant"
-#pragma clang diagnostic ignored "-Wdouble-promotion"
-#pragma clang diagnostic ignored "-Wfloat-equal"
-#endif
-
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-// warning C4005: macro redefinition
-#pragma warning( disable : 4005 )
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/queue.hpp b/simulation/libsimulator/include/simulator/queue.hpp
--- a/simulation/libsimulator/include/simulator/queue.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/queue.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,100 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef QUEUE_HPP_INCLUDED
-#define QUEUE_HPP_INCLUDED
-
-#include "simulator/simulator.hpp"
-#include "simulator/packet.hpp"
-#include "simulator/mallocator.hpp"
-
-#ifdef _MSC_VER
-#pragma warning(push)
-// warning C4251: X: class Y needs to have dll-interface to be used by clients of struct
-#pragma warning( disable : 4251)
-#endif
-
-namespace sim {
-
-	struct timed_packet
-	{
-		timed_packet(chrono::high_resolution_clock::time_point t, aux::packet p)
-			: ts(t), pkt(std::move(p))
-		{}
-		timed_packet(timed_packet&&) = default;
-		timed_packet& operator=(timed_packet&&) = default;
-		timed_packet(timed_packet const&) = delete;
-		timed_packet& operator=(timed_packet const&) = delete;
-		chrono::high_resolution_clock::time_point ts;
-		aux::packet pkt;
-	};
-
-	// this is a queue. It can be configured to contrain
-	struct SIMULATOR_DECL queue : sink
-	{
-		queue(asio::io_context& ios, int bandwidth
-			, chrono::high_resolution_clock::duration propagation_delay
-			, int max_queue_size, std::string name = "queue");
-
-		virtual void incoming_packet(aux::packet p) override final;
-
-		virtual std::string label() const override final;
-
-		queue(queue const&) = delete;
-		queue& operator=(queue const&) = delete;
-
-		queue(queue&&) = default;
-		queue& operator=(queue&&) = delete;
-
-	private:
-
-		void begin_send_next_packet();
-		void next_packet_sent();
-
-		// the queue can't hold more than this number of bytes. Once it's full,
-		// any new packets arriving will be dropped (tail drop)
-		int m_max_queue_size;
-
-		// the amount of time it takes to forward a packet. Every packet is
-		// delayed by at least this much before being forwarded
-		chrono::high_resolution_clock::duration m_forwarding_latency;
-
-		// the number of bytes per second that can be sent. This includes the
-		// packet overhead
-		int m_bandwidth;
-
-		// the number of bytes currently in the packet queue
-		int m_queue_size;
-
-		std::string m_node_name;
-
-		// this is the queue of packets and the time each packet was enqueued
-		std::deque<timed_packet, aux::mallocator<timed_packet>> m_queue;
-		asio::high_resolution_timer m_forward_timer;
-
-		chrono::high_resolution_clock::time_point m_last_forward;
-	};
-
-}
-
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/simulator.hpp b/simulation/libsimulator/include/simulator/simulator.hpp
--- a/simulation/libsimulator/include/simulator/simulator.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/simulator.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,1348 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef SIMULATOR_HPP_INCLUDED
-#define SIMULATOR_HPP_INCLUDED
-
-#include "simulator/push_warnings.hpp"
-
-#include <boost/config.hpp>
-#include <boost/asio/detail/config.hpp>
-#include <boost/asio/basic_deadline_timer.hpp>
-#include <boost/asio/ip/udp.hpp>
-#include <boost/asio/ip/tcp.hpp>
-#include <boost/asio/write.hpp>
-#include <boost/asio/read.hpp>
-#include <boost/asio/io_context.hpp>
-#include <boost/system/error_code.hpp>
-#include <boost/asio/ip/network_v4.hpp>
-#include <boost/asio/buffers_iterator.hpp>
-
-#include <boost/asio/post.hpp>
-#include <boost/asio/defer.hpp>
-#include <boost/asio/dispatch.hpp>
-
-#include <boost/optional.hpp>
-
-#include "simulator/pop_warnings.hpp"
-
-#include "simulator/chrono.hpp"
-#include "simulator/sink_forwarder.hpp"
-#include "simulator/function.hpp"
-#include "simulator/noexcept_movable.hpp"
-#include "simulator/mallocator.hpp"
-
-#include <deque>
-#include <mutex>
-#include <map>
-#include <unordered_map>
-#include <unordered_set>
-#include <set>
-#include <vector>
-#include <list>
-#include <functional>
-
-#ifndef IP_DONTFRAGMENT
-#define IP_DONTFRAGMENT 1
-#endif
-
-namespace sim
-{
-	namespace aux
-	{
-		struct channel;
-		struct packet;
-		struct pcap;
-	}
-
-	// this represents a network route (a series of sinks to pass a packet
-	// through)
-	struct SIMULATOR_DECL route
-	{
-		friend route operator+(route lhs, route rhs)
-		{ return std::move(lhs.append(std::move(rhs))); }
-
-		std::shared_ptr<sink> next_hop() const { return hops.front(); }
-		std::shared_ptr<sink> pop_front()
-		{
-			if (hops.empty()) return std::shared_ptr<sink>();
-			std::shared_ptr<sink> ret(std::move(hops.front()));
-			hops.erase(hops.begin());
-			return ret;
-		}
-		void replace_last(std::shared_ptr<sink> s) { hops.back() = std::move(s); }
-		void prepend(route const& r)
-		{ hops.insert(hops.begin(), r.hops.begin(), r.hops.end()); }
-		void prepend(std::shared_ptr<sink> s) { hops.insert(hops.begin(), std::move(s)); }
-		route& append(route const& r)
-		{ hops.insert(hops.end(), r.hops.begin(), r.hops.end()); return *this; }
-		route& append(std::shared_ptr<sink> s) { hops.push_back(std::move(s)); return *this; }
-		bool empty() const { return hops.empty(); }
-		std::shared_ptr<sink> last() const
-		{ return hops.back(); }
-
-	private:
-		std::deque<std::shared_ptr<sink>, aux::mallocator<std::shared_ptr<sink>>> hops;
-	};
-
-	void forward_packet(aux::packet p);
-
-	struct simulation;
-	struct configuration;
-	struct queue;
-
-	namespace asio
-	{
-
-	using boost::asio::buffer_size;
-	using boost::asio::const_buffer;
-	using boost::asio::mutable_buffer;
-	using boost::asio::buffer;
-
-	using boost::asio::post;
-	using boost::asio::dispatch;
-	using boost::asio::defer;
-
-	struct io_context;
-
-	struct io_executor
-	{
-		io_executor(io_context& ctx) : m_ctx(&ctx) {}
-		io_context& context() const { return *m_ctx; }
-
-		template <typename Handler, typename Allocator>
-		void dispatch(Handler handler, Allocator const& a) const;
-
-		template <typename Handler, typename Allocator>
-		void post(Handler handler, Allocator const& a) const;
-
-		template <typename Handler, typename Allocator>
-		void defer(Handler handler, Allocator const& a) const;
-
-		void on_work_finished() const {}
-		void on_work_started() const {}
-
-		bool running_in_this_thread() const { return true; }
-
-		friend bool operator==(io_executor const& lhs, io_executor const& rhs)
-		{ return lhs.m_ctx == rhs.m_ctx; }
-
-		friend bool operator!=(io_executor const& lhs, io_executor const& rhs)
-		{ return lhs.m_ctx != rhs.m_ctx; }
-
-	private:
-		io_context* m_ctx;
-	};
-
-	struct SIMULATOR_DECL high_resolution_timer
-	{
-		friend struct sim::simulation;
-
-		using time_type = chrono::high_resolution_clock::time_point;
-		using duration_type = chrono::high_resolution_clock::duration;
-
-		using executor_type = io_executor;
-		executor_type get_executor();
-
-		explicit high_resolution_timer(io_context& io_context);
-		high_resolution_timer(io_context& io_context,
-			const time_type& expiry_time);
-		high_resolution_timer(io_context& io_context,
-			const duration_type& expiry_time);
-		high_resolution_timer(high_resolution_timer&&) noexcept = default;
-		high_resolution_timer& operator=(high_resolution_timer&&) noexcept = default;
-		~high_resolution_timer();
-
-		std::size_t cancel();
-		std::size_t cancel_one();
-
-		time_type expiry() const;
-		std::size_t expires_at(const time_type& expiry_time);
-		std::size_t expires_after(const duration_type& expiry_time);
-
-		void wait();
-		void wait(boost::system::error_code& ec);
-
-		void async_wait(aux::function<void(boost::system::error_code const&)> handler);
-
-	private:
-
-		void fire(boost::system::error_code ec);
-
-		time_type m_expiration_time;
-		aux::function<void(boost::system::error_code const&)> m_handler;
-		io_context* m_io_service;
-		bool m_expired;
-	};
-
-	using waitable_timer = high_resolution_timer;
-
-	namespace error = boost::asio::error;
-
-	template <typename Protocol>
-	struct socket_base
-	{
-		socket_base(io_context& ios) : m_io_service(ios) {}
-		socket_base(socket_base&& s) = default;
-
-		enum wait_type_t
-		{
-			wait_read, wait_write, wait_error
-		};
-
-		// io_control
-		using reuse_address = boost::asio::socket_base::reuse_address;
-		using executor_type = io_executor;
-		executor_type get_executor();
-
-		// socket options
-		using send_buffer_size = boost::asio::socket_base::send_buffer_size;
-		using receive_buffer_size = boost::asio::socket_base::receive_buffer_size;
-
-		template <class Option>
-		void set_option(Option const& opt, boost::system::error_code&)
-		{
-			Protocol const p = Protocol::v4();
-			(void)p;
-#ifdef IP_DONTFRAG
-			if (opt.name(p) == IP_DONTFRAG)
-				m_dont_fragment = *reinterpret_cast<int const*>(opt.data(p)) != 0;
-#endif
-#ifdef IP_DONTFRAGMENT
-			if (opt.name(p) == IP_DONTFRAGMENT)
-				m_dont_fragment = *reinterpret_cast<int const*>(opt.data(p)) != 0;
-#endif
-#ifdef IP_MTU_DISCOVER
-			if (opt.name(p) == IP_MTU_DISCOVER)
-				m_dont_fragment = *reinterpret_cast<int const*>(opt.data(p)) == IP_PMTUDISC_DO;
-#endif
-		}
-
-		void set_option(receive_buffer_size const& op, boost::system::error_code&)
-		{
-			m_max_receive_queue_size = op.value();
-		}
-
-		void set_option(send_buffer_size const&, boost::system::error_code&)
-		{
-			// TODO: implement
-		}
-
-		void set_option(reuse_address const&, boost::system::error_code&)
-		{
-			// TODO: implement
-		}
-
-		typename Protocol::endpoint local_endpoint(boost::system::error_code& ec) const
-		{
-			if (!m_open)
-			{
-				ec = error::bad_descriptor;
-				return typename Protocol::endpoint{};
-			}
-
-			return m_user_bound_to;
-		}
-
-		typename Protocol::endpoint local_endpoint() const
-		{
-			boost::system::error_code ec;
-			auto const ret = local_endpoint(ec);
-			if (ec) throw boost::system::system_error(ec);
-			return ret;
-		}
-
-		typename Protocol::endpoint local_bound_to(boost::system::error_code& ec) const
-		{
-			if (!m_open)
-			{
-				ec = error::bad_descriptor;
-				return typename Protocol::endpoint{};
-			}
-
-			return m_bound_to;
-		}
-
-		typename Protocol::endpoint local_bound_to() const
-		{
-			boost::system::error_code ec;
-			auto const ret = local_bound_to(ec);
-			if (ec) throw boost::system::system_error(ec);
-			return ret;
-		}
-
-		template <class Option>
-		void get_option(Option&, boost::system::error_code&) { }
-
-		void get_option(receive_buffer_size& op, boost::system::error_code&)
-		{
-			op = m_max_receive_queue_size;
-		}
-
-		template <class IoControl>
-		void io_control(IoControl const&, boost::system::error_code&) { }
-
-		template <class IoControl>
-		void io_control(IoControl const&) {}
-
-		void non_blocking(bool b, boost::system::error_code&)
-		{ m_non_blocking = b; }
-
-		void non_blocking(bool b)
-		{ m_non_blocking = b; }
-
-		bool is_open() const
-		{
-			return m_open;
-		}
-
-		using message_flags = int;
-
-		// internal interface
-
-		route get_incoming_route();
-		route get_outgoing_route();
-
-	protected:
-
-		io_context& m_io_service;
-
-		typename Protocol::endpoint m_bound_to;
-
-		// this is the interface the user requested to bind to (in order to
-		// distinguish the concrete interface it was bound to and INADDR_ANY if
-		// that was requested). We keep this separately to return it as the local
-		// endpoint
-		typename Protocol::endpoint m_user_bound_to;
-
-		// this is an object implementing the sink interface, forwarding
-		// packets to this socket. If this socket is destructed, this forwarder
-		// is redirected to just drop packets. This is necessary since sinks
-		// must be held by shared_ptr, and socket objects aren't.
-		std::shared_ptr<aux::sink_forwarder> m_forwarder;
-
-		// whether the socket is open or not
-		bool m_open = false;
-
-		// true if the socket is set to non-blocking mode
-		bool m_non_blocking = false;
-
-		// when true, the MTU limit is in effect
-		bool m_dont_fragment = false;
-
-		// the max size of the incoming queue. This is to emulate the send and
-		// receive buffer. This should also depend on the bandwidth, to not
-		// make the queue size not grow too long in time.
-		int m_max_receive_queue_size = 64 * 1024;
-	};
-
-	namespace ip {
-
-	using boost::asio::ip::address;
-	using boost::asio::ip::address_v4;
-	using boost::asio::ip::address_v6;
-
-	using boost::asio::ip::make_address_v4;
-	using boost::asio::ip::make_address_v6;
-	using boost::asio::ip::make_address;
-
-	using boost::asio::ip::make_network_v4;
-
-	template<typename Protocol>
-	struct basic_endpoint : boost::asio::ip::basic_endpoint<Protocol>
-	{
-		basic_endpoint(ip::address const& addr, unsigned short port)
-			: boost::asio::ip::basic_endpoint<Protocol>(addr, port) {}
-		basic_endpoint() : boost::asio::ip::basic_endpoint<Protocol>() {}
-	};
-
-	template <typename Protocol>
-	struct basic_resolver_entry
-	{
-		using endpoint_type = typename Protocol::endpoint;
-		using protocol_type = Protocol;
-
-		basic_resolver_entry() {}
-		basic_resolver_entry(
-			endpoint_type const& ep
-			, std::string const& host
-			, std::string const& service)
-			: m_endpoint(ep)
-			, m_host_name(host)
-			, m_service(service)
-		{}
-
-		endpoint_type endpoint() const { return m_endpoint; }
-		std::string host_name() const { return m_host_name; }
-		operator endpoint_type() const { return m_endpoint; }
-		std::string service_name() const { return m_service; }
-
-	private:
-		endpoint_type m_endpoint;
-		std::string m_host_name;
-		std::string m_service;
-	};
-
-	template<typename Protocol>
-	struct SIMULATOR_DECL basic_resolver
-	{
-		basic_resolver(io_context& ios);
-
-		using protocol_type = Protocol;
-		using results_type = std::vector<basic_resolver_entry<Protocol>, aux::mallocator<basic_resolver_entry<Protocol>>>;
-
-		void cancel();
-
-		void async_resolve(std::string hostname, char const* service
-			, aux::function<void(boost::system::error_code const&,
-				results_type)> handler);
-
-		basic_resolver(basic_resolver&&) noexcept;
-		basic_resolver& operator=(basic_resolver&&) noexcept;
-		basic_resolver(basic_resolver const&) = delete;
-		basic_resolver& operator=(basic_resolver const&) = delete;
-
-		//TODO: add remaining members
-
-	private:
-
-		void on_lookup(boost::system::error_code const& ec);
-
-		struct result_t
-		{
-			chrono::high_resolution_clock::time_point completion_time;
-			boost::system::error_code err;
-			results_type ips;
-			aux::function<void(boost::system::error_code const&,
-				results_type)> handler;
-
-			result_t(
-				chrono::high_resolution_clock::time_point ct
-				, boost::system::error_code e
-				, results_type ips_
-				, aux::function<void(boost::system::error_code const&
-					, results_type)> h)
-				: completion_time(ct)
-				, err(e)
-				, ips(std::move(ips_))
-				, handler(std::move(h))
-			{}
-
-			result_t(result_t&&) noexcept = default;
-			result_t& operator=(result_t&&) = default;
-			result_t(result_t const&) = delete;
-			result_t& operator=(result_t const&) = delete;
-		};
-
-		io_context* m_ios;
-		asio::high_resolution_timer m_timer;
-		using queue_t = aux::noexcept_movable<std::vector<result_t>>;
-
-		queue_t m_queue;
-	};
-
-	struct SIMULATOR_DECL udp
-	{
-		static udp v4() { return udp(AF_INET); }
-		static udp v6() { return udp(AF_INET6); }
-
-		using endpoint = basic_endpoint<udp>;
-
-		struct SIMULATOR_DECL socket : socket_base<udp>, sink
-		{
-			using endpoint_type = ip::udp::endpoint;
-			using protocol_type = ip::udp;
-			using lowest_layer_type = socket;
-
-			socket(io_context& ios);
-			~socket() override;
-
-			socket(socket const&) = delete;
-			socket& operator=(socket const&) = delete;
-			socket(socket&&);
-
-			lowest_layer_type& lowest_layer() { return *this; }
-
-			void bind(ip::udp::endpoint const& ep
-				, boost::system::error_code& ec);
-			void bind(ip::udp::endpoint const& ep);
-
-			void close();
-			void close(boost::system::error_code& ec);
-
-			void cancel(boost::system::error_code& ec);
-			void cancel();
-
-			void open(udp protocol, boost::system::error_code& ec);
-			void open(udp protocol);
-
-			template<typename ConstBufferSequence>
-			std::size_t send_to(ConstBufferSequence const& bufs
-				, udp::endpoint const& destination
-				, socket_base::message_flags flags
-				, boost::system::error_code& ec)
-			{
-				std::vector<asio::const_buffer> b(buffer_sequence_begin(bufs)
-					, buffer_sequence_end(bufs));
-				abort_send_handlers();
-				return send_to_impl(b, destination, flags, ec);
-			}
-
-			template<typename ConstBufferSequence>
-			std::size_t send_to(ConstBufferSequence const& bufs
-				, udp::endpoint const& destination)
-			{
-				std::vector<asio::const_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				abort_send_handlers();
-				boost::system::error_code ec;
-				std::size_t ret = send_to_impl(b, destination, 0, ec);
-				if (ec) throw boost::system::system_error(ec);
-				return ret;
-			}
-
-			void async_wait(socket_base::wait_type_t w
-				, aux::function<void(boost::system::error_code const&)> handler);
-
-			template <class BufferSequence>
-			void async_receive(BufferSequence const& bufs
-				, aux::function<void(boost::system::error_code const&
-					, std::size_t)> handler)
-			{
-				std::vector<asio::mutable_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				abort_recv_handlers();
-
-				async_receive_from_impl(b, nullptr, 0, std::move(handler));
-			}
-
-			template <class BufferSequence>
-			void async_receive_from(BufferSequence const& bufs
-				, udp::endpoint& sender
-				, aux::function<void(boost::system::error_code const&
-					, std::size_t)> handler)
-			{
-				std::vector<asio::mutable_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				abort_recv_handlers();
-
-				async_receive_from_impl(b, &sender, 0, std::move(handler));
-			}
-
-			template <class BufferSequence>
-			void async_receive_from(BufferSequence const& bufs
-				, udp::endpoint& sender
-				, socket_base::message_flags flags
-				, aux::function<void(boost::system::error_code const&
-					, std::size_t)> handler)
-			{
-				std::vector<asio::mutable_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				abort_recv_handlers();
-
-				async_receive_from_impl(b, &sender, flags, std::move(handler));
-			}
-/*
-			void async_read_from(null_buffers const&
-				, aux::function<void(boost::system::error_code const&
-					, std::size_t)> handler)
-			{
-				abort_recv_handlers();
-				async_read_some_null_buffers_impl(std::move(handler));
-			}
-*/
-
-			template <class BufferSequence>
-			std::size_t receive_from(BufferSequence const& bufs
-				, udp::endpoint& sender)
-			{
-				std::vector<asio::mutable_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				assert(!b.empty());
-				abort_recv_handlers();
-				boost::system::error_code ec;
-				std::size_t ret = receive_from_impl(b, &sender, 0, ec);
-				if (ec) throw boost::system::system_error(ec);
-				return ret;
-			}
-
-			template <class BufferSequence>
-			std::size_t receive_from(BufferSequence const& bufs
-				, udp::endpoint& sender
-				, socket_base::message_flags)
-			{
-				std::vector<asio::mutable_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				assert(!b.empty());
-				abort_recv_handlers();
-				boost::system::error_code ec;
-				std::size_t ret = receive_from_impl(b, &sender, 0, ec);
-				if (ec) throw boost::system::system_error(ec);
-				return ret;
-			}
-
-			template <class BufferSequence>
-			std::size_t receive_from(BufferSequence const& bufs
-				, udp::endpoint& sender
-				, socket_base::message_flags
-				, boost::system::error_code& ec)
-			{
-				std::vector<asio::mutable_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				assert(!b.empty());
-				abort_recv_handlers();
-				return receive_from_impl(b, &sender, 0, ec);
-			}
-
-			// TODO: support connect and remote_endpoint
-
-			// internal interface
-
-			// implements sink
-			virtual void incoming_packet(aux::packet p) override final;
-			virtual std::string label() const override final
-			{ return m_bound_to.address().to_string(); }
-
-			void async_receive_from_impl(std::vector<asio::mutable_buffer> const& bufs
-				, udp::endpoint* sender
-				, socket_base::message_flags flags
-				, aux::function<void(boost::system::error_code const&
-					, std::size_t)> handler);
-
-			std::size_t receive_from_impl(
-				std::vector<asio::mutable_buffer> const& bufs
-				, udp::endpoint* sender
-				, socket_base::message_flags flags
-				, boost::system::error_code& ec);
-
-			void async_wait_receive_impl(
-				udp::endpoint* sender
-				, aux::function<void(boost::system::error_code const&)> handler);
-
-		private:
-
-			void maybe_wakeup_reader();
-			void abort_send_handlers();
-			void abort_recv_handlers();
-
-			std::size_t send_to_impl(std::vector<asio::const_buffer> const& b
-				, udp::endpoint const& dst, message_flags flags
-				, boost::system::error_code& ec);
-
-			// this is the next time we'll have an opportunity to send another
-			// outgoing packet. This is used to implement the bandwidth constraints
-			// of channels. This may be in the past, in which case it's OK to send
-			// a packet immediately.
-			chrono::high_resolution_clock::time_point m_next_send;
-
-			// while we're blocked in an async_write_some operation, this is the
-			// handler that should be called once we're done sending
-			aux::function<void(boost::system::error_code const&, std::size_t)>
-				m_send_handler;
-			aux::function<void(boost::system::error_code const&)>
-				m_wait_send_handler;
-
-			// if we have an outstanding read on this socket, this is set to the
-			// handler.
-			aux::function<void(boost::system::error_code const&, std::size_t)>
-				m_recv_handler;
-			aux::function<void(boost::system::error_code const&)>
-				m_wait_recv_handler;
-
-			// if we have an outstanding read operation, this is the buffer to
-			// receive into
-			std::vector<asio::mutable_buffer> m_recv_buffer;
-
-			// if we have an outstanding receive operation, this may point to an
-			// endpoint to fill in the senders IP in
-			udp::endpoint* m_recv_sender;
-
-			asio::high_resolution_timer m_recv_timer;
-			asio::high_resolution_timer m_send_timer;
-
-			// this is the incoming queue of packets for each socket
-			std::list<aux::packet, aux::mallocator<aux::packet>> m_incoming_queue;
-
-			bool m_recv_null_buffers;
-
-			// the number of bytes in the incoming packet queue
-			int m_queue_size;
-
-			// our address family
-			bool m_is_v4;
-		};
-
-		using resolver = basic_resolver<udp>;
-
-		int family() const { return m_family; }
-
-		friend bool operator==(udp const& lhs, udp const& rhs)
-		{ return lhs.m_family == rhs.m_family; }
-
-		friend bool operator!=(udp const& lhs, udp const& rhs)
-		{ return lhs.m_family != rhs.m_family; }
-
-	private:
-		// Construct with a specific family.
-		explicit udp(int protocol_family)
-			: m_family(protocol_family)
-		{}
-
-		int m_family;
-
-	}; // udp
-
-	struct SIMULATOR_DECL tcp
-	{
-		// temporary fix until the resolvers are implemented using our endpoint
-		tcp(boost::asio::ip::tcp p) : m_family(p.family()) {}
-
-		static tcp v4() { return tcp(AF_INET); }
-		static tcp v6() { return tcp(AF_INET6); }
-
-		int family() const { return m_family; }
-
-		using endpoint = basic_endpoint<tcp>;
-
-		struct SIMULATOR_DECL socket : socket_base<tcp>, sink
-		{
-			using endpoint_type = ip::tcp::endpoint;
-			using protocol_type = ip::tcp;
-			using lowest_layer_type = socket;
-
-			explicit socket(io_context& ios);
-			socket(socket const&) = delete;
-			socket& operator=(socket const&) = delete;
-			socket(socket&&);
-			socket& operator=(socket&&);
-
-			~socket() override;
-
-			void close();
-			void close(boost::system::error_code& ec);
-			void open(tcp protocol, boost::system::error_code& ec);
-			void open(tcp protocol);
-			void bind(ip::tcp::endpoint const& ep
-				, boost::system::error_code& ec);
-			void bind(ip::tcp::endpoint const& ep);
-			tcp::endpoint remote_endpoint(boost::system::error_code& ec) const;
-			tcp::endpoint remote_endpoint() const;
-
-			lowest_layer_type& lowest_layer() { return *this; }
-
-			void async_connect(tcp::endpoint const& target
-				, aux::function<void(boost::system::error_code const&)> h);
-
-			template <class ConstBufferSequence>
-			void async_write_some(ConstBufferSequence const& bufs
-				, aux::function<void(boost::system::error_code const&
-					, std::size_t)> handler)
-			{
-				std::vector<asio::const_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				abort_send_handlers();
-				async_write_some_impl(b, std::move(handler));
-			}
-
-			void async_wait(socket_base::wait_type_t const w
-				, aux::function<void(boost::system::error_code const&)> handler)
-			{
-				if (w == socket_base::wait_type_t::wait_write)
-				{
-					abort_send_handlers();
-					assert(false && "not supported yet");
-				}
-				else if (w == socket_base::wait_type_t::wait_read)
-				{
-					abort_recv_handlers();
-					async_wait_read_impl(std::move(handler));
-				}
-			}
-
-			template <class BufferSequence>
-			std::size_t read_some(BufferSequence const& bufs
-				, boost::system::error_code& ec)
-			{
-				assert(m_non_blocking && "blocking operations not supported");
-				std::vector<asio::mutable_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				return read_some_impl(b, ec);
-			}
-
-			template <class ConstBufferSequence>
-			std::size_t write_some(ConstBufferSequence const& bufs
-				, boost::system::error_code& ec)
-			{
-				assert(m_non_blocking && "blocking operations not supported");
-				std::vector<asio::const_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				return write_some_impl(b, ec);
-			}
-
-			template <class BufferSequence>
-			void async_read_some(BufferSequence const& bufs
-				, aux::function<void(boost::system::error_code const&
-					, std::size_t)> handler)
-			{
-				std::vector<asio::mutable_buffer> b(buffer_sequence_begin(bufs), buffer_sequence_end(bufs));
-				abort_recv_handlers();
-
-				async_read_some_impl(b, std::move(handler));
-			}
-
-			std::size_t available(boost::system::error_code & ec) const;
-			std::size_t available() const;
-
-			void cancel(boost::system::error_code& ec);
-			void cancel();
-
-			using socket_base::set_option;
-			using socket_base::get_option;
-			using socket_base::io_control;
-
-			// private interface
-
-			// implements sink
-			virtual void incoming_packet(aux::packet p) override;
-			virtual std::string label() const override final
-			{ return m_bound_to.address().to_string(); }
-
-			void internal_connect(tcp::endpoint const& bind_ip
-				, std::shared_ptr<aux::channel> const& c
-				, boost::system::error_code& ec);
-
-			void abort_send_handlers();
-			void abort_recv_handlers();
-
-			virtual bool internal_is_listening();
-		protected:
-
-			void maybe_wakeup_reader();
-			void maybe_wakeup_writer();
-
-			void async_write_some_impl(std::vector<asio::const_buffer> const& bufs
-				, aux::function<void(boost::system::error_code const&, std::size_t)> handler);
-			void async_read_some_impl(std::vector<asio::mutable_buffer> const& bufs
-				, aux::function<void(boost::system::error_code const&, std::size_t)> handler);
-			void async_wait_read_impl(
-				aux::function<void(boost::system::error_code const&)> handler);
-			std::size_t write_some_impl(std::vector<asio::const_buffer> const& bufs
-				, boost::system::error_code& ec);
-			std::size_t read_some_impl(std::vector<asio::mutable_buffer> const& bufs
-				, boost::system::error_code& ec);
-
-			void send_packet(aux::packet p);
-
-			// called when a packet is dropped
-			void packet_dropped(aux::packet p);
-
-			aux::function<void(boost::system::error_code const&)> m_connect_handler;
-
-			asio::high_resolution_timer m_connect_timer;
-
-			// the tcp "packet size" (segment size)
-			// TODO: name this constant!
-			int m_mss = 1475;
-
-			// while we're blocked in an async_write_some operation, this is the
-			// handler that should be called once we're done sending
-			aux::function<void(boost::system::error_code const&, std::size_t)> m_send_handler;
-			aux::function<void(boost::system::error_code const&)> m_wait_send_handler;
-
-			std::vector<asio::const_buffer> m_send_buffer;
-
-			// this is the incoming queue of packets for each socket
-			std::list<aux::packet, aux::mallocator<aux::packet>> m_incoming_queue;
-
-			// the number of bytes in the incoming packet queue
-			int m_queue_size = 0;
-
-			// if we have an outstanding read on this socket, this is set to the
-			// handler.
-			aux::function<void(boost::system::error_code const&, std::size_t)> m_recv_handler;
-			aux::function<void(boost::system::error_code const&)> m_wait_recv_handler;
-
-			// if we have an outstanding buffer to receive into, these are them
-			std::vector<asio::mutable_buffer> m_recv_buffer;
-
-			asio::high_resolution_timer m_recv_timer;
-
-			// our address family
-			bool m_is_v4 = true;
-
-			// true if the currently outstanding read operation is for null_buffers
-			bool m_recv_null_buffers = false;
-
-			// true if the currenly outstanding write operation is for null_buffers
-			bool m_send_null_buffers = false;
-
-			// if this socket is connected to another endpoint, this object is
-			// shared between both sockets and contain information and state about
-			// the channel.
-			std::shared_ptr<aux::channel> m_channel;
-
-			std::uint64_t m_next_outgoing_seq = 0;
-			std::uint64_t m_next_incoming_seq = 0;
-
-			// the sequence number of the last dropped packet. We should only cut
-			// the cwnd in half once per round-trip. If a whole window is lost, we
-			// need to only halve it once
-			std::uint64_t m_last_drop_seq = 0;
-
-			// the current congestion window size (in bytes)
-			int m_cwnd = m_mss * 2;
-
-			// the number of bytes that have been sent but not ACKed yet
-			int m_bytes_in_flight = 0;
-
-			// reorder buffer for when packets are dropped
-			std::map<std::uint64_t, aux::packet, std::less<std::uint64_t>, aux::mallocator<std::pair<std::uint64_t const, aux::packet>>> m_reorder_buffer;
-
-			// the sizes of packets given their sequence number
-			std::unordered_map<std::uint64_t, int, std::hash<std::uint64_t>, std::equal_to<std::uint64_t>, aux::mallocator<std::pair<std::uint64_t const, int>>> m_outstanding_packet_sizes;
-
-			// packets to re-send (because they were dropped)
-			std::list<aux::packet, aux::mallocator<aux::packet>> m_outgoing_packets;
-		};
-
-		struct SIMULATOR_DECL acceptor : socket
-		{
-			explicit acceptor(io_context& ios);
-			acceptor(acceptor&&);
-			~acceptor() override;
-
-			void cancel(boost::system::error_code& ec);
-			void cancel();
-
-			void listen(int qs = -1);
-			void listen(int qs, boost::system::error_code& ec);
-
-			void async_accept(ip::tcp::socket& peer
-				, aux::function<void(boost::system::error_code const&)> h);
-			void async_accept(ip::tcp::socket& peer
-				, ip::tcp::endpoint& peer_endpoint
-				, aux::function<void(boost::system::error_code const&)> h);
-			void async_accept(aux::function<void(boost::system::error_code const&, ip::tcp::socket peer)> h);
-
-			void close(boost::system::error_code& ec);
-			void close();
-
-			// private interface
-
-			// implements sink
-			virtual void incoming_packet(aux::packet p) override final;
-			virtual bool internal_is_listening() override final;
-
-		private:
-			// check the incoming connection queue to see if any connection in
-			// there is ready to be accepted and delivered to the user
-			void check_accept_queue();
-			void do_check_accept_queue(boost::system::error_code const& ec);
-
-			aux::function<void(boost::system::error_code const&)> m_accept_handler;
-			aux::function<void(boost::system::error_code const&, ip::tcp::socket)> m_accept_handler2;
-
-			// the number of half-open incoming connections this listen socket can
-			// hold. If this is -1, this socket is not yet listening and incoming
-			// connection attempts should be rejected.
-			int m_queue_size_limit;
-
-			// these are incoming connection attempts. Both half-open and
-			// completely connected. When accepting a connection, this queue is
-			// checked first before waiting for a connection attempt.
-			using incoming_conns_t = std::vector<std::shared_ptr<aux::channel>, aux::mallocator<std::shared_ptr<aux::channel>>>;
-			incoming_conns_t m_incoming_conns;
-
-			// for new-style accept, allocate socket in here just to fail early
-			boost::optional<ip::tcp::socket> m_new_socket;
-
-			// the socket to accept a connection into
-			tcp::socket* m_accept_into;
-
-			// the endpoint to write the remote endpoint into when accepting
-			tcp::endpoint* m_remote_endpoint;
-
-			// non copyable
-			acceptor(acceptor const&);
-			acceptor& operator=(acceptor const&);
-		};
-
-		using resolver = basic_resolver<tcp>;
-
-		friend bool operator==(tcp const& lhs, tcp const& rhs)
-		{ return lhs.m_family == rhs.m_family; }
-
-		friend bool operator!=(tcp const& lhs, tcp const& rhs)
-		{ return lhs.m_family != rhs.m_family; }
-
-	private:
-		// Construct with a specific family.
-		explicit tcp(int protocol_family)
-			: m_family(protocol_family)
-		{}
-
-		int m_family;
-	};
-
-	extern template struct basic_resolver<udp>;
-	extern template struct basic_resolver<tcp>;
-
-	} // ip
-
-	} // asio
-
-	struct SIMULATOR_DECL simulation
-	{
-		// it calls fire() when a timer fires
-		friend struct high_resolution_timer;
-
-		simulation(configuration& config);
-		~simulation();
-
-		std::size_t run();
-
-		std::size_t poll(boost::system::error_code& ec);
-		std::size_t poll();
-
-		std::size_t poll_one(boost::system::error_code& ec);
-		std::size_t poll_one();
-
-		void stop();
-		bool stopped() const;
-		void restart();
-		// private interface
-
-		void add_timer(asio::high_resolution_timer* t);
-		void remove_timer(asio::high_resolution_timer* t);
-
-		boost::asio::io_context& get_internal_service()
-		{ return m_service; }
-
-		asio::io_context& get_io_context()
-		{ return *m_internal_ios; }
-
-		asio::ip::tcp::endpoint bind_socket(asio::ip::tcp::socket* socket
-			, asio::ip::tcp::endpoint ep
-			, boost::system::error_code& ec);
-		void unbind_socket(asio::ip::tcp::socket* socket
-			, asio::ip::tcp::endpoint const& ep);
-		void rebind_socket(asio::ip::tcp::socket* s, asio::ip::tcp::endpoint ep);
-
-		asio::ip::udp::endpoint bind_udp_socket(asio::ip::udp::socket* socket
-			, asio::ip::udp::endpoint ep
-			, boost::system::error_code& ec);
-		void unbind_udp_socket(asio::ip::udp::socket* socket
-			, asio::ip::udp::endpoint const& ep);
-		void rebind_udp_socket(asio::ip::udp::socket* socket, asio::ip::udp::endpoint ep);
-
-		std::shared_ptr<aux::channel> internal_connect(asio::ip::tcp::socket* s
-			, asio::ip::tcp::endpoint const& target, boost::system::error_code& ec);
-
-		route find_udp_socket(
-			asio::ip::udp::socket const& socket
-			, asio::ip::udp::endpoint const& ep);
-
-		configuration& config() const { return m_config; }
-
-		void add_io_service(asio::io_context* ios);
-		void remove_io_service(asio::io_context* ios);
-		std::vector<asio::io_context*> get_all_io_services() const;
-
-		aux::pcap* get_pcap() const { return m_pcap.get(); }
-		void log_pcap(char const* filename);
-
-	private:
-		struct timer_compare
-		{
-			bool operator()(asio::high_resolution_timer const* lhs
-				, asio::high_resolution_timer const* rhs) const
-			{ return lhs->expiry() < rhs->expiry(); }
-		};
-
-		configuration& m_config;
-
-		std::unique_ptr<aux::pcap> m_pcap;
-
-		// all non-expired timers
-		std::mutex m_timer_queue_mutex;
-		using timer_queue_t = std::multiset<asio::high_resolution_timer*, timer_compare, aux::mallocator<asio::high_resolution_timer*>>;
-		timer_queue_t m_timer_queue;
-
-		// these are the io services that represent nodes on the network
-		std::unordered_set<asio::io_context*, std::hash<asio::io_context*>, std::equal_to<asio::io_context*>, aux::mallocator<asio::io_context*>> m_nodes;
-
-		using listen_sockets_t = std::map<asio::ip::tcp::endpoint, asio::ip::tcp::socket*>;
-		using listen_socket_iter_t = listen_sockets_t::iterator;
-		listen_sockets_t m_listen_sockets;
-
-		using udp_sockets_t = std::map<asio::ip::udp::endpoint, asio::ip::udp::socket*>;
-		using udp_socket_iter_t = udp_sockets_t::iterator;
-		udp_sockets_t m_udp_sockets;
-
-		// used for internal timers. this is a pimpl sine our io_context is
-		// incomplete at this point
-		std::unique_ptr<asio::io_context> m_internal_ios;
-
-		// the next port to use for an outgoing connection, where the port is not
-		// specified. We want this to be as unique as possible, to distinguish the
-		// TCP streams.
-		std::uint16_t m_next_bind_port = 2000;
-
-		bool m_stopped = false;
-
-		// underlying message queue
-		boost::asio::io_context m_service;
-	};
-
-	namespace asio {
-
-	using boost::asio::async_write;
-	using boost::asio::async_read;
-
-	// boost.asio compatible io_context class that simulates the network
-	// and time.
-	struct SIMULATOR_DECL io_context : boost::asio::execution_context
-	{
-		io_context(sim::simulation& sim);
-		io_context(sim::simulation& sim, ip::address const& ip);
-		io_context(sim::simulation& sim, std::vector<ip::address> const& ips);
-		io_context(std::size_t threads_hint = 0);
-		~io_context();
-
-		// not copyable and non movable (it's not movable because we currently
-		// keep pointers to the io_context instances in the simulator object)
-		io_context(io_context const&) = delete;
-		io_context(io_context&&) = delete;
-		io_context& operator=(io_context const&) = delete;
-		io_context& operator=(io_context&&) = delete;
-
-		std::size_t run(boost::system::error_code& ec);
-		std::size_t run();
-
-		std::size_t poll(boost::system::error_code& ec);
-		std::size_t poll();
-
-		std::size_t poll_one(boost::system::error_code& ec);
-		std::size_t poll_one();
-
-		void stop();
-		bool stopped() const;
-		void restart();
-
-		template <typename Handler, typename Allocator>
-		void dispatch_impl(Handler handler, Allocator const& a)
-		{ get_internal_service().get_executor().dispatch(std::move(handler), a); }
-
-		template <typename Handler, typename Allocator>
-		void post_impl(Handler handler, Allocator const& a)
-		{ get_internal_service().get_executor().post(std::move(handler), a); }
-
-		template <typename Handler, typename Allocator>
-		void defer_impl(Handler handler, Allocator const& a)
-		{ get_internal_service().get_executor().defer(std::move(handler), a); }
-
-		// internal interface
-		boost::asio::io_context& get_internal_service();
-
-		void add_timer(high_resolution_timer* t);
-		void remove_timer(high_resolution_timer* t);
-
-		ip::tcp::endpoint bind_socket(ip::tcp::socket* socket, ip::tcp::endpoint ep
-			, boost::system::error_code& ec);
-		void unbind_socket(ip::tcp::socket* socket
-			, ip::tcp::endpoint const& ep);
-		void rebind_socket(asio::ip::tcp::socket* s, asio::ip::tcp::endpoint ep);
-
-		ip::udp::endpoint bind_udp_socket(ip::udp::socket* socket, ip::udp::endpoint ep
-			, boost::system::error_code& ec);
-		void unbind_udp_socket(ip::udp::socket* socket
-			, ip::udp::endpoint const& ep);
-		void rebind_udp_socket(asio::ip::udp::socket* socket, asio::ip::udp::endpoint ep);
-
-		std::shared_ptr<aux::channel> internal_connect(ip::tcp::socket* s
-			, ip::tcp::endpoint const& target, boost::system::error_code& ec);
-
-		route find_udp_socket(asio::ip::udp::socket const& socket
-			, ip::udp::endpoint const& ep);
-
-		route const& get_outgoing_route(ip::address ip) const
-		{ return m_outgoing_route.find(ip)->second; }
-
-		route const& get_incoming_route(ip::address ip) const
-		{ return m_incoming_route.find(ip)->second; }
-
-		int get_path_mtu(const asio::ip::address& source, const asio::ip::address& dest) const;
-		std::vector<ip::address> const& get_ips() const { return m_ips; }
-
-		sim::simulation& sim() { return m_sim; }
-
-		using executor_type = io_executor;
-		executor_type get_executor() { return executor_type(*this); }
-
-	private:
-
-		sim::simulation& m_sim;
-		std::vector<ip::address> m_ips;
-
-		// these are determined by the configuration. They may include NATs and
-		// DSL modems (queues)
-		std::map<ip::address, route> m_outgoing_route;
-		std::map<ip::address, route> m_incoming_route;
-
-		bool m_stopped = false;
-	};
-
-	template <typename Handler, typename Allocator>
-	void io_executor::dispatch(Handler handler, Allocator const& a) const
-	{ m_ctx->dispatch_impl(std::move(handler), a); }
-
-	template <typename Handler, typename Allocator>
-	void io_executor::post(Handler handler, Allocator const& a) const
-	{ m_ctx->post_impl(std::move(handler), a); }
-
-	template <typename Handler, typename Allocator>
-	void io_executor::defer(Handler handler, Allocator const& a) const
-	{ m_ctx->defer_impl(std::move(handler), a); }
-
-	template <typename Protocol>
-	io_executor
-	socket_base<Protocol>::get_executor()
-	{ return io_executor(m_io_service); }
-
-	template <typename Protocol>
-	route socket_base<Protocol>::get_incoming_route()
-	{
-		route ret = m_io_service.get_incoming_route(m_bound_to.address());
-		assert(m_forwarder);
-		ret.append(std::static_pointer_cast<sim::sink>(m_forwarder));
-		return ret;
-	}
-
-	template <typename Protocol>
-	route socket_base<Protocol>::get_outgoing_route()
-	{
-		return route(m_io_service.get_outgoing_route(m_bound_to.address()));
-	}
-
-	} // asio
-
-	// user supplied configuration of the network to simulate
-	struct SIMULATOR_DECL configuration
-	{
-		virtual ~configuration() {}
-
-		// build the network
-		virtual void build(simulation& sim) = 0;
-
-		// return the hops on the network packets from src to dst need to traverse
-		virtual route channel_route(asio::ip::address src
-			, asio::ip::address dst) = 0;
-
-		// return the hops an incoming packet to ep need to traverse before
-		// reaching the socket (for instance a NAT)
-		virtual route incoming_route(asio::ip::address ip) = 0;
-
-		// return the hops an outgoing packet from ep need to traverse before
-		// reaching the network (for instance a DSL modem)
-		virtual route outgoing_route(asio::ip::address ip) = 0;
-
-		// return the path MTU between the two IP addresses
-		// For TCP sockets, this will be called once when the connection is
-		// established. For UDP sockets it's called for every burst of packets
-		// that are sent
-		virtual int path_mtu(asio::ip::address ip1, asio::ip::address ip2) = 0;
-
-		// called for every hostname lookup made by the client. ``reqyestor`` is
-		// the node performing the lookup, ``hostname`` is the name being looked
-		// up. Resolve the name into addresses and fill in ``result`` or set
-		// ``ec`` if the hostname is not found or some other error occurs. The
-		// return value is the latency of the lookup. The client's callback won't
-		// be called until after waiting this long.
-		virtual chrono::high_resolution_clock::duration hostname_lookup(
-			asio::ip::address const& requestor
-			, std::string hostname
-			, std::vector<asio::ip::address>& result
-			, boost::system::error_code& ec) = 0;
-
-		virtual void clear() = 0;
-	};
-
-	struct SIMULATOR_DECL default_config : configuration
-	{
-		default_config() : m_sim(nullptr) {}
-
-		void build(simulation& sim) override;
-		route channel_route(asio::ip::address src, asio::ip::address dst) override;
-		route incoming_route(asio::ip::address ip) override;
-		route outgoing_route(asio::ip::address ip) override;
-		int path_mtu(asio::ip::address ip1, asio::ip::address ip2) override;
-		chrono::high_resolution_clock::duration hostname_lookup(
-			asio::ip::address const& requestor
-			, std::string hostname
-			, std::vector<asio::ip::address>& result
-			, boost::system::error_code& ec) override;
-
-		void clear() override;
-	protected:
-		std::shared_ptr<queue> m_network;
-		std::map<asio::ip::address, std::shared_ptr<queue>> m_incoming;
-		std::map<asio::ip::address, std::shared_ptr<queue>> m_outgoing;
-		simulation* m_sim;
-	};
-
-	namespace aux
-	{
-		/* the channel can be in the following states:
-			1. handshake-1 - the initiating socket has sent SYN
-			2. handshake-2 - the accepting connection has sent SYN+ACK
-			3. handshake-3 - the initiating connection has received the SYN+ACK and
-			                 considers the connection open, but the 3rd handshake
-			                 message is still in flight.
-			4. connected   - the accepting side has received the 3rd handshake
-			                 packet and considers it open
-
-			Whenever a connection attempt is made to a listening socket, as long as
-			there is still space in the incoming socket queue, the accepting side
-			will always respond immediately and complete the handshake, then wait
-			until the user calls async_accept (which in this case would complete
-			immediately).
-		*/
-		struct SIMULATOR_DECL channel
-		{
-			channel() {}
-			// index 0 is the incoming route to the socket that initiated the connection.
-			// index 1 may be empty while the connection is half-open
-			route hops[2];
-
-			// the actual endpoint of each end of the channel
-			asio::ip::tcp::endpoint ep[2];
-
-			// observable endpoint of each side of the channel. This is not how you
-			// see yourself, just the other end
-			asio::ip::tcp::endpoint visible_ep[2];
-
-			// the number of bytes sent from respective direction
-			// this is used to simulate the TCP sequence number, so it deliberately
-			// is meant to wrap at 32 bits
-			std::uint32_t bytes_sent[2];
-
-			int remote_idx(asio::ip::tcp::endpoint const& self) const;
-			int self_idx(asio::ip::tcp::endpoint const& self) const;
-		};
-
-	} // aux
-
-	void SIMULATOR_DECL dump_network_graph(simulation const& s, const std::string& filename);
-}
-
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif
-
-#endif // SIMULATOR_HPP_INCLUDED
-
diff -Naupr a/simulation/libsimulator/include/simulator/sink.hpp b/simulation/libsimulator/include/simulator/sink.hpp
--- a/simulation/libsimulator/include/simulator/sink.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/sink.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef SINK_HPP_INCLUDED
-#define SINK_HPP_INCLUDED
-
-#include "simulator/config.hpp"
-#include <string>
-
-namespace sim {
-
-namespace aux {
-	struct packet;
-}
-
-	// this is an interface for somthing that can accept incoming packets,
-	// such as queues, sockets, NATs and TCP congestion windows
-	struct SIMULATOR_DECL sink
-	{
-		virtual void incoming_packet(aux::packet p) = 0;
-
-		// used for visualization
-		virtual std::string label() const = 0;
-
-		virtual std::string attributes() const { return "shape=box"; }
-		virtual ~sink() = default;
-	};
-
-} // sim
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/sink_forwarder.hpp b/simulation/libsimulator/include/simulator/sink_forwarder.hpp
--- a/simulation/libsimulator/include/simulator/sink_forwarder.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/sink_forwarder.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef SINK_FORWARDER_HPP_INCLUDED
-#define SINK_FORWARDER_HPP_INCLUDED
-
-#include "simulator/config.hpp"
-#include "simulator/sink.hpp"
-
-namespace sim { namespace aux {
-
-	struct packet;
-
-	struct SIMULATOR_DECL sink_forwarder final : sink
-	{
-		sink_forwarder(sink* dst);
-		void incoming_packet(packet p) override;
-		std::string label() const override;
-		void reset(sink* s = nullptr);
-
-	private:
-		sink* m_dst;
-	};
-
-}} // sim
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/socks_server.hpp b/simulation/libsimulator/include/simulator/socks_server.hpp
--- a/simulation/libsimulator/include/simulator/socks_server.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/socks_server.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,174 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef SOCKS_SERVER_HPP_INCLUDED
-#define SOCKS_SERVER_HPP_INCLUDED
-
-#include "simulator/simulator.hpp"
-
-#ifdef _MSC_VER
-#pragma warning(push)
-// warning C4251: X: class Y needs to have dll-interface to be used by clients of struct
-#pragma warning( disable : 4251)
-#endif
-
-namespace sim
-{
-
-enum socks_flag
-{
-	// when this flag is set, the proxy will close the client connection
-	// immediately after sending the response to a UDP ASSOCIATE command
-	disconnect_udp_associate = 1
-};
-
-struct SIMULATOR_DECL socks_connection : std::enable_shared_from_this<socks_connection>
-{
-	socks_connection(asio::io_context& ios, int version, std::array<int, 3>& cmd_counts
-		, std::uint32_t flags);
-
-	asio::ip::tcp::socket& socket() { return m_client_connection; }
-
-	void start();
-
-private:
-
-	void on_handshake1(boost::system::error_code const& ec, size_t bytes_transferred);
-	void on_handshake2(boost::system::error_code const& ec, size_t bytes_transferred);
-	void on_handshake3(boost::system::error_code const& ec, size_t bytes_transferred);
-	void on_request1(boost::system::error_code const& ec, size_t bytes_transferred);
-	void on_request2(boost::system::error_code const& ec, size_t bytes_transferred);
-
-	void on_write(boost::system::error_code const& ec, size_t bytes_transferred
-		, bool close);
-	void close_connection();
-
-	int format_response(asio::ip::address const& addr, int port, int response);
-
-	void on_connected(boost::system::error_code const& ec);
-	void on_request_domain_name(boost::system::error_code const& ec, size_t bytes_transferred);
-	void on_request_domain_lookup(boost::system::error_code const& ec
-		, const asio::ip::tcp::resolver::results_type ips);
-
-	void open_forward_connection(asio::ip::tcp::endpoint const& target);
-	void bind_connection(asio::ip::tcp::endpoint const& target);
-	void start_accept(boost::system::error_code const& ec);
-
-	void udp_associate(asio::ip::tcp::endpoint const& target);
-	void on_read_udp(boost::system::error_code const& ec, std::size_t bytes_transferred);
-	void wait_for_eof(boost::system::error_code const& ec, std::size_t bytes_transferred);
-
-	void on_server_receive(boost::system::error_code const& ec
-		, std::size_t bytes_transferred);
-	void on_server_forward(boost::system::error_code const& ec
-		, size_t bytes_transferred);
-
-	void on_client_receive(boost::system::error_code const& ec
-		, std::size_t bytes_transferred);
-	void on_client_forward(boost::system::error_code const& ec
-		, size_t bytes_transferred);
-
-	char const* command() const;
-
-	asio::io_context& m_ios;
-
-	asio::ip::tcp::resolver m_resolver;
-
-	// this is the SOCKS client connection, i.e. the client connecting to us and
-	// being forwarded
-	asio::ip::tcp::socket m_client_connection;
-
-	// this is the connection to the server the socks client is being forwarded
-	// to
-	asio::ip::tcp::socket m_server_connection;
-	asio::ip::tcp::acceptor m_bind_socket;
-
-	asio::ip::udp::socket m_udp_associate;
-	asio::ip::udp::endpoint m_udp_associate_ep;
-	asio::ip::udp::endpoint m_udp_from;
-
-	std::array<char, 1500> m_udp_buffer;
-
-	// receive buffer for data going out, i.e. client -> proxy (us) -> server
-	char m_out_buffer[65536];
-	// buffer size
-	int m_num_out_bytes;
-
-	// receive buffer for data coming in, i.e. server -> proxy (us) -> client
-	char m_in_buffer[65536];
-	// buffer size
-	int m_num_in_bytes;
-
-	// set to true when shutting down
-	bool m_close;
-
-	// the SOCKS protocol version (4 or 5)
-	const int m_version;
-
-	int m_command;
-
-	std::array<int, 3>& m_cmd_counts;
-
-	std::uint32_t const m_flags;
-};
-
-// This is a very simple socks4 and 5 server that only supports a single
-// concurrent connection
-struct SIMULATOR_DECL socks_server
-{
-	socks_server(asio::io_context& ios, unsigned short listen_port
-		, int version = 5, std::uint32_t flags = 0);
-
-	void stop();
-
-	// return the number of CONNECT, BIND and UDP_ASSOCIATE commands the proxy
-	// has received
-	std::array<int, 3> cmd_counts() const
-	{ return m_cmd_counts; }
-
-private:
-
-	void on_accept(boost::system::error_code const& ec);
-
-	asio::io_context& m_ios;
-
-	asio::ip::tcp::acceptor m_listen_socket;
-
-	std::shared_ptr<socks_connection> m_conn;
-
-	asio::ip::tcp::endpoint m_ep;
-
-	// set to true when shutting down
-	bool m_close;
-
-	// the SOCKS protocol version (4 or 5)
-	const int m_version;
-
-	std::array<int, 3> m_cmd_counts;
-
-	std::uint32_t const m_flags;
-};
-
-}
-
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif
-
-#endif
-
diff -Naupr a/simulation/libsimulator/include/simulator/utils.hpp b/simulation/libsimulator/include/simulator/utils.hpp
--- a/simulation/libsimulator/include/simulator/utils.hpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/include/simulator/utils.hpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/*
-
-Copyright (c) 2016, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef UTILS_HPP_INCLUDED
-#define UTILS_HPP_INCLUDED
-
-#include "simulator/simulator.hpp"
-
-namespace sim
-{
-
-// shortcut for creating a timer with a timeout and action
-struct timer
-{
-	timer(simulation& sim, chrono::high_resolution_clock::duration timeout
-		, aux::function<void(boost::system::error_code const&)>&& f)
-		: m_ios(sim, asio::ip::address_v4())
-		, m_timer(m_ios)
-	{
-		m_timer.expires_after(timeout);
-		m_timer.async_wait(std::move(f));
-	}
-
-private:
-	sim::asio::io_context m_ios;
-	sim::asio::high_resolution_timer m_timer;
-};
-
-} // sim
-
-#endif
-
diff -Naupr a/simulation/libsimulator/src/acceptor.cpp b/simulation/libsimulator/src/acceptor.cpp
--- a/simulation/libsimulator/src/acceptor.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/acceptor.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,379 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/packet.hpp"
-
-#include <functional>
-#include <boost/beast/core/bind_handler.hpp>
-
-#include <cinttypes>
-
-using boost::beast::bind_handler;
-
-typedef sim::chrono::high_resolution_clock::time_point time_point;
-typedef sim::chrono::high_resolution_clock::duration duration;
-
-namespace sim {
-namespace asio {
-namespace ip {
-
-	tcp::acceptor::acceptor(io_context& ios)
-		: socket(ios)
-		, m_queue_size_limit(-1)
-	{}
-
-	tcp::acceptor::acceptor(acceptor&&) = default;
-
-	tcp::acceptor::~acceptor()
-	{
-		boost::system::error_code ec;
-		close(ec);
-	}
-
-	void tcp::acceptor::listen(int qs)
-	{
-		boost::system::error_code ec;
-		listen(qs, ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	void tcp::acceptor::listen(int qs, boost::system::error_code& ec)
-	{
-		if (qs == -1) qs = 20;
-
-		if (!m_open)
-		{
-			ec = error::bad_descriptor;
-			return;
-		}
-		if (m_bound_to == ip::tcp::endpoint())
-		{
-			ec = error::invalid_argument;
-			return;
-		}
-
-		m_queue_size_limit = qs;
-		ec.clear();
-	}
-
-	void tcp::acceptor::close(boost::system::error_code& ec)
-	{
-		m_queue_size_limit = -1;
-		cancel(ec);
-		socket::close(ec);
-	}
-
-	void tcp::acceptor::close()
-	{
-		if (m_accept_handler)
-		{
-			post(m_io_service, bind_handler(std::exchange(m_accept_handler, nullptr)
-				, boost::system::error_code(error::operation_aborted)));
-		}
-		if (m_accept_handler2)
-		{
-			post(m_io_service, [&, h = std::exchange(m_accept_handler2, nullptr)] () mutable {
-				h(boost::system::error_code(error::operation_aborted)
-					, ip::tcp::socket(m_io_service));
-				});
-		}
-	}
-
-	void tcp::acceptor::cancel(boost::system::error_code& ec)
-	{
-		ec.clear();
-		if (m_accept_handler)
-		{
-			try
-			{
-				post(m_io_service, bind_handler(std::exchange(m_accept_handler, nullptr)
-					, boost::system::error_code(error::operation_aborted)));
-			}
-			catch (std::bad_alloc const&)
-			{
-				ec = error::no_memory;
-			}
-			catch (std::exception const&)
-			{
-				ec = error::no_memory;
-			}
-		}
-		if (m_accept_handler2)
-		{
-			try
-			{
-				post(m_io_service, [&, h = std::exchange(m_accept_handler2, nullptr)] () mutable {
-					h(boost::system::error_code(error::operation_aborted)
-						, ip::tcp::socket(m_io_service));
-				});
-			}
-			catch (std::bad_alloc const&)
-			{
-				ec = error::no_memory;
-			}
-			catch (std::exception const&)
-			{
-				ec = error::no_memory;
-			}
-		}
-	}
-
-	void tcp::acceptor::cancel()
-	{
-		boost::system::error_code ec;
-		cancel(ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	void tcp::acceptor::async_accept(ip::tcp::socket& peer
-		, aux::function<void(boost::system::error_code const&)> h)
-	{
-		// TODO: assert that the io_context we use is the same as the one peer use
-		if (peer.is_open())
-		{
-			boost::system::error_code ec;
-			peer.close(ec);
-		}
-
-		if (m_accept_handler)
-		{
-			m_accept_into = nullptr;
-			m_remote_endpoint = nullptr;
-			post(m_io_service, bind_handler(std::exchange(m_accept_handler, nullptr)
-				, boost::system::error_code(error::operation_aborted)));
-		}
-		if (m_accept_handler2)
-		{
-			m_accept_into = nullptr;
-			m_remote_endpoint = nullptr;
-			post(m_io_service, [&, h = std::exchange(m_accept_handler2, nullptr)] () mutable {
-				h(boost::system::error_code(error::operation_aborted)
-					, ip::tcp::socket(m_io_service));
-			});
-		}
-		m_accept_handler = std::move(h);
-		m_accept_into = &peer;
-		m_remote_endpoint = nullptr;
-
-		check_accept_queue();
-	}
-
-	void tcp::acceptor::async_accept(ip::tcp::socket& peer
-		, ip::tcp::endpoint& peer_endpoint
-		, aux::function<void(boost::system::error_code const&)> h)
-	{
-		if (peer.is_open())
-		{
-			boost::system::error_code ec;
-			peer.close(ec);
-		}
-
-		if (m_accept_handler)
-		{
-			post(m_io_service, bind_handler(std::exchange(m_accept_handler, nullptr)
-				, boost::system::error_code(error::operation_aborted)));
-		}
-		if (m_accept_handler2)
-		{
-			post(m_io_service, [&, h = std::exchange(m_accept_handler2, nullptr)] () mutable {
-				h(boost::system::error_code(error::operation_aborted)
-					, ip::tcp::socket(m_io_service));
-			});
-		}
-		m_accept_handler = std::move(h);
-		m_accept_into = &peer;
-		m_remote_endpoint = &peer_endpoint;
-
-		check_accept_queue();
-	}
-
-	void tcp::acceptor::async_accept(aux::function<void(boost::system::error_code const&, ip::tcp::socket peer)> h)
-	{
-		m_remote_endpoint = nullptr;
-		if (m_accept_handler)
-		{
-			m_accept_into = nullptr;
-			post(m_io_service, bind_handler(std::exchange(m_accept_handler, nullptr)
-				, boost::system::error_code(error::operation_aborted)));
-		}
-		if (m_accept_handler2)
-		{
-			m_accept_into = nullptr;
-			post(m_io_service, [&, h = std::exchange(m_accept_handler2, nullptr)] () mutable {
-				h(boost::system::error_code(error::operation_aborted)
-					, ip::tcp::socket(m_io_service));
-			});
-		}
-		m_new_socket.emplace(m_io_service);
-		m_accept_handler2 = std::move(h);
-		m_accept_into = &*m_new_socket;
-
-		check_accept_queue();
-	}
-
-	void tcp::acceptor::do_check_accept_queue(boost::system::error_code const& ec)
-	{
-		if (ec) return;
-		check_accept_queue();
-	}
-
-	void tcp::acceptor::incoming_packet(aux::packet p)
-	{
-		switch (p.type)
-		{
-			case aux::packet::type_t::syn:
-				m_incoming_conns.push_back(p.channel);
-				check_accept_queue();
-				return;
-			case aux::packet::type_t::error:
-				assert(false); // something is not wired up correctly
-				if (m_accept_handler)
-				{
-					m_accept_into = nullptr;
-					m_remote_endpoint = nullptr;
-					post(m_io_service, bind_handler(std::exchange(m_accept_handler, nullptr)
-						, boost::system::error_code(error::operation_aborted)));
-				}
-				if (m_accept_handler2)
-				{
-					m_accept_into = nullptr;
-					m_remote_endpoint = nullptr;
-					post(m_io_service, [&, h = std::exchange(m_accept_handler2, nullptr)] () mutable {
-						h(boost::system::error_code(error::operation_aborted)
-							, ip::tcp::socket(m_io_service));
-					});
-				}
-				return;
-			default:
-				// if this happens, it implies that an incoming connection sent
-				// payload before receiving a syn_ack. Alternatively that the
-				// acceptor sent the syn_ack but still left the last-hop in the
-				// incoming route to point to this socket, instead of the
-				// accepted-into socket
-				assert(false);
-				return;
-		}
-	}
-
-	void tcp::acceptor::check_accept_queue()
-	{
-		if (!is_open())
-		{
-			// if the acceptor socket is closed. Any potential socket in the queue
-			// should be closed too.
-			for (auto const& incoming : m_incoming_conns)
-			{
-				aux::packet p;
-				p.from = asio::ip::udp::endpoint(
-					m_bound_to.address(), m_bound_to.port());
-				p.type = aux::packet::type_t::error;
-				p.ec = boost::system::error_code(error::connection_reset);
-				p.overhead = 28;
-				p.hops = incoming->hops[0];
-
-				forward_packet(std::move(p));
-			}
-			m_incoming_conns.clear();
-
-			if (m_accept_handler)
-			{
-				m_accept_into = nullptr;
-				m_remote_endpoint = nullptr;
-				post(m_io_service, bind_handler(std::exchange(m_accept_handler, nullptr)
-					, boost::system::error_code(error::operation_aborted)));
-			}
-			if (m_accept_handler2)
-			{
-				m_accept_into = nullptr;
-				m_remote_endpoint = nullptr;
-				post(m_io_service, [&, h = std::exchange(m_accept_handler2, nullptr)] () mutable {
-					h(boost::system::error_code(error::operation_aborted)
-						, ip::tcp::socket(m_io_service));
-				});
-			}
-		}
-
-		// if the user is not waiting for an incoming connection, there's no point
-		// in checking the queue
-		if (!m_accept_handler && !m_accept_handler2) return;
-
-		if (m_incoming_conns.empty()) return;
-
-		std::shared_ptr<aux::channel> c = std::move(m_incoming_conns.front());
-		m_incoming_conns.erase(m_incoming_conns.begin());
-
-		// this was initiated at least one 3-way handshake ago.
-		// we can pick it up and consider it connected
-		if (m_remote_endpoint) *m_remote_endpoint = c->ep[0];
-		m_remote_endpoint = nullptr;
-
-		boost::system::error_code ec;
-		// if the acceptor socket is closed. Any potential socket in the queue
-		m_accept_into->internal_connect(m_bound_to, c, ec);
-
-		// notify the other end
-		aux::packet p;
-		p.from = asio::ip::udp::endpoint(m_bound_to.address(), m_bound_to.port());
-		if (ec)
-		{
-			c->hops[1] = route();
-			p.type = aux::packet::type_t::error;
-			p.ec = ec;
-		}
-		else
-		{
-		// TODO: extend pcap logging to include SYN+ACK packets
-			p.type = aux::packet::type_t::syn_ack;
-		}
-		p.channel = c;
-		p.overhead = 28;
-		p.hops = p.channel->hops[0];
-
-		forward_packet(std::move(p));
-
-		try
-		{
-			if (m_accept_handler)
-			{
-				post(m_io_service, bind_handler(std::exchange(m_accept_handler, nullptr), ec));
-			}
-			else if (m_accept_handler2)
-			{
-				post(m_io_service, bind_handler(std::exchange(m_accept_handler2, nullptr)
-					, ec, std::move(*m_accept_into)));
-			}
-		}
-		catch (...)
-		{
-			m_new_socket.reset();
-			m_accept_into = nullptr;
-			throw;
-		}
-		m_new_socket.reset();
-		m_accept_into = nullptr;
-	}
-
-	bool tcp::acceptor::internal_is_listening()
-	{
-		return m_queue_size_limit > 0;
-	}
-}
-}
-}
-
diff -Naupr a/simulation/libsimulator/src/default_config.cpp b/simulation/libsimulator/src/default_config.cpp
--- a/simulation/libsimulator/src/default_config.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/default_config.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/queue.hpp"
-#include <memory>
-
-typedef sim::chrono::high_resolution_clock::time_point time_point;
-typedef sim::chrono::high_resolution_clock::duration duration;
-using sim::asio::ip::address_v4;
-using sim::asio::ip::address_v6;
-using sim::asio::ip::address;
-using sim::chrono::milliseconds;
-using sim::chrono::duration_cast;
-
-namespace sim {
-
-	void default_config::build(simulation& sim)
-	{
-		// 0 bandwidth and 0 queue means infinite. The network itself only adds
-		// 50 ms latency
-		m_network = std::make_shared<queue>(std::ref(sim.get_io_context())
-			, 0, duration_cast<duration>(milliseconds(30)), 0, "network");
-		m_sim = &sim;
-	}
-
-	void default_config::clear()
-	{
-		m_network.reset();
-		m_outgoing.clear();
-		m_incoming.clear();
-	}
-
-	route default_config::channel_route(
-		asio::ip::address /* src */
-		, asio::ip::address /* dst */)
-	{
-		return route().append(m_network);
-	}
-
-	route default_config::incoming_route(asio::ip::address ip)
-	{
-		// incoming download rate is 800kB/s with a 200 kB queue
-		// and 1 ms forwarding delay
-		auto it = m_incoming.find(ip);
-		if (it != m_incoming.end()) return route().append(it->second);
-		it = m_incoming.insert(it, std::make_pair(ip, std::make_shared<queue>(
-			std::ref(m_sim->get_io_context()), 800 * 1000
-			, duration_cast<duration>(milliseconds(1)), 200 * 1000, "DSL modem in")));
-		return route().append(it->second);
-	}
-
-	int default_config::path_mtu(
-		asio::ip::address /* ip1 */
-		, asio::ip::address /* ip2 */)
-	{
-		return 1475;
-	}
-
-	// return the hops an outgoing packet from ep need to traverse before
-	// reaching the network (for instance a DSL modem)
-	route default_config::outgoing_route(asio::ip::address ip)
-	{
-		// outgoing upload rate is 200kB/s with a 200 kB queue
-		// and 1 ms forwarding delay
-		auto it = m_outgoing.find(ip);
-		if (it != m_outgoing.end()) return route().append(it->second);
-		it = m_outgoing.insert(it, std::make_pair(ip, std::make_shared<queue>(
-			std::ref(m_sim->get_io_context()), 200 * 1000
-			, duration_cast<duration>(milliseconds(1)), 200 * 1000, "DSL modem out")));
-		return route().append(it->second);
-	}
-
-	duration default_config::hostname_lookup(
-		asio::ip::address const& /* requestor */
-		, std::string hostname
-		, std::vector<asio::ip::address>& result
-		, boost::system::error_code& ec)
-	{
-		if (hostname == "localhost")
-		{
-			result = { asio::ip::make_address_v6("::1")
-				, asio::ip::make_address_v4("127.0.0.1") };
-			return duration_cast<duration>(chrono::microseconds(1));
-		}
-
-		ec = boost::system::error_code(asio::error::host_not_found);
-		return duration_cast<duration>(chrono::milliseconds(100));
-	}
-}
-
diff -Naupr a/simulation/libsimulator/src/high_resolution_clock.cpp b/simulation/libsimulator/src/high_resolution_clock.cpp
--- a/simulation/libsimulator/src/high_resolution_clock.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/high_resolution_clock.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-
-#include <functional>
-
-#include "simulator/push_warnings.hpp"
-#include <boost/system/error_code.hpp>
-#include "simulator/pop_warnings.hpp"
-
-namespace sim { namespace chrono {
-	namespace {
-
-		// this is the global simulation timer
-		high_resolution_clock::time_point g_simulation_time;
-	}
-
-	high_resolution_clock::time_point high_resolution_clock::now()
-	{
-		return g_simulation_time;
-	}
-
-	void high_resolution_clock::fast_forward(high_resolution_clock::duration d)
-	{
-		g_simulation_time += d;
-	}
-
-	void reset_clock()
-	{
-		g_simulation_time = high_resolution_clock::time_point{};
-	}
-
-} // chrono
-} // sim
-
diff -Naupr a/simulation/libsimulator/src/high_resolution_timer.cpp b/simulation/libsimulator/src/high_resolution_timer.cpp
--- a/simulation/libsimulator/src/high_resolution_timer.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/high_resolution_timer.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/handler_allocator.hpp"
-
-#include <functional>
-#include <boost/system/error_code.hpp>
-
-namespace sim
-{
-
-	namespace asio {
-
-	high_resolution_timer::high_resolution_timer(io_context& ioc)
-		: m_expiration_time(time_type())
-		, m_io_service(&ioc)
-		, m_expired(true)
-	{
-	}
-
-	high_resolution_timer::high_resolution_timer(io_context& ioc,
-		const time_type& expiry_time)
-		: m_expiration_time(time_type())
-		, m_io_service(&ioc)
-		, m_expired(true)
-	{
-		expires_at(expiry_time);
-	}
-
-	high_resolution_timer::high_resolution_timer(io_context& ioc,
-		const duration_type& expiry_time)
-		: m_expiration_time(time_type())
-		, m_io_service(&ioc)
-		, m_expired(true)
-	{
-		expires_after(expiry_time);
-	}
-
-	high_resolution_timer::~high_resolution_timer()
-	{
-		cancel();
-	}
-
-	std::size_t high_resolution_timer::cancel()
-	{
-		if (m_expired) return 0;
-		m_expired = true;
-		m_io_service->remove_timer(this);
-		if (!m_handler) return 0;
-		fire(boost::asio::error::operation_aborted);
-		return 1;
-	}
-
-	std::size_t high_resolution_timer::cancel_one()
-	{
-		// TODO: support multiple handlers
-		return cancel();
-	}
-
-	high_resolution_timer::time_type high_resolution_timer::expiry() const
-	{ return m_expiration_time; }
-
-	std::size_t high_resolution_timer::expires_at(high_resolution_timer::time_type const& expiry_time)
-	{
-		std::size_t ret = cancel();
-		m_expiration_time = expiry_time;
-		m_expired = false;
-		m_io_service->add_timer(this);
-		return ret;
-	}
-
-	std::size_t high_resolution_timer::expires_after(const duration_type& expiry_time)
-	{
-		std::size_t ret = cancel();
-		m_expiration_time = chrono::high_resolution_clock::now() + expiry_time;
-		m_expired = false;
-		m_io_service->add_timer(this);
-		return ret;
-	}
-
-	void high_resolution_timer::wait()
-	{
-		assert(false && "can't use synchcronous calls in simulator");
-		boost::system::error_code ec;
-		wait(ec);
-	}
-
-	void high_resolution_timer::wait(boost::system::error_code&)
-	{
-		assert(false && "can't use synchcronous calls in simulator");
-		time_type now = chrono::high_resolution_clock::now();
-		if (now >= m_expiration_time) return;
-		chrono::high_resolution_clock::fast_forward(m_expiration_time - now);
-	}
-
-	void high_resolution_timer::async_wait(aux::function<void(boost::system::error_code const&)> handler)
-	{
-		// TODO: support multiple handlers
-		assert(!m_handler);
-		m_handler = std::move(handler);
-		if (m_expired)
-		{
-			fire(boost::system::error_code());
-			return;
-		}
-	}
-
-	void high_resolution_timer::fire(boost::system::error_code ec)
-	{
-		m_expired = true;
-		if (!m_handler) return;
-		auto h = std::move(m_handler);
-		m_handler = nullptr;
-		post(*m_io_service, make_malloc(std::bind(std::move(h), ec)));
-	}
-
-	high_resolution_timer::executor_type high_resolution_timer::get_executor()
-	{
-		return (*m_io_service).get_executor();
-	}
-
-	} // asio
-
-} // sim
-
diff -Naupr a/simulation/libsimulator/src/http_proxy.cpp b/simulation/libsimulator/src/http_proxy.cpp
--- a/simulation/libsimulator/src/http_proxy.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/http_proxy.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,362 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/http_proxy.hpp"
-#include "simulator/http_server.hpp" // for helper functions
-
-#include <functional>
-#include <cstdio> // for printf
-
-using namespace sim::asio;
-using namespace sim::asio::ip;
-using namespace std::placeholders;
-
-using boost::system::error_code;
-
-namespace sim
-{
-	using namespace aux;
-
-	http_proxy::http_proxy(io_context& ios, unsigned short const listen_port)
-		: m_resolver(ios)
-		, m_listen_socket(ios)
-		, m_client_connection(ios)
-		, m_server_connection(ios)
-		, m_writing_to_server(false)
-		, m_num_client_in_bytes(0)
-		, m_num_server_out_bytes(0)
-		, m_num_in_bytes(0)
-		, m_close(false)
-	{
-		address local_ip = ios.get_ips().front();
-		if (local_ip.is_v4())
-		{
-			m_listen_socket.open(tcp::v4());
-			m_listen_socket.bind(tcp::endpoint(address_v4::any(), listen_port));
-		}
-		else
-		{
-			m_listen_socket.open(tcp::v6());
-			m_listen_socket.bind(tcp::endpoint(address_v6::any(), listen_port));
-		}
-		m_listen_socket.listen();
-
-		m_listen_socket.async_accept(m_client_connection, m_ep
-			, std::bind(&http_proxy::on_accept, this, _1));
-	}
-
-	void http_proxy::on_accept(error_code const& ec)
-	{
-		if (ec == asio::error::operation_aborted)
-			return;
-
-		if (ec)
-		{
-			std::printf("http_proxy::on_accept: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		std::printf("http_proxy accepted connection from: %s : %d\n",
-			m_ep.address().to_string().c_str(), m_ep.port());
-
-		// read http request
-		m_client_connection.async_read_some(asio::buffer(
-			&m_client_in_buffer[0], sizeof(m_client_in_buffer))
-			, std::bind(&http_proxy::on_read_request, this, _1, _2));
-	}
-
-	void http_proxy::on_read_request(error_code const& ec, size_t bytes_transferred) try
-	{
-		if (ec)
-		{
-			std::printf("http_proxy::on_read_request: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		m_num_client_in_bytes += int(bytes_transferred);
-
-		// scan for end of HTTP request
-		int req_len = find_request_len(m_client_in_buffer, m_num_client_in_bytes);
-		while (req_len >= 0)
-		{
-			// parse request from [0, eor), connect to target server and forward
-			// the request.
-			http_request const req = parse_request(m_client_in_buffer, req_len);
-			forward_request(req);
-
-			// pop this request from the receive buffer
-			memmove(m_client_in_buffer, m_client_in_buffer + req_len
-				, m_num_client_in_bytes - req_len);
-			m_num_client_in_bytes -= req_len;
-
-			// is there another request in the buffer?
-			req_len = find_request_len(m_client_in_buffer, m_num_client_in_bytes);
-		}
-
-		// read more from the client
-		m_client_connection.async_read_some(asio::buffer(
-			&m_client_in_buffer[m_num_client_in_bytes]
-			, sizeof(m_client_in_buffer) - m_num_client_in_bytes)
-			, std::bind(&http_proxy::on_read_request, this, _1, _2));
-	}
-	catch (std::runtime_error& e)
-	{
-		std::printf("http_proxy::on_read_request() failed: %s\n"
-			, e.what());
-		close_connection();
-	}
-
-	void http_proxy::forward_request(http_request const& req)
-	{
-		std::string out_request;
-		out_request = req.method;
-		out_request += ' ';
-		if (req.req.compare(0, 7, "http://") != 0)
-		{
-			std::printf("http_proxy::forward_request: expected full URL in request, got: %s\n"
-				, req.req.c_str());
-			throw std::runtime_error("invalid request");
-		}
-
-		std::string::size_type const path_start = req.req.find_first_of('/', 7);
-		if (path_start == std::string::npos) out_request += '/';
-		else out_request.append(req.req, path_start, std::string::npos);
-		out_request += " HTTP/1.1\r\n";
-
-		std::string::size_type const host_end = req.req.substr(0, path_start).find_last_of(':');
-
-		std::string host = req.req.substr(7, (host_end != std::string::npos && host_end > 7)
-			? host_end - 7 : path_start - 7);
-
-		// if the hostname is an IPv6 address, strip the brackets around it to
-		// make it parse correctly
-		if (host.size() >= 2 && host.front() == '[' && host.back() == ']')
-			host = host.substr(1, host.size() - 2);
-
-		int const port = host_end == std::string::npos || host_end <= 7 ? 80
-			: atoi(req.req.substr(host_end + 1, path_start).c_str());
-		assert(port >= 0 && port < 0xffff);
-
-		bool found_host = false;
-		for (auto const& h : req.headers)
-		{
-			if (h.first == "host") found_host = true;
-
-			out_request += h.first;
-			out_request += ": ";
-			out_request += h.second;
-			out_request += "\r\n";
-		}
-		if (!found_host)
-		{
-			out_request += "host: ";
-			out_request += host;
-			out_request += "\r\n";
-		}
-		out_request += "\r\n";
-
-		if (m_num_server_out_bytes + out_request.size() > sizeof(m_server_out_buffer))
-		{
-			std::printf("http_proxy: Too many queued server requests: %d bytes\n"
-				, int(m_num_server_out_bytes + out_request.size()));
-			throw std::runtime_error("pipeline too deep");
-		}
-		memmove(&m_server_out_buffer[m_num_server_out_bytes]
-			, out_request.data(), out_request.size());
-		m_num_server_out_bytes += int(out_request.size());
-
-		if (!m_server_connection.is_open())
-		{
-			boost::system::error_code err;
-			tcp::endpoint target(make_address(host.c_str(), err)
-				, static_cast<unsigned short>(port));
-			if (err)
-			{
-				char port_str[10];
-				std::snprintf(port_str, sizeof(port_str), "%d", port);
-				m_resolver.async_resolve(host, port_str
-					, std::bind(&http_proxy::on_domain_lookup, this, _1, _2));
-				return;
-			}
-			open_forward_connection(target);
-			return;
-		}
-
-		// TODO: make sure we're connecting/connected to the same (host, port)
-		// that this request is for. Don't support multiple servers
-
-		write_server_send_buffer();
-	}
-
-	void http_proxy::on_domain_lookup(boost::system::error_code const& ec
-		, const asio::ip::tcp::resolver::results_type ips)
-	{
-		if (ec || ips.empty())
-		{
-			if (ec)
-			{
-				std::printf("http_proxy::on_domain_lookup: (%d) %s\n"
-					, ec.value(), ec.message().c_str());
-			}
-			else
-			{
-				std::printf("http_proxy::on_request_domain_lookup: empty response\n");
-			}
-			error(503, "Resource Temporarily Unavailable");
-			return;
-		}
-		open_forward_connection(ips.front().endpoint());
-	}
-
-	void http_proxy::open_forward_connection(const asio::ip::tcp::endpoint& target)
-	{
-		m_server_connection.open(target.protocol());
-
-		std::printf("http_proxy: async_connect: %s:%d\n"
-			, target.address().to_string().c_str(), target.port());
-		m_server_connection.async_connect(target
-			, std::bind(&http_proxy::on_connected, this, _1));
-	}
-
-	void http_proxy::error(int code, char const* message)
-	{
-		std::string send_buffer = send_response(code, message);
-		memcpy(m_in_buffer, send_buffer.data(), send_buffer.size());
-		asio::async_write(m_client_connection, asio::buffer(
-			&m_in_buffer[0], send_buffer.size())
-			, std::bind(&http_proxy::close_connection, this));
-	}
-
-	void http_proxy::on_connected(boost::system::error_code const& ec)
-	{
-		if (ec)
-		{
-			std::printf("http_proxy::on_connected() connection failed: %s\n", ec.message().c_str());
-			m_server_connection.close();
-			error(503, "Service Temporarily Unavailable");
-			return;
-		}
-
-		std::printf("http_proxy: connected\n");
-
-		write_server_send_buffer();
-
-		m_server_connection.async_read_some(
-			asio::buffer(m_in_buffer, sizeof(m_in_buffer))
-			, std::bind(&http_proxy::on_server_receive, this, _1, _2));
-	}
-
-	void http_proxy::write_server_send_buffer()
-	{
-		if (m_writing_to_server) return;
-		m_writing_to_server = true;
-		m_server_connection.async_write_some(asio::buffer(
-			&m_server_out_buffer[0], m_num_server_out_bytes)
-			, std::bind(&http_proxy::on_server_write, this, _1, _2));
-	}
-
-	void http_proxy::on_server_write(error_code const& ec, size_t bytes_transferred)
-	{
-		m_writing_to_server = false;
-		if (ec)
-		{
-			std::printf("http_proxy::on_server_write: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		memmove(&m_server_out_buffer[0], &m_server_out_buffer[bytes_transferred]
-			, m_num_server_out_bytes - bytes_transferred);
-		m_num_server_out_bytes -= int(bytes_transferred);
-
-		if (m_num_server_out_bytes > 0)
-			write_server_send_buffer();
-	}
-
-	// we received some data from the server, forward it to the server
-	void http_proxy::on_server_receive(boost::system::error_code const& ec
-		, std::size_t bytes_transferred)
-	{
-		if (ec)
-		{
-			std::printf("http_proxy: error reading from server: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		asio::async_write(m_client_connection, asio::buffer(&m_in_buffer[0], bytes_transferred)
-			, std::bind(&http_proxy::on_server_forward, this, _1, _2));
-	}
-
-	void http_proxy::on_server_forward(error_code const& ec
-		, size_t)
-	{
-		if (ec)
-		{
-			std::printf("http_proxy: error writing to client: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		m_server_connection.async_read_some(
-			sim::asio::buffer(m_in_buffer, sizeof(m_in_buffer))
-			, std::bind(&http_proxy::on_server_receive, this, _1, _2));
-	}
-
-	void http_proxy::stop()
-	{
-		m_close = true;
-		m_listen_socket.close();
-	}
-
-	void http_proxy::close_connection()
-	{
-		m_num_client_in_bytes = 0;
-		m_num_server_out_bytes = 0;
-		m_num_in_bytes = 0;
-
-		error_code err;
-		m_client_connection.close(err);
-		if (err)
-		{
-			std::printf("http_proxy::close: failed to close client connection (%d) %s\n"
-				, err.value(), err.message().c_str());
-		}
-		m_server_connection.close(err);
-		if (err)
-		{
-			std::printf("http_proxy::close: failed to close server connection (%d) %s\n"
-				, err.value(), err.message().c_str());
-		}
-
-		if (m_close) return;
-
-		// now we can accept another connection
-		m_listen_socket.async_accept(m_client_connection, m_ep
-			, std::bind(&http_proxy::on_accept, this, _1));
-	}
-}
-
diff -Naupr a/simulation/libsimulator/src/http_server.cpp b/simulation/libsimulator/src/http_server.cpp
--- a/simulation/libsimulator/src/http_server.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/http_server.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,393 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/http_server.hpp"
-
-#include <functional>
-#include <cstdio> // for printf
-
-using namespace sim::asio;
-using namespace sim::asio::ip;
-using namespace std::placeholders;
-
-using boost::system::error_code;
-
-namespace sim
-{
-	using namespace aux;
-
-	namespace {
-		char const* find(char const* hay, int const hsize
-			, char const* needle, int const nsize)
-		{
-			for (int i = 0; i < hsize - nsize + 1; ++i)
-			{
-				if (memcmp(hay + i, needle, nsize) == 0) return hay + i;
-			}
-			return nullptr;
-		}
-	}
-
-	std::string trim(std::string s)
-	{
-		if (s.empty()) return s;
-
-		int start = 0;
-		int end = int(s.size());
-		while (strchr(" \r\n\t", s[start]) != NULL && start < end)
-		{
-			++start;
-		}
-
-		while (strchr(" \r\n\t", s[end-1]) != NULL && end > start)
-		{
-			--end;
-		}
-		return s.substr(start, end - start);
-	}
-
-	std::string lower_case(std::string s)
-	{
-		std::string ret;
-		std::transform(s.begin(), s.end(), std::back_inserter(ret)
-			, [](char c) { return static_cast<char>(tolower(c)); } );
-		return ret;
-	}
-
-	std::string normalize(const std::string& s)
-	{
-		std::vector<std::string> elements;
-		char const* start = s.c_str();
-		if (*start == '/') ++start;
-		char const* slash = strchr(start, '/');
-		while (slash != NULL)
-		{
-			std::string element(start, slash - start);
-			if (element != "..")
-			{
-				elements.push_back(element);
-			} else if (!elements.empty())
-			{
-				elements.erase(elements.end()-1);
-			}
-			start = slash + 1;
-			slash = strchr(start, '/');
-		}
-		elements.push_back(start);
-
-		std::string ret;
-		for (auto const& e : elements)
-		{
-			ret += '/';
-			ret += e;
-		}
-
-		return ret;
-	}
-
-	// TODO: extra_header should be a std::vector
-	std::string send_response(int code, char const* status_message
-		, int len, char const** extra_header)
-	{
-		std::string ret = "HTTP/1.1 " + std::to_string(code) + " " + status_message + "\r\n";
-
-		ret += "content-length: " + std::to_string(len) + "\r\n";
-
-		if (extra_header)
-		{
-			ret += extra_header[0];
-			ret += extra_header[1];
-			ret += extra_header[2];
-			ret += extra_header[3];
-		}
-		ret += "\r\n";
-
-		return ret;
-	}
-
-	http_server::http_server(io_context& ios, unsigned short listen_port, int flags)
-		: m_ios(ios)
-		, m_listen_socket(ios)
-		, m_connection(ios)
-		, m_bytes_used(0)
-		, m_close(false)
-		, m_flags(flags)
-	{
-		address local_ip = ios.get_ips().front();
-		if (local_ip.is_v4())
-		{
-			m_listen_socket.open(tcp::v4());
-			m_listen_socket.bind(tcp::endpoint(address_v4::any(), listen_port));
-		}
-		else
-		{
-			m_listen_socket.open(tcp::v6());
-			m_listen_socket.bind(tcp::endpoint(address_v6::any(), listen_port));
-		}
-		m_listen_socket.listen();
-
-		m_listen_socket.async_accept(m_connection, m_ep
-			, std::bind(&http_server::on_accept, this, _1));
-	}
-
-	void http_server::on_accept(error_code const& ec)
-	{
-		if (ec)
-		{
-			std::printf("http_server::on_accept: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		std::printf("http_server accepted connection from: %s : %d\n",
-			m_ep.address().to_string().c_str(), m_ep.port());
-
-		read();
-	}
-
-	void http_server::register_handler(std::string const& path, handler_t h)
-	{
-		m_handlers[path] = std::move(h);
-	}
-
-	void http_server::register_content(std::string const& path
-		, std::int64_t const size, generator_t gen)
-	{
-		m_handlers[path] = [gen,size](std::string, std::string, std::map<std::string, std::string>& hdr)
-		{
-			std::int64_t start = 0;
-			std::int64_t end = size;
-
-			auto it = hdr.find("range");
-			bool const range_req = it != hdr.end();
-			if (range_req)
-			{
-				std::string range = it->second;
-				// skip "bytes "
-				range = range.substr(range.find_first_of('=') + 1);
-				start = std::stoll(range.substr(0, range.find('-')));
-				end = std::stoll(range.substr(range.find_first_of('-') + 1)) + 1;
-			}
-
-			std::string header = "Content-Range: bytes " + std::to_string(start)
-				+ "-" + std::to_string(end-1) + "/" + std::to_string(end-start) + "\r\n";
-			char const* extra_headers[4] = { header.c_str(), "", "", ""};
-
-			return sim::send_response(range_req ? 206 : 200
-				, range_req ? "Partial Content" : "OK"
-				, int(end - start), range_req ? extra_headers : nullptr)
-				+ gen(start, end - start);
-		};
-	}
-
-	void http_server::register_redirect(std::string const& path, std::string const& target)
-	{
-		m_handlers[path] = [target](std::string, std::string, std::map<std::string, std::string>&)
-		{
-			std::string header = "Location: " + target + "\r\n";
-			char const* extra_headers[4] = { header.c_str(), "", "", ""};
-			return sim::send_response(301, "Moved Permanently", 0, extra_headers);
-		};
-	}
-
-	void http_server::register_stall_handler(std::string const& path){
-		m_stall_handlers.insert(path);
-	}
-
-	void http_server::read()
-	{
-		if (m_bytes_used >= int(m_recv_buffer.size()) / 2)
-		{
-			m_recv_buffer.resize((std::max)(500, m_bytes_used * 2));
-		}
-		assert(int(m_recv_buffer.size()) > m_bytes_used);
-		m_connection.async_read_some(asio::buffer(&m_recv_buffer[m_bytes_used]
-				, m_recv_buffer.size() - m_bytes_used)
-			, std::bind(&http_server::on_read, this, _1, _2));
-	}
-
-	http_request parse_request(char const* start, int len)
-	{
-		http_request ret;
-
-		char const* const end_of_request = start + len;
-		char const* const space = find(start, len, " ", 1);
-		if (space == nullptr)
-		{
-			std::printf("http_server: failed to parse request:\n%s\n"
-				, std::string(start, len).c_str());
-			throw std::runtime_error("parse failed");
-		}
-
-		char const* const space2 = find(space + 1
-			, int(len - (space - start + 1)), " ", 1);
-		if (space2 == nullptr)
-		{
-			std::printf("http_server: failed to parse request:\n%s\n"
-				, std::string(start, len).c_str());
-			throw std::runtime_error("parse failed");
-		}
-		ret.method.assign(start, space);
-		ret.req.assign(space+1, space2);
-		if (ret.method != "CONNECT") {
-			ret.path.assign(normalize(ret.req.substr(0, ret.req.find_first_of('?'))));
-		} else {
-			ret.path.assign(ret.req);
-		}
-		std::printf("parse_request: %s %s [%s]\n"
-			, ret.method.c_str(), ret.path.c_str(), ret.req.c_str());
-
-		char const* header = find(space2, int(len - (space2 - start)), "\r\n", 2);
-		while (header != end_of_request - 4)
-		{
-			if (header == nullptr)
-			{
-				std::printf("http_server: failed to parse request:\n%s\n"
-					, std::string(start, len).c_str());
-				throw std::runtime_error("parse failed");
-			}
-			char const* const next = find(header + 2
-				, int(len - (header + 2 - start)), "\r\n", 2);
-			char const* const value = static_cast<char const*>(memchr(header, ':', len - (header - start)));
-			if (value == nullptr || next == nullptr || value > next)
-			{
-				std::printf("http_server: failed to parse request:\n%s\n"
-					, std::string(start, len).c_str());
-				throw std::runtime_error("parse failed");
-			}
-
-			ret.headers[lower_case(trim(std::string(header, value)))]
-				= trim(std::string(value+1, next));
-
-			header = next;
-		}
-		return ret;
-	}
-
-	int find_request_len(char const* buf, int const len)
-	{
-		char const* end_of_request = find(buf, len, "\r\n\r\n", 4);
-		if (end_of_request == nullptr) return -1;
-		return int(end_of_request - buf + 4);
-	}
-
-	void http_server::on_read(error_code const& ec, size_t bytes_transferred) try
-	{
-		if (ec)
-		{
-			std::printf("http_server::on_read: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		m_bytes_used += int(bytes_transferred);
-
-		int const req_len = find_request_len(m_recv_buffer.data(), m_bytes_used);
-		if (req_len < 0)
-		{
-			read();
-			return;
-		}
-
-		http_request req = parse_request(m_recv_buffer.data(), req_len);
-
-		m_recv_buffer.erase(m_recv_buffer.begin(), m_recv_buffer.begin() + req_len);
-		m_bytes_used -= req_len;
-
-		auto it = m_handlers.find(req.path);
-		if (it == m_handlers.end())
-		{
-			if (m_stall_handlers.find(req.path) != m_stall_handlers.end())
-			{
-				return;
-			}
-			// no handler found, 404
-			m_send_buffer = send_response(404, "Not Found");
-		}
-		else
-		{
-			m_send_buffer = it->second(req.method, req.req, req.headers);
-		}
-
-		bool close = lower_case(req.headers["connection"]) == "close";
-
-		async_write(m_connection, asio::buffer(m_send_buffer.data()
-			, m_send_buffer.size()), std::bind(&http_server::on_write
-			, this, _1, _2, close));
-	}
-	catch (std::exception& e)
-	{
-		std::printf("http_server::on_read() failed: %s\n"
-			, e.what());
-		close_connection();
-	}
-
-	void http_server::on_write(error_code const& ec
-		, size_t /* bytes_transferred */
-		, bool close)
-	{
-		if (ec)
-		{
-			std::printf("http_server::on_write: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		if (!close && (m_flags & keep_alive))
-		{
-			// try to read another request out of the buffer
-			post(m_ios, std::bind(&http_server::on_read, this, error_code(), 0));
-		}
-		else
-		{
-			close_connection();
-		}
-	}
-
-	void http_server::stop()
-	{
-		m_close = true;
-		m_listen_socket.close();
-	}
-
-	void http_server::close_connection()
-	{
-		m_recv_buffer.clear();
-		m_bytes_used = 0;
-
-		error_code err;
-		m_connection.close(err);
-		if (err)
-		{
-			std::printf("http_server::close: failed to close connection (%d) %s\n"
-				, err.value(), err.message().c_str());
-			return;
-		}
-
-		if (m_close) return;
-
-		// now we can accept another connection
-		m_listen_socket.async_accept(m_connection, m_ep
-			, std::bind(&http_server::on_accept, this, _1));
-	}
-}
-
diff -Naupr a/simulation/libsimulator/src/io_service.cpp b/simulation/libsimulator/src/io_service.cpp
--- a/simulation/libsimulator/src/io_service.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/io_service.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,257 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-
-#include <boost/make_shared.hpp>
-#include <boost/system/error_code.hpp>
-
-namespace sim { namespace asio {
-
-	io_context::io_context(sim::simulation& sim)
-		: io_context(sim, std::vector<asio::ip::address>())
-	{}
-
-	io_context::io_context(sim::simulation& sim, asio::ip::address const& ip)
-		: io_context(sim, std::vector<asio::ip::address>{ip})
-	{}
-
-	io_context::io_context(sim::simulation& sim, std::vector<asio::ip::address> const& ips)
-		: m_sim(sim)
-		, m_ips(ips)
-		, m_stopped(false)
-	{
-		for (auto const& ip : m_ips)
-		{
-			m_outgoing_route[ip] = m_sim.config().outgoing_route(ip);
-			m_incoming_route[ip] = m_sim.config().incoming_route(ip);
-		}
-		m_sim.add_io_service(this);
-	}
-
-	io_context::~io_context()
-	{
-		m_sim.remove_io_service(this);
-	}
-
-	io_context::io_context(std::size_t)
-		: m_sim(*reinterpret_cast<sim::simulation*>(0))
-	{
-		assert(false);
-	}
-
-	int io_context::get_path_mtu(const asio::ip::address& source, const asio::ip::address& dest) const
-	{
-		// TODO: it would be nice to actually traverse the virtual network nodes
-		// and ask for their MTU instead
-		assert(std::count(m_ips.begin(), m_ips.end(), source) > 0 && "source address must be a local address to this node/io_context");
-		return m_sim.config().path_mtu(source, dest);
-	}
-
-	void io_context::stop()
-	{
-		// TODO: cancel all outstanding handler associated with this io_context
-		m_stopped = true;
-	}
-
-	bool io_context::stopped() const
-	{
-		return m_stopped;
-	}
-
-	void io_context::restart()
-	{
-		m_stopped = false;
-	}
-
-	std::size_t io_context::run()
-	{
-		assert(false);
-		return 0;
-	}
-
-	std::size_t io_context::run(boost::system::error_code&)
-	{
-		assert(false);
-		return 0;
-	}
-
-	std::size_t io_context::poll()
-	{
-		assert(false);
-		return 0;
-	}
-
-	std::size_t io_context::poll(boost::system::error_code&)
-	{
-		assert(false);
-		return 0;
-	}
-
-	std::size_t io_context::poll_one()
-	{
-		assert(false);
-		return 0;
-	}
-
-	std::size_t io_context::poll_one(boost::system::error_code&)
-	{
-		assert(false);
-		return 0;
-	}
-
-	// private interface
-
-	void io_context::add_timer(high_resolution_timer* t)
-	{
-		m_sim.add_timer(t);
-	}
-
-	void io_context::remove_timer(high_resolution_timer* t)
-	{
-		m_sim.remove_timer(t);
-	}
-
-	boost::asio::io_context& io_context::get_internal_service()
-	{ return m_sim.get_internal_service(); }
-
-	ip::tcp::endpoint io_context::bind_socket(ip::tcp::socket* socket
-		, ip::tcp::endpoint ep, boost::system::error_code& ec)
-	{
-		assert(!m_ips.empty() && "you cannot use an internal io_context (one without an IP address) for creating and binding sockets");
-		if (ep.address() == ip::address_v4::any())
-		{
-			auto it = std::find_if(m_ips.begin(), m_ips.end()
-				, [](ip::address const& ip) { return ip.is_v4(); } );
-			if (it == m_ips.end())
-			{
-				ec.assign(boost::system::errc::address_not_available
-					, boost::system::generic_category());
-				return ip::tcp::endpoint();
-			}
-			// TODO: pick the first local endpoint for now. In the future we may
-			// want have a bias toward
-			ep.address(*it);
-		}
-		else if (ep.address() == ip::address_v6::any())
-		{
-			auto it = std::find_if(m_ips.begin(), m_ips.end()
-				, [](ip::address const& ip) { return ip.is_v6(); } );
-			if (it == m_ips.end())
-			{
-				ec.assign(boost::system::errc::address_not_available
-					, boost::system::generic_category());
-				return ip::tcp::endpoint();
-			}
-			// TODO: pick the first local endpoint for now. In the future we may
-			// want have a bias toward
-			ep.address(*it);
-		}
-		else if (std::count(m_ips.begin(), m_ips.end(), ep.address()) == 0)
-		{
-			// you can only bind to the IP assigned to this node.
-			// TODO: support loopback
-			ec.assign(boost::system::errc::address_not_available
-				, boost::system::generic_category());
-			return ip::tcp::endpoint();
-		}
-
-		return m_sim.bind_socket(socket, ep, ec);
-	}
-
-	void io_context::unbind_socket(ip::tcp::socket* socket
-		, const ip::tcp::endpoint& ep)
-	{
-		m_sim.unbind_socket(socket, ep);
-	}
-
-	void io_context::rebind_socket(asio::ip::tcp::socket* s, asio::ip::tcp::endpoint ep)
-	{
-		m_sim.rebind_socket(s, ep);
-	}
-
-	ip::udp::endpoint io_context::bind_udp_socket(ip::udp::socket* socket
-		, ip::udp::endpoint ep, boost::system::error_code& ec)
-	{
-		assert(!m_ips.empty() && "you cannot use an internal io_context (one without an IP address) for creating and binding sockets");
-		if (ep.address() == ip::address_v4::any())
-		{
-			auto it = std::find_if(m_ips.begin(), m_ips.end()
-				, [](ip::address const& ip) { return ip.is_v4(); });
-			if (it == m_ips.end())
-			{
-				ec.assign(boost::system::errc::address_not_available
-					, boost::system::generic_category());
-				return ip::udp::endpoint();
-			}
-			// TODO: pick the first local endpoint for now. In the future we may
-			// want have a bias toward
-			ep.address(*it);
-		}
-		else if (ep.address() == ip::address_v6::any())
-		{
-			auto it = std::find_if(m_ips.begin(), m_ips.end()
-				, [](ip::address const& ip) { return ip.is_v6(); });
-			if (it == m_ips.end())
-			{
-				ec.assign(boost::system::errc::address_not_available
-						  , boost::system::generic_category());
-				return ip::udp::endpoint();
-			}
-			// TODO: pick the first local endpoint for now. In the future we may
-			// want have a bias toward
-			ep.address(*it);
-		}
-		else if (std::count(m_ips.begin(), m_ips.end(), ep.address()) == 0)
-		{
-			// you can only bind to the IP assigned to this node.
-			// TODO: support loopback
-			ec.assign(boost::system::errc::address_not_available
-				, boost::system::generic_category());
-			return ip::udp::endpoint();
-		}
-
-		return m_sim.bind_udp_socket(socket, ep, ec);
-	}
-
-	void io_context::unbind_udp_socket(ip::udp::socket* socket
-		, const ip::udp::endpoint& ep)
-	{
-		m_sim.unbind_udp_socket(socket, ep);
-	}
-
-	void io_context::rebind_udp_socket(asio::ip::udp::socket* socket, asio::ip::udp::endpoint ep)
-	{
-		m_sim.rebind_udp_socket(socket, ep);
-	}
-
-	std::shared_ptr<aux::channel> io_context::internal_connect(ip::tcp::socket* s
-		, ip::tcp::endpoint const& target, boost::system::error_code& ec)
-	{
-		return m_sim.internal_connect(s, target, ec);
-	}
-
-	route io_context::find_udp_socket(asio::ip::udp::socket const& socket
-		, ip::udp::endpoint const& ep)
-	{
-		return m_sim.find_udp_socket(socket, ep);
-	}
-
-} // asio
-} // sim
-
diff -Naupr a/simulation/libsimulator/src/pcap.cpp b/simulation/libsimulator/src/pcap.cpp
--- a/simulation/libsimulator/src/pcap.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/pcap.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,204 +0,0 @@
-/*
-
-Copyright (c) 2017, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/pcap.hpp"
-#include "simulator/chrono.hpp"
-#include "simulator/packet.hpp"
-
-using sim::chrono::duration_cast;
-using sim::chrono::seconds;
-
-using sim::asio::ip::address_v4;
-using sim::asio::ip::tcp;
-using sim::asio::ip::udp;
-
-namespace sim { namespace aux {
-
-namespace {
-
-	template <typename T, typename cond = typename std::enable_if<std::is_pod<T>::value>::type>
-	void write(std::fstream& o, T const& value)
-	{ o.write(reinterpret_cast<char const*>(&value), sizeof(value)); }
-
-	// documented here:
-	// http://www.tcpdump.org/linktypes.html
-	std::uint32_t const LINKTYPE_RAW = 101;
-
-	struct ip_header
-	{
-		std::uint8_t version_len;
-		std::uint8_t dscp;
-		std::uint16_t length;
-		std::uint16_t identification;
-		std::uint16_t fragment;
-		std::uint8_t ttl;
-		std::uint8_t protocol;
-		std::uint16_t checksum;
-		std::uint32_t source_ip;
-		std::uint32_t destination_ip;
-	};
-
-	struct udp_header
-	{
-		std::uint16_t src_port;
-		std::uint16_t dst_port;
-		std::uint16_t length;
-		std::uint16_t checksum;
-	};
-
-	struct tcp_header
-	{
-		std::uint16_t src_port;
-		std::uint16_t dst_port;
-		std::uint32_t seq_nr;
-		std::uint32_t ack_nr;
-		std::uint8_t offset;
-		std::uint8_t flags;
-		std::uint16_t window_size;
-		std::uint16_t checksum;
-		std::uint16_t urgent;
-	};
-}
-
-	pcap::pcap(char const* filename)
-		: m_file(filename, std::ios_base::out | std::ios_base::trunc | std::ios_base::binary)
-	{
-		// file format documented here:
-		// https://wiki.wireshark.org/Development/LibpcapFileFormat
-		// write pcap file header
-		write(m_file, std::uint32_t(0xa1b2c3d4)); // magic number
-		write(m_file, std::uint16_t(2)); // versopm major
-		write(m_file, std::uint16_t(4)); // versopm minor
-		write(m_file, std::int32_t(0)); // thiszone
-		write(m_file, std::uint32_t(0)); // sigfigs
-		write(m_file, std::uint32_t(0xffff)); // snaplen
-		write(m_file, LINKTYPE_RAW); // network
-	}
-
-	void write_ip_header(std::fstream& file, int const size, int const protocol
-		, address_v4 const source, address_v4 const dest)
-	{
-		ip_header const header = {
-			(4 << 4) | 5, // version_len
-			0, // dscp
-			htons(std::uint16_t(size)), // length
-			0, // identification
-			0, // fragment
-			200, // ttl
-			std::uint8_t(protocol), // protocol
-			0, // checksum
-			htonl(std::uint32_t(source.to_uint())), // source ip
-			htonl(std::uint32_t(dest.to_uint())) // destination ip
-		};
-
-		write(file, header);
-	}
-
-	void write_udp_header(std::fstream& file, int const size, int const src_port
-		, int const dst_port)
-	{
-		assert(src_port != 0);
-		assert(dst_port != 0);
-		udp_header const header = {
-			htons(std::uint16_t(src_port)), // source port
-			htons(std::uint16_t(dst_port)), // destination port
-			htons(std::uint16_t(sizeof(udp_header) + size)), // length
-			0 // checksum
-		};
-
-		write(file, header);
-	}
-
-	void write_tcp_header(std::fstream& file, int const src_port
-		, int const dst_port, std::uint32_t const seq_nr)
-	{
-		assert(src_port != 0);
-		assert(dst_port != 0);
-		tcp_header const header = {
-			htons(std::uint16_t(src_port)), // source port
-			htons(std::uint16_t(dst_port)), // destination port
-			htonl(seq_nr), // sequence number
-			std::uint32_t(0), // acknowledgement number
-			std::uint8_t(5 << 4), // header size (data offset)
-			std::uint8_t(0), // flags
-			htons(std::uint16_t(65535)), // window size
-			std::uint16_t(0), // checksum
-			std::uint16_t(0) // urgent offset
-		};
-
-		write(file, header);
-	}
-
-	void pcap::log_tcp(packet const& p, tcp::endpoint const src
-		, tcp::endpoint const dst)
-	{
-		// synthesize IP/TCP header and write packet
-		auto const now = chrono::high_resolution_clock::now();
-
-		// just an arbitrary posix time used as starting point
-		std::uint32_t const sim_start_time = 441794304;
-		std::uint32_t const secs = static_cast<std::uint32_t>(duration_cast<chrono::seconds>(now.time_since_epoch()).count());
-		std::uint32_t const usecs = static_cast<std::uint32_t>(duration_cast<chrono::microseconds>(now.time_since_epoch() - seconds(secs)).count());
-
-		std::uint32_t const packet_size = static_cast<std::uint32_t>(sizeof(ip_header) + sizeof(tcp_header) + p.buffer.size());
-
-		write(m_file, sim_start_time + secs);
-		write(m_file, usecs);
-		write(m_file, packet_size);
-		write(m_file, packet_size);
-
-		// 6 is the protocol number for TCP
-		write_ip_header(m_file, packet_size, 6
-			, src.address().to_v4(), dst.address().to_v4());
-
-		// TODO: if the packet has error set with asio::error::eof
-		// set the FIN flag
-		write_tcp_header(m_file, p.from.port(), dst.port(), p.byte_counter);
-
-		m_file.write(reinterpret_cast<char const*>(p.buffer.data()), p.buffer.size());
-	}
-
-	void pcap::log_udp(packet const& p, udp::endpoint const src
-		, udp::endpoint const dst)
-	{
-		// synthesize IP/UDP header and write packet
-		auto const now = chrono::high_resolution_clock::now();
-
-		// just an arbitrary posix time used as starting point
-		std::uint32_t const sim_start_time = 441794304;
-		std::uint32_t const secs = static_cast<std::uint32_t>(duration_cast<chrono::seconds>(now.time_since_epoch()).count());
-		std::uint32_t const usecs = static_cast<std::uint32_t>(duration_cast<chrono::microseconds>(now.time_since_epoch() - seconds(secs)).count());
-
-		std::uint32_t const packet_size = static_cast<std::uint32_t>(sizeof(ip_header) + sizeof(udp_header) + p.buffer.size());
-
-		write(m_file, sim_start_time + secs);
-		write(m_file, usecs);
-		write(m_file, packet_size);
-		write(m_file, packet_size);
-
-		// 17 is the protocol number for UDP
-		write_ip_header(m_file, packet_size, 17
-			, src.address().to_v4(), dst.address().to_v4());
-
-		write_udp_header(m_file, static_cast<int>(p.buffer.size()), p.from.port(), static_cast<int>(dst.port()));
-
-		m_file.write(reinterpret_cast<char const*>(p.buffer.data()), p.buffer.size());
-	}
-
-}}
-
diff -Naupr a/simulation/libsimulator/src/queue.cpp b/simulation/libsimulator/src/queue.cpp
--- a/simulation/libsimulator/src/queue.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/queue.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,142 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/queue.hpp"
-#include "simulator/handler_allocator.hpp"
-#include <functional>
-#include <cstdio> // for printf
-
-typedef sim::chrono::high_resolution_clock::time_point time_point;
-typedef sim::chrono::high_resolution_clock::duration duration;
-
-namespace sim
-{
-	using namespace aux;
-
-	queue::queue(asio::io_context& ios
-		, int bandwidth
-		, chrono::high_resolution_clock::duration propagation_delay
-		, int max_queue_size
-		, std::string name)
-		: m_max_queue_size(max_queue_size)
-		, m_forwarding_latency(propagation_delay)
-		, m_bandwidth(bandwidth)
-		, m_queue_size(0)
-		, m_node_name(name)
-		, m_forward_timer(ios)
-		, m_last_forward(chrono::high_resolution_clock::now())
-	{}
-
-	std::string queue::label() const
-	{
-		char ret[400];
-		int p = std::snprintf(ret, sizeof(ret), "%s\n", m_node_name.c_str());
-
-		if (m_bandwidth != 0)
-		{
-			p += std::snprintf(ret + p, sizeof(ret) - p, "rate: %d kB/s\n"
-				, m_bandwidth / 1000);
-		}
-
-		if (m_queue_size != 0)
-		{
-			p += std::snprintf(ret + p, sizeof(ret) - p, "queue: %d kB\n"
-				, m_queue_size / 1000);
-		}
-
-		if (m_forwarding_latency.count() != 0)
-		{
-			p += std::snprintf(ret + p, sizeof(ret) - p, "latency: %d ms\n"
-				, int(chrono::duration_cast<chrono::milliseconds>(m_forwarding_latency).count()));
-		}
-
-		return ret;
-	}
-
-	void queue::incoming_packet(aux::packet p)
-	{
-		const int packet_size = int(p.buffer.size() + p.overhead);
-
-		// tail-drop
-		if (p.ok_to_drop()
-			&& m_max_queue_size > 0
-			&& m_queue_size + packet_size > m_max_queue_size)
-		{
-			// if any hop on the network drops a packet, it has to return it to the
-			// sender.
-			auto drop_fun = std::move(p.drop_fun);
-			if (drop_fun) drop_fun(std::move(p));
-			return;
-		}
-
-		time_point const now = chrono::high_resolution_clock::now();
-
-		m_queue.emplace_back(now + m_forwarding_latency, std::move(p));
-		m_queue_size += packet_size;
-		if (m_queue.size() > 1) return;
-
-		begin_send_next_packet();
-	}
-
-	void queue::begin_send_next_packet()
-	{
-		time_point now = chrono::high_resolution_clock::now();
-
-		if (m_queue.front().ts > now)
-		{
-			m_forward_timer.expires_at(m_queue.front().ts);
-			m_forward_timer.async_wait(make_malloc(std::bind(&queue::begin_send_next_packet
-				, this)));
-			return;
-		}
-
-		m_last_forward = now;
-		if (m_bandwidth == 0)
-		{
-			post(m_forward_timer.get_executor(), make_malloc(std::bind(&queue::next_packet_sent
-				, this)));
-			return;
-		}
-		const double nanoseconds_per_byte = 1000000000.0
-			/ double(m_bandwidth);
-
-		aux::packet const& p = m_queue.front().pkt;
-		const int packet_size = int(p.buffer.size() + p.overhead);
-
-		m_last_forward += chrono::duration_cast<duration>(chrono::nanoseconds(
-			boost::int64_t(nanoseconds_per_byte * packet_size)));
-
-		m_forward_timer.expires_at(m_last_forward);
-		m_forward_timer.async_wait(make_malloc(std::bind(&queue::next_packet_sent
-			, this)));
-	}
-
-	void queue::next_packet_sent()
-	{
-		aux::packet p = std::move(m_queue.front().pkt);
-		m_queue.erase(m_queue.begin());
-		const int packet_size = int(p.buffer.size() + p.overhead);
-		m_queue_size -= packet_size;
-
-		forward_packet(std::move(p));
-
-		if (m_queue.size())
-			begin_send_next_packet();
-	}
-}
-
diff -Naupr a/simulation/libsimulator/src/resolver.cpp b/simulation/libsimulator/src/resolver.cpp
--- a/simulation/libsimulator/src/resolver.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/resolver.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,143 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/handler_allocator.hpp"
-#include <functional>
-
-typedef sim::chrono::high_resolution_clock::time_point time_point;
-typedef sim::chrono::high_resolution_clock::duration duration;
-
-using namespace std::placeholders;
-
-namespace sim {
-namespace asio {
-namespace ip {
-
-	template<typename Protocol>
-	basic_resolver<Protocol>::basic_resolver(io_context& ios)
-		: m_ios(&ios)
-		, m_timer(ios)
-	{}
-
-	template<typename Protocol>
-	basic_resolver<Protocol>::basic_resolver(basic_resolver<Protocol>&&) noexcept = default;
-
-	template<typename Protocol>
-	basic_resolver<Protocol>& basic_resolver<Protocol>::operator=(basic_resolver<Protocol>&&) noexcept = default;
-
-	template<typename Protocol>
-	void basic_resolver<Protocol>::async_resolve(std::string hostname, char const* service
-		, aux::function<void(boost::system::error_code const&, results_type)> handler)
-	{
-		std::vector<asio::ip::address> result;
-		boost::system::error_code ec;
-
-		const chrono::high_resolution_clock::time_point start_time =
-			m_queue.empty() ? chrono::high_resolution_clock::now() :
-			m_queue.front().completion_time;
-
-		assert(!m_ios->get_ips().empty() && "internal io service objects can only "
-			"be used for timers");
-
-		// if the hostname is an IP address, resolve it immediately
-		asio::ip::address addr = make_address_v4(hostname, ec);
-		if (ec) addr = make_address_v6(hostname, ec);
-		if (!ec)
-		{
-			const chrono::high_resolution_clock::time_point t = chrono::high_resolution_clock::now()
-				+ chrono::microseconds(1);
-			results_type ips;
-			int const port = atoi(service);
-			assert(port >= 0 && port <= 0xffff);
-			ips.emplace_back(
-				typename Protocol::endpoint(addr, static_cast<unsigned short>(port))
-				, hostname, service);
-			result_t res{t, ec, std::move(ips), std::move(handler) };
-			m_queue.insert(m_queue.begin(), std::move(res));
-			m_timer.expires_at(m_queue.front().completion_time);
-			m_timer.async_wait(aux::make_malloc(std::bind(&basic_resolver::on_lookup, this, _1)));
-			return;
-		}
-		ec.clear();
-
-		const chrono::high_resolution_clock::time_point completion_time =
-			start_time
-			+ m_ios->sim().config().hostname_lookup(m_ios->get_ips().front(), hostname
-				, result, ec);
-
-		results_type ips;
-
-		int const port = atoi(service);
-		assert(port >= 0 && port <= 0xffff);
-
-		for (auto const& ip : result)
-		{
-			ips.emplace_back(
-				typename Protocol::endpoint(ip, static_cast<unsigned short>(port))
-				, hostname, service);
-		}
-
-		result_t res{ completion_time, ec, std::move(ips), std::move(handler)};
-		m_queue.emplace_back(std::move(res));
-
-		m_timer.expires_at(m_queue.front().completion_time);
-		m_timer.async_wait(aux::make_malloc(std::bind(&basic_resolver::on_lookup, this, _1)));
-	}
-
-	template<typename Protocol>
-	void basic_resolver<Protocol>::on_lookup(boost::system::error_code const& ec)
-	{
-		if (ec == asio::error::operation_aborted) return;
-
-		if (m_queue.empty()) return;
-
-		typename queue_t::value_type v = std::move(m_queue.front());
-		m_queue.erase(m_queue.begin());
-
-		// once the handler is called, it's possible the last reference keeping
-		// this object (basic_resolver) alive is released and we're deleted. Make
-		// sure to not touch any members after the handler in that case.
-		bool const empty = m_queue.empty();
-		v.handler(v.err, std::move(v.ips));
-		if (empty) return;
-
-		m_timer.expires_at(m_queue.front().completion_time);
-		m_timer.async_wait(aux::make_malloc(std::bind(&basic_resolver::on_lookup, this, _1)));
-	}
-
-	template<typename Protocol>
-	void basic_resolver<Protocol>::cancel()
-	{
-		queue_t q;
-		m_queue.swap(q);
-		for (auto& r : q)
-		{
-			r.err = asio::error::operation_aborted;
-			post(m_timer.get_executor(), aux::make_malloc(std::bind(std::move(r.handler)
-				, r.err, std::move(r.ips))));
-		}
-	}
-
-	// explicitly instantiate the functions
-	template struct basic_resolver<udp>;
-	template struct basic_resolver<tcp>;
-}
-}
-}
-
diff -Naupr a/simulation/libsimulator/src/simulation.cpp b/simulation/libsimulator/src/simulation.cpp
--- a/simulation/libsimulator/src/simulation.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/simulation.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,349 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/packet.hpp"
-#include "simulator/pcap.hpp"
-
-#include <tuple> // for tie
-#include <memory> // for make_shared
-#include <cstdio> // for printf
-
-using namespace sim::asio;
-
-namespace sim
-{
-	simulation::simulation(configuration& config)
-		: m_config(config)
-		, m_internal_ios(new asio::io_context(*this))
-		, m_service(1)
-	{
-		sim::chrono::reset_clock();
-		m_config.build(*this);
-	}
-
-	simulation::~simulation()
-	{
-		m_config.clear();
-
-		assert(m_timer_queue.empty());
-	}
-
-	std::size_t simulation::run() try
-	{
-		std::size_t ret = 0;
-		std::size_t last_executed = 0;
-		do {
-
-			m_service.restart();
-			last_executed = m_service.poll();
-			ret += last_executed;
-
-			chrono::high_resolution_clock::time_point now
-				= chrono::high_resolution_clock::now();
-
-			std::lock_guard<std::mutex> l(m_timer_queue_mutex);
-			if (!m_timer_queue.empty()) {
-				asio::high_resolution_timer* next_timer = *m_timer_queue.begin();
-				chrono::high_resolution_clock::fast_forward(next_timer->expiry() - now);
-
-				now = chrono::high_resolution_clock::now();
-
-				while (!m_timer_queue.empty()
-					&& (*m_timer_queue.begin())->expiry() <= now) {
-
-					next_timer = *m_timer_queue.begin();
-					m_timer_queue.erase(m_timer_queue.begin());
-					next_timer->fire(boost::system::error_code());
-					++last_executed;
-					++ret;
-				}
-			}
-
-//			std::fprintf(stderr, "run: last_executed: %d stopped: %d timer-queue: %d\n"
-//				, int(last_executed), m_stopped, int(m_timer_queue.size()));
-		} while (last_executed > 0 && !m_stopped);
-
-//		std::fprintf(stderr, "exiting simulation::run(): last_executed: %d stopped: %d timer-queue: %d ret: %d\n"
-//			, int(last_executed), m_stopped, int(m_timer_queue.size()), int(ret));
-		return ret;
-	}
-	catch (...)
-	{
-		// cancel all outstanding timers
-		// we make a copy, since cancelling the timers will mutate m_timer_queue
-		auto queue = m_timer_queue;
-		for (auto& t : queue)
-			t->cancel();
-
-		auto listen_sockets = m_listen_sockets;
-		for (auto& s : listen_sockets)
-			s.second->cancel();
-
-		auto udp_sockets = m_udp_sockets;
-		for (auto& s : udp_sockets)
-			s.second->cancel();
-		m_stopped = true;
-		throw;
-	}
-
-	void simulation::stop() { m_stopped = true; }
-	bool simulation::stopped() const { return m_stopped; }
-	void simulation::restart() { m_stopped = false; }
-
-	void simulation::add_timer(asio::high_resolution_timer* t)
-	{
-		assert(!m_stopped);
-		if (t->expiry() == sim::chrono::high_resolution_clock::now())
-		{
-			std::fprintf(stderr, "WARNING: timer scheduled for current time!\n");
-		}
-		std::lock_guard<std::mutex> l(m_timer_queue_mutex);
-		m_timer_queue.insert(t);
-	}
-
-	void simulation::remove_timer(asio::high_resolution_timer* t)
-	{
-		std::lock_guard<std::mutex> l(m_timer_queue_mutex);
-		if (m_timer_queue.empty()) return;
-		timer_queue_t::iterator begin;
-		timer_queue_t::iterator end;
-		std::tie(begin, end) = m_timer_queue.equal_range(t);
-		if (begin == end) return;
-		begin = std::find(begin, end, t);
-		if (begin == end) return;
-		m_timer_queue.erase(begin);
-	}
-
-	void simulation::rebind_socket(ip::tcp::socket* s, ip::tcp::endpoint ep)
-	{
-		auto i = m_listen_sockets.find(ep);
-		assert(i != m_listen_sockets.end());
-		i->second = s;
-	}
-
-	ip::tcp::endpoint simulation::bind_socket(ip::tcp::socket* socket
-		, ip::tcp::endpoint ep, boost::system::error_code& ec)
-	{
-		assert(ep.address() != boost::asio::ip::address());
-
-		if (ep.port() < 1024 && ep.port() > 0)
-		{
-			// emulate process not running as root
-			ec = boost::asio::error::access_denied;
-			return ip::tcp::endpoint();
-		}
-
-		if (ep.port() == 0)
-		{
-			// if the socket is being bound to port 0, it means the system picks a
-			// free port. We want to avoid re-using ports, because that may confuse
-			// wireshark when threading together the TCP streams.
-			ep.port(m_next_bind_port++);
-			if (m_next_bind_port > 65534) m_next_bind_port = 2000;
-
-			listen_socket_iter_t i = m_listen_sockets.lower_bound(ep);
-			while (i != m_listen_sockets.end() && i->first == ep)
-			{
-				ep.port(ep.port() + 1);
-				if (ep.port() > 65530)
-				{
-					ec = boost::asio::error::address_in_use;
-					return ip::tcp::endpoint();
-				}
-				i = m_listen_sockets.lower_bound(ep);
-			}
-		}
-
-		listen_socket_iter_t i = m_listen_sockets.lower_bound(ep);
-		if (i != m_listen_sockets.end() && i->first == ep)
-		{
-			ec = boost::asio::error::address_in_use;
-			return ip::tcp::endpoint();
-		}
-
-		m_listen_sockets.insert(i, std::make_pair(ep, socket));
-		ec.clear();
-		return ep;
-	}
-
-	void simulation::unbind_socket(ip::tcp::socket* socket
-		, const ip::tcp::endpoint& ep)
-	{
-		listen_socket_iter_t i = m_listen_sockets.find(ep);
-		if (i == m_listen_sockets.end() || i->second != socket) return;
-		m_listen_sockets.erase(i);
-	}
-
-	void simulation::rebind_udp_socket(ip::udp::socket* socket, ip::udp::endpoint ep)
-	{
-		auto i = m_udp_sockets.find(ep);
-		assert(i != m_udp_sockets.end());
-		i->second = socket;
-	}
-
-	ip::udp::endpoint simulation::bind_udp_socket(ip::udp::socket* socket
-		, ip::udp::endpoint ep, boost::system::error_code& ec)
-	{
-		assert(ep.address() != boost::asio::ip::address());
-
-		if (ep.port() < 1024 && ep.port() > 0)
-		{
-			// emulate process not running as root
-			ec = boost::asio::error::access_denied;
-			return ip::udp::endpoint();
-		}
-
-		if (ep.port() == 0)
-		{
-			// if the socket is being bound to port 0, it means the system picks a
-			// free port.
-
-			ep.port(m_next_bind_port++);
-			if (m_next_bind_port > 65534) m_next_bind_port = 2000;
-			udp_socket_iter_t i = m_udp_sockets.lower_bound(ep);
-			while (i != m_udp_sockets.end() && i->first == ep)
-			{
-				ep.port(ep.port() + 1);
-				if (ep.port() > 65530)
-				{
-					ec = boost::asio::error::address_in_use;
-					return ip::udp::endpoint();
-				}
-				i = m_udp_sockets.lower_bound(ep);
-			}
-		}
-
-		udp_socket_iter_t i = m_udp_sockets.lower_bound(ep);
-		if (i != m_udp_sockets.end() && i->first == ep)
-		{
-			ec = boost::asio::error::address_in_use;
-			return ip::udp::endpoint();
-		}
-
-		m_udp_sockets.insert(i, std::make_pair(ep, socket));
-		ec.clear();
-		return ep;
-	}
-
-	void simulation::unbind_udp_socket(ip::udp::socket* socket
-		, const ip::udp::endpoint& ep)
-	{
-		udp_socket_iter_t i = m_udp_sockets.find(ep);
-		if (i == m_udp_sockets.end() || i->second != socket) return;
-		m_udp_sockets.erase(i);
-	}
-
-	std::shared_ptr<aux::channel> simulation::internal_connect(
-		asio::ip::tcp::socket* s
-		, ip::tcp::endpoint const& target, boost::system::error_code& ec)
-	{
-		// find remote socket
-		listen_sockets_t::iterator i = m_listen_sockets.find(target);
-		if (i == m_listen_sockets.end())
-		{
-			ec = boost::system::error_code(error::connection_refused);
-			return std::shared_ptr<aux::channel>();
-		}
-
-		// make sure it's a listening socket
-		ip::tcp::socket* remote = i->second;
-		if (!remote->internal_is_listening())
-		{
-			ec = boost::system::error_code(error::connection_refused);
-			return std::shared_ptr<aux::channel>();
-		}
-
-		// create a channel
-		std::shared_ptr<aux::channel> c = std::make_shared<aux::channel>();
-
-		asio::ip::tcp::endpoint from = s->local_bound_to(ec);
-
-		route network_route = m_config.channel_route(from.address()
-			, target.address());
-		c->hops[0] = remote->get_outgoing_route() + network_route + s->get_incoming_route();
-		c->hops[1] = s->get_outgoing_route() + network_route + remote->get_incoming_route();
-
-		c->ep[0] = s->local_bound_to(ec);
-		c->ep[1] = remote->local_bound_to(ec);
-
-		c->visible_ep[0] = s->local_bound_to(ec);
-		c->visible_ep[1] = remote->local_bound_to(ec);
-
-		aux::packet p;
-		p.type = aux::packet::type_t::syn;
-		p.overhead = 28;
-		p.from = asio::ip::udp::endpoint(from.address(), from.port());
-		p.channel = c;
-		if (ec) return std::shared_ptr<aux::channel>();
-
-		p.hops = c->hops[1];
-
-		forward_packet(std::move(p));
-
-		return c;
-	}
-
-	route simulation::find_udp_socket(asio::ip::udp::socket const& socket
-		, ip::udp::endpoint const& ep)
-	{
-		udp_socket_iter_t i = m_udp_sockets.find(ep);
-		if (i == m_udp_sockets.end())
-			return route();
-
-		ip::udp::endpoint src = socket.local_bound_to();
-		route network_route = m_config.channel_route(src.address(), ep.address());
-
-		// ask the socket for its incoming route
-		network_route.append(i->second->get_incoming_route());
-
-		return network_route;
-	}
-
-	void simulation::add_io_service(asio::io_context* ios)
-	{
-		bool added = m_nodes.insert(ios).second;
-		(void)added;
-		assert(added);
-	}
-
-	void simulation::remove_io_service(asio::io_context* ios)
-	{
-		auto it = m_nodes.find(ios);
-		assert(it != m_nodes.end());
-		m_nodes.erase(it);
-	}
-
-	std::vector<io_context*> simulation::get_all_io_services() const
-	{
-		std::vector<io_context*> ret;
-		ret.reserve(m_nodes.size());
-		std::remove_copy_if(
-			m_nodes.begin(), m_nodes.end(), std::back_inserter(ret)
-			, [](io_context* ios) { return ios->get_ips().empty(); });
-		return ret;
-	}
-
-	void simulation::log_pcap(char const* filename)
-	{
-		std::printf("saving packet capture to: \"%s\"\n", filename);
-		m_pcap = std::unique_ptr<aux::pcap>(new aux::pcap(filename));
-	}
-
-}
-
diff -Naupr a/simulation/libsimulator/src/simulator.cpp b/simulation/libsimulator/src/simulator.cpp
--- a/simulation/libsimulator/src/simulator.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/simulator.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,262 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/packet.hpp"
-
-#include <functional>
-#include <unordered_set>
-#include <set>
-#include <cstdio> // for printf
-
-#include "simulator/push_warnings.hpp"
-#include <boost/system/error_code.hpp>
-#include "simulator/pop_warnings.hpp"
-
-typedef sim::chrono::high_resolution_clock::time_point time_point;
-typedef sim::chrono::high_resolution_clock::duration duration;
-
-namespace sim {
-namespace asio {
-namespace ip {
-
-	default_config default_cfg;
-
-} // ip
-} // asio
-
-void forward_packet(aux::packet p)
-{
-	std::shared_ptr<sink> next_hop = p.hops.pop_front();
-	if (!next_hop)
-	{
-		std::fprintf(stderr, "packet lost\n");
-		return;
-	}
-	next_hop->incoming_packet(std::move(p));
-}
-
-namespace
-{
-	// this is a dummy sink for endpoints, wrapping an io_context
-	struct endpoint : sink
-	{
-		endpoint(asio::io_context& ioc)
-			: m_ioc(ioc)
-		{}
-
-		virtual void incoming_packet(aux::packet p) override final { assert(false); }
-
-		virtual std::string label() const override final
-		{
-			std::string ret;
-			for (auto const& ip : m_ioc.get_ips())
-			{
-				ret += ip.to_string();
-				ret += " ";
-			}
-			return ret;
-		}
-
-		virtual std::string attributes() const override final
-		{
-			return "shape=ellipse";
-		}
-
-	private:
-		asio::io_context& m_ioc;
-	};
-}
-
-namespace
-{
-	std::string escape_label(std::string n)
-	{
-		std::string ret;
-		for (auto c : n)
-		{
-			if (c == '\n')
-			{
-				ret += "\\n";
-				continue;
-			}
-			if (c == '\"')
-			{
-				ret += "\\\"";
-				continue;
-			}
-			ret += c;
-		}
-		return ret;
-	}
-}
-
-void dump_network_graph(simulation const& s, const std::string& filename)
-{
-	// all edges (directed).
-	std::set<std::pair<std::shared_ptr<sink>, std::shared_ptr<sink>>> edges;
-
-	// all network nodes
-	std::unordered_set<std::shared_ptr<sink>> nodes;
-
-	// local nodes (subgrapgs)
-	std::vector<std::unordered_set<std::shared_ptr<sink>>> local_nodes;
-
-	const std::vector<asio::io_context*> io_services = s.get_all_io_services();
-
-	for (auto ioc : io_services)
-	{
-		std::shared_ptr<sink> ep = std::make_shared<endpoint>(*ioc);
-		local_nodes.push_back(std::unordered_set<std::shared_ptr<sink>>());
-		local_nodes.back().insert(ep);
-
-		for (auto const& ip : ioc->get_ips())
-		{
-			route in = ioc->get_incoming_route(ip);
-			route out = ioc->get_outgoing_route(ip);
-
-			// this is the outgoing node for this endpoint. This is
-			// how it connects to the network.
-			const std::shared_ptr<sink> egress = out.empty() ? ep : out.last();
-
-			// first add both the incoming and outgoing chains
-			std::shared_ptr<sink> prev;
-			while (!in.empty())
-			{
-				auto node = in.pop_front();
-				local_nodes.back().insert(node);
-				if (prev) edges.insert({prev, node});
-				prev = node;
-			}
-			if (prev) edges.insert({prev, ep});
-
-			prev = ep;
-			while (!out.empty())
-			{
-				auto node = out.pop_front();
-				local_nodes.back().insert(node);
-				edges.insert({prev, node});
-				prev = node;
-			}
-
-			// then connect the endpoint of those chains to the rest of the network.
-			// Since the network may be arbitrarily complex, we actually have to
-			// completely iterate over all other endpoints
-
-			for (auto ios2 : io_services)
-			{
-				for (auto const& ip2 : ios2->get_ips())
-				{
-					route network = s.config().channel_route(
-						ip, ip2);
-
-					std::shared_ptr<sink> last = ios2->get_incoming_route(ip2).next_hop();
-
-					prev = egress;
-					while (!network.empty())
-					{
-						auto node = network.pop_front();
-						nodes.insert(node);
-						edges.insert({prev, node});
-						prev = node;
-					}
-					edges.insert({prev, last});
-				}
-			}
-		}
-	}
-
-	// by now, the nodes and edges should represent the complete graph. Render it
-	// into dot.
-
-	FILE* f = fopen(filename.c_str(), "w+");
-
-	std::fprintf(f, "digraph network {\n"
-		"concentrate=true;\n"
-		"overlap=scale;\n"
-		"splines=true;\n");
-
-	std::fprintf(f, "\n// nodes\n\n");
-
-	for (const auto& n : nodes)
-	{
-		std::string attributes = n->attributes();
-		std::fprintf(f, " \"%p\" [label=\"%s\",style=\"filled\",color=\"red\"%s%s];\n"
-			, static_cast<void*>(n.get())
-			, escape_label(n->label()).c_str()
-			, attributes.empty() ? "" : ", "
-			, attributes.c_str());
-	}
-
-	std::fprintf(f, "\n// local networks\n\n");
-
-	int idx = 0;
-	for (auto ln : local_nodes)
-	{
-		std::fprintf(f, "subgraph cluster_%d {\n", idx++);
-
-		for (const auto& n : ln)
-		{
-			std::string attributes = n->attributes();
-			std::fprintf(f, " \"%p\" [label=\"%s\",style=\"filled\",color=\"green\"%s%s];\n"
-				, static_cast<void*>(n.get())
-				, escape_label(n->label()).c_str()
-				, attributes.empty() ? "" : ", "
-				, attributes.c_str());
-		}
-
-		std::fprintf(f, "}\n");
-	}
-
-	std::fprintf(f, "\n// edges\n\n");
-
-	while (!edges.empty())
-	{
-		auto edge = *edges.begin();
-		edges.erase(edges.begin());
-
-		std::fprintf(f, "\"%p\" -> \"%p\"\n"
-			, static_cast<void*>(edge.first.get())
-			, static_cast<void*>(edge.second.get()));
-	}
-
-	std::fprintf(f, "}\n");
-	fclose(f);
-}
-
-namespace aux {
-
-	int channel::remote_idx(const asio::ip::tcp::endpoint& self) const
-	{
-		if (ep[0] == self) return 1;
-		if (ep[1] == self) return 0;
-		assert(false && "invalid socket");
-		return -1;
-	}
-
-	int channel::self_idx(const asio::ip::tcp::endpoint& self) const
-	{
-		if (ep[0] == self) return 0;
-		if (ep[1] == self) return 1;
-		assert(false && "invalid socket");
-		return -1;
-	}
-
-} // aux
-} // sim
-
diff -Naupr a/simulation/libsimulator/src/sink_forwarder.cpp b/simulation/libsimulator/src/sink_forwarder.cpp
--- a/simulation/libsimulator/src/sink_forwarder.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/sink_forwarder.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/sink_forwarder.hpp"
-#include "simulator/packet.hpp"
-
-namespace sim { namespace aux {
-
-	sink_forwarder::sink_forwarder(sink* dst)
-		: m_dst(dst)
-	{}
-
-	void sink_forwarder::incoming_packet(packet p)
-	{
-		if (m_dst == nullptr) return;
-		m_dst->incoming_packet(std::move(p));
-	}
-
-	std::string sink_forwarder::label() const
-	{
-		return m_dst ? m_dst->label() : "";
-	}
-
-	void sink_forwarder::reset(sink* s)
-	{
-		m_dst = s;
-	}
-
-}}
-
diff -Naupr a/simulation/libsimulator/src/socks_server.cpp b/simulation/libsimulator/src/socks_server.cpp
--- a/simulation/libsimulator/src/socks_server.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/socks_server.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,912 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/socks_server.hpp"
-
-#include <functional>
-#include <cstdint>
-#include <cinttypes>
-#include <cstdio> // for printf
-
-using namespace sim::asio;
-using namespace sim::asio::ip;
-using namespace std::placeholders;
-
-using boost::system::error_code;
-
-namespace sim
-{
-	using namespace aux;
-
-	socks_server::socks_server(io_context& ios, unsigned short listen_port, int version
-		, std::uint32_t const flags)
-		: m_ios(ios)
-		, m_listen_socket(ios)
-		, m_conn(std::make_shared<socks_connection>(m_ios, version, m_cmd_counts, flags))
-		, m_close(false)
-		, m_version(version)
-		, m_flags(flags)
-	{
-		m_cmd_counts.fill(0);
-		address local_ip = ios.get_ips().front();
-		if (local_ip.is_v4())
-		{
-			m_listen_socket.open(tcp::v4());
-			m_listen_socket.bind(tcp::endpoint(address_v4::any(), listen_port));
-		}
-		else
-		{
-			m_listen_socket.open(tcp::v6());
-			m_listen_socket.bind(tcp::endpoint(address_v6::any(), listen_port));
-		}
-		m_listen_socket.listen();
-
-		m_listen_socket.async_accept(m_conn->socket(), m_ep
-			, std::bind(&socks_server::on_accept, this, _1));
-	}
-
-	void socks_server::on_accept(error_code const& ec)
-	{
-		if (ec == asio::error::operation_aborted)
-			return;
-
-		if (ec)
-		{
-			std::printf("socks_server::on_accept: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			return;
-		}
-
-		std::printf("socks_server accepted connection from: %s : %d\n",
-			m_ep.address().to_string().c_str(), m_ep.port());
-
-		m_conn->start();
-
-		// create a new connection to accept into
-		m_conn = std::make_shared<socks_connection>(m_ios, m_version, m_cmd_counts, m_flags);
-
-		// now we can accept another connection
-		m_listen_socket.async_accept(m_conn->socket(), m_ep
-			, std::bind(&socks_server::on_accept, this, _1));
-	}
-
-	void socks_server::stop()
-	{
-		m_close = true;
-		m_listen_socket.close();
-	}
-
-	socks_connection::socks_connection(asio::io_context& ios
-		, int version, std::array<int, 3>& cmd_counts, std::uint32_t const flags)
-		: m_ios(ios)
-		, m_resolver(m_ios)
-		, m_client_connection(ios)
-		, m_server_connection(m_ios)
-		, m_bind_socket(m_ios)
-		, m_udp_associate(m_ios)
-		, m_num_out_bytes(0)
-		, m_num_in_bytes(0)
-		, m_close(false)
-		, m_version(version)
-		, m_command(0)
-		, m_cmd_counts(cmd_counts)
-		, m_flags(flags)
-	{
-	}
-
-	void socks_connection::start()
-	{
-		if (m_version == 4)
-		{
-			asio::async_read(m_client_connection, asio::buffer(&m_out_buffer[0], 9)
-				, std::bind(&socks_connection::on_request1, shared_from_this(), _1, _2));
-		} else {
-			// read protocol version and number of auth-methods
-			asio::async_read(m_client_connection, asio::buffer(&m_out_buffer[0], 2)
-				, std::bind(&socks_connection::on_handshake1, shared_from_this(), _1, _2));
-		}
-	}
-
-	void socks_connection::on_handshake1(error_code const& ec, size_t bytes_transferred)
-	{
-		if (ec || bytes_transferred != 2)
-		{
-			std::printf("socks_connection::on_handshake1: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		if (m_out_buffer[0] != 4 && m_out_buffer[0] != 5)
-		{
-			std::printf("socks_connection::on_handshake1: unexpected socks protocol version: %d"
-				, int(m_out_buffer[0]));
-			close_connection();
-			return;
-		}
-
-		int num_methods = unsigned(m_out_buffer[1]);
-
-		// read list of auth-methods
-		asio::async_read(m_client_connection, asio::buffer(&m_out_buffer[0],
-				num_methods)
-			, std::bind(&socks_connection::on_handshake2, shared_from_this()
-				, _1, _2));
-	}
-
-	void socks_connection::on_handshake2(error_code const& ec, size_t bytes_transferred)
-	{
-		if (ec)
-		{
-			std::printf("socks_connection::on_handshake2: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		if (std::count(m_out_buffer, m_out_buffer + bytes_transferred, 0) == 0)
-		{
-			std::printf("socks_connection: could not find auth-method 0 (no-auth) in socks handshake\n");
-			close_connection();
-			return;
-		}
-
-		m_in_buffer[0] = 5; // socks version
-		m_in_buffer[1] = 0; // auth-method (no-auth)
-
-		asio::async_write(m_client_connection, asio::buffer(&m_in_buffer[0], 2)
-			, std::bind(&socks_connection::on_handshake3, shared_from_this()
-				, _1, _2));
-	}
-
-	void socks_connection::on_handshake3(error_code const& ec, size_t bytes_transferred)
-	{
-		if (ec || bytes_transferred != 2)
-		{
-			std::printf("socks_connection::on_handshake3: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		asio::async_read(m_client_connection, asio::buffer(&m_out_buffer[0], 10)
-			, std::bind(&socks_connection::on_request1, shared_from_this()
-				, _1, _2));
-	}
-
-	void socks_connection::on_request1(error_code const& ec, size_t bytes_transferred)
-	{
-		size_t const expected = m_version == 4 ? 9 : 10;
-		if (ec || bytes_transferred != expected)
-		{
-			std::printf("socks_connection::on_request1: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-// +----+-----+-------+------+----------+----------+
-// |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
-// +----+-----+-------+------+----------+----------+
-// | 1  |  1  | X'00' |  1   | Variable |    2     |
-// +----+-----+-------+------+----------+----------+
-
-		int const version = m_out_buffer[0];
-		int const command = m_out_buffer[1];
-		m_command = command;
-		++m_cmd_counts[command - 1];
-
-		if (version != m_version)
-		{
-			std::printf("socks_connection::on_request1: unexpected socks protocol version: %d expected: %d\n"
-				, int(m_out_buffer[0]), m_version);
-			close_connection();
-			return;
-		}
-
-		if (m_version == 4)
-		{
-			if (command != 1 && command != 2)
-			{
-				std::printf("socks_connection::on_request1: unexpected socks command: %d\n"
-					, command);
-				close_connection();
-				return;
-			}
-
-			std::uint16_t port = m_out_buffer[2] & 0xff;
-			port <<= 8;
-			port |= m_out_buffer[3] & 0xff;
-
-			std::uint32_t addr = m_out_buffer[4] & 0xff;
-			addr <<= 8;
-			addr |= m_out_buffer[5] & 0xff;
-			addr <<= 8;
-			addr |= m_out_buffer[6] & 0xff;
-			addr <<= 8;
-			addr |= m_out_buffer[7] & 0xff;
-
-			if (m_out_buffer[8] != 0)
-			{
-				// in this case, we would have to read one byte at a time until we
-				// get to the null terminator.
-				std::printf("socks_connection::on_request1: username in SOCKS4 mode not supported\n");
-				close_connection();
-				return;
-			}
-			asio::ip::tcp::endpoint target(asio::ip::address_v4(addr), port);
-			if (command == 1)
-			{
-				open_forward_connection(target);
-			}
-			else if (command == 2)
-			{
-				bind_connection(target);
-			}
-
-			return;
-		}
-
-		if (command != 1 && command != 2 && command != 3)
-		{
-			std::printf("socks_connection::on_request1: unexpected command: %d\n"
-				, command);
-			close_connection();
-			return;
-		}
-
-		if (m_out_buffer[2] != 0)
-		{
-			std::printf("socks_connection::on_request1: reserved byte is non-zero: %d\n"
-				, int(m_out_buffer[2]));
-			close_connection();
-			return;
-		}
-
-		int atyp = unsigned(m_out_buffer[3]);
-
-		if (atyp != 1 && atyp != 3 && atyp != 4)
-		{
-			std::printf("socks_connection::on_request1: unexpected address type in SOCKS request: %d\n"
-				, atyp);
-			close_connection();
-			return;
-		}
-
-		std::printf("socks_connection: received %s request address type: %d\n"
-			, command == 1 ? "CONNECT"
-			: command == 2 ? "BIND"
-			: "UDP_ASSOCIATE", atyp);
-
-		switch (atyp)
-		{
-			case 1: { // IPv4 address (we have the whole request already)
-
-// +----+-----+-------+------+----------+----------+
-// |VER | CMD |  RSV  | ATYP | BND.ADDR | BND.PORT |
-// +----+-----+-------+------+----------+----------+
-// | 1  |  1  | X'00' |  1   | 4        |    2     |
-// +----+-----+-------+------+----------+----------+
-
-				std::uint32_t addr = m_out_buffer[4] & 0xff;
-				addr <<= 8;
-				addr |= m_out_buffer[5] & 0xff;
-				addr <<= 8;
-				addr |= m_out_buffer[6] & 0xff;
-				addr <<= 8;
-				addr |= m_out_buffer[7] & 0xff;
-
-				std::uint16_t port = m_out_buffer[8] & 0xff;
-				port <<= 8;
-				port |= m_out_buffer[9] & 0xff;
-
-				asio::ip::tcp::endpoint target(asio::ip::address_v4(addr), port);
-				if (command == 1)
-				{
-					open_forward_connection(target);
-				}
-				else if (command == 2)
-				{
-					bind_connection(target);
-				}
-				else if (command == 3)
-				{
-					if (target.address() == address())
-					{
-						target.address(m_client_connection.remote_endpoint().address());
-					}
-					udp_associate(target);
-				}
-
-				break;
-			}
-			case 3: { // domain name
-
-// +----+-----+-------+------+-----+----------+----------+
-// |VER | CMD |  RSV  | ATYP | LEN | BND.ADDR | BND.PORT |
-// +----+-----+-------+------+-----+----------+----------+
-// | 1  |  1  | X'00' |  1   | 1   | Variable |    2     |
-// +----+-----+-------+------+-----+----------+----------+
-
-				if (command == 2)
-				{
-					std::printf("ERROR: cannot BIND to hostname address (only IPv4 or IPv6 addresses)\n");
-					close_connection();
-					return;
-				}
-
-				const int len = std::uint8_t(m_out_buffer[4]);
-				// we already read an address of length 4, assuming it was an IPv4
-				// address. Now, with a domain name, one of those bytes was the
-				// length-prefix, but we still read 3 bytes already.
-				const int additional_bytes = len - 3;
-				asio::async_read(m_client_connection, asio::buffer(&m_out_buffer[10], additional_bytes)
-					, std::bind(&socks_connection::on_request_domain_name
-						, shared_from_this(), _1, _2));
-				break;
-			}
-			case 4: // IPv6 address
-
-// +----+-----+-------+------+----------+----------+
-// |VER | CMD |  RSV  | ATYP | BND.ADDR | BND.PORT |
-// +----+-----+-------+------+----------+----------+
-// | 1  |  1  | X'00' |  1   | 16       |    2     |
-// +----+-----+-------+------+----------+----------+
-
-				std::printf("ERROR: unsupported address type %d\n", atyp);
-				close_connection();
-		}
-	}
-
-	void socks_connection::on_request_domain_name(error_code const& ec, size_t bytes_transferred)
-	{
-		if (ec)
-		{
-			std::printf("socks_connection::on_request_domain_name(%s): (%d) %s\n"
-				, command(), ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		int const buffer_size = int(10 + bytes_transferred);
-
-		std::uint16_t port = m_out_buffer[buffer_size - 2] & 0xff;
-		port <<= 8;
-		port |= m_out_buffer[buffer_size - 1] & 0xff;
-
-		std::string hostname(&m_out_buffer[5], std::uint8_t(m_out_buffer[4]));
-		std::printf("socks_connection::on_request_domain_name(%s): hostname: %s port: %d\n"
-			, command(), hostname.c_str(), port);
-
-		char port_str[10];
-		std::snprintf(port_str, sizeof(port_str), "%d", port);
-		m_resolver.async_resolve(hostname, port_str
-			, std::bind(&socks_connection::on_request_domain_lookup
-				, shared_from_this(), _1, _2));
-	}
-
-	void socks_connection::on_request_domain_lookup(boost::system::error_code const& ec
-		, asio::ip::tcp::resolver::results_type const ips)
-	{
-		if (ec || ips.empty())
-		{
-			if (ec)
-			{
-				std::printf("socks_connection::on_request_domain_lookup(%s): (%d) %s\n"
-					, command(), ec.value(), ec.message().c_str());
-			}
-			else
-			{
-				std::printf("socks_connection::on_request_domain_lookup(%s): empty response\n"
-					, command());
-			}
-
-// +----+-----+-------+------+----------+----------+
-// |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
-// +----+-----+-------+------+----------+----------+
-// | 1  |  1  | X'00' |  1   | Variable |    2     |
-// +----+-----+-------+------+----------+----------+
-
-			m_in_buffer[0] = char(m_version); // version
-			m_in_buffer[1] = 4; // response (host unreachable)
-			m_in_buffer[2] = 0; // reserved
-			m_in_buffer[3] = 1; // IPv4
-			memset(&m_in_buffer[4], 0, 4);
-			m_in_buffer[8] = 0; // port
-			m_in_buffer[9] = 0;
-
-			auto self = shared_from_this();
-			asio::async_write(m_client_connection
-				, asio::buffer(&m_in_buffer[0], 10)
-				, [=](boost::system::error_code const&, size_t)
-				{
-					self->close_connection();
-				});
-			return;
-		}
-
-		std::printf("socks_connection::on_request_domain_lookup(%s): connecting to: %s port: %d\n"
-			, command()
-			, ips.front().endpoint().address().to_string().c_str()
-			, ips.front().endpoint().port());
-		open_forward_connection(ips.front().endpoint());
-	}
-
-	void socks_connection::open_forward_connection(const asio::ip::tcp::endpoint& target)
-	{
-		std::printf("socks_connection::open_forward_connection(%s): connecting to %s port %d\n"
-			, command(), target.address().to_string().c_str(), target.port());
-
-		m_server_connection.open(target.protocol());
-		m_server_connection.async_connect(target
-			, std::bind(&socks_connection::on_connected, shared_from_this()
-				, _1));
-	}
-
-	void socks_connection::bind_connection(const asio::ip::tcp::endpoint& target)
-	{
-		std::printf("socks_connection::bind_connection(%s): binding to %s port %d\n"
-			, command(), target.address().to_string().c_str(), target.port());
-
-		error_code ec;
-		m_bind_socket.open(target.protocol(), ec);
-		if (ec)
-		{
-			std::printf("ERROR: open bind socket failed: (%d) %s\n", ec.value()
-				, ec.message().c_str());
-		}
-		else
-		{
-			m_bind_socket.bind(target, ec);
-		}
-
-		int const response = ec
-			? (m_version == 4 ? 91 : 1)
-			: (m_version == 4 ? 90 : 0);
-		tcp::endpoint ep = m_bind_socket.local_endpoint();
-		int const len = format_response(ep.address(), ep.port(), response);
-
-		if (ec)
-		{
-			std::printf("ERROR: binding socket to %s %d failed: (%d) %s\n"
-				, target.address().to_string().c_str()
-				, target.port()
-				, ec.value()
-				, ec.message().c_str());
-
-			auto self = shared_from_this();
-
-			asio::async_write(m_client_connection
-				, asio::buffer(&m_in_buffer[0], len)
-				, [=](boost::system::error_code const&, size_t)
-				{
-					self->close_connection();
-				});
-			return;
-		}
-
-		// send response
-		asio::async_write(m_client_connection
-			, asio::buffer(&m_in_buffer[0], len)
-			, std::bind(&socks_connection::start_accept, shared_from_this(), _1));
-	}
-
-	void socks_connection::udp_associate(const asio::ip::tcp::endpoint& target)
-	{
-		std::printf("socks_connection::udp_associate(%s): %s:%d\n"
-			, command(), target.address().to_string().c_str(), target.port());
-
-		m_udp_associate_ep.address(target.address());
-		m_udp_associate_ep.port(target.port());
-
-		error_code ec;
-		m_udp_associate.open(m_udp_associate_ep.protocol(), ec);
-		if (ec)
-		{
-			std::printf("ERROR: open UDP associate socket failed: (%d) %s\n", ec.value()
-				, ec.message().c_str());
-		}
-		else
-		{
-			m_udp_associate.bind(udp::endpoint(address_v4(), 0), ec);
-			if (ec)
-			{
-				std::printf("ERROR: binding socket failed: (%d) %s\n"
-					, ec.value(), ec.message().c_str());
-			}
-			else
-			{
-				m_udp_associate.non_blocking(true);
-				m_udp_associate.async_receive_from(boost::asio::buffer(m_udp_buffer)
-					, m_udp_from, 0, std::bind(&socks_connection::on_read_udp, this, _1, _2));
-			}
-		}
-
-		int const response = ec ? 1 : 0;
-		udp::endpoint ep = m_udp_associate.local_bound_to();
-		int const len = format_response(ep.address(), ep.port(), response);
-
-		if (ec)
-		{
-			auto self = shared_from_this();
-
-			asio::async_write(m_client_connection
-				, asio::buffer(&m_in_buffer[0], len)
-				, [=](boost::system::error_code const&, size_t)
-				{
-					self->close_connection();
-				});
-			return;
-		}
-
-		// send response
-		asio::async_write(m_client_connection, asio::buffer(&m_in_buffer[0], len)
-			, std::bind(&socks_connection::wait_for_eof, shared_from_this(), _1, _2));
-	}
-
-	void socks_connection::wait_for_eof(boost::system::error_code const& ec, std::size_t)
-	{
-		if (ec)
-		{
-			std::printf("socks_connection::wait_for_eof: %s\n", ec.message().c_str());
-			m_udp_associate.close();
-			m_udp_associate_ep = udp::endpoint();
-			m_client_connection.close();
-			return;
-		}
-
-		if (m_flags & socks_flag::disconnect_udp_associate)
-		{
-			std::printf("socks_connection::wait_for_eof: closing connection prematurely\n");
-			m_client_connection.close();
-			return;
-		}
-
-		m_client_connection.async_read_some(
-			asio::buffer(m_out_buffer)
-			, std::bind(&socks_connection::wait_for_eof, shared_from_this()
-				, _1, _2));
-	}
-
-	void socks_connection::on_read_udp(boost::system::error_code const& ec
-		, std::size_t bytes_transferred)
-	{
-		std::printf("socks_connection::on_read_udp\n");
-		if (ec)
-		{
-			std::printf("socks_connection::on_read_udp: %s\n", ec.message().c_str());
-			return;
-		}
-
-		// if the client didn't specify an IP and port it would send packets from,
-		// we assumed the same IP as the TCP connection and assume the port is the
-		// same as the first UDP packet from that host
-		if (m_udp_associate_ep.port() == 0
-			&& m_udp_from.address() == m_udp_associate_ep.address())
-		{
-			m_udp_associate_ep.port(m_udp_from.port());
-		}
-
-		if (m_udp_from == m_udp_associate_ep)
-		{
-			// read UDP ASSICOATE header and forward outgoing packet
-			// +----+------+------+----------+----------+----------+
-			// |RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |
-			// +----+------+------+----------+----------+----------+
-			// | 2  |  1   |  1   | Variable |    2     | Variable |
-			// +----+------+------+----------+----------+----------+
-
-			char const* ptr = m_udp_buffer.data();
-			if (ptr[2] != 0) std::printf("fragment != 0, not supported\n");
-
-			// TODO: support hostnames too
-			if (ptr[3] != 1) std::printf("only supports IPv4. ATYP: %d\n", ptr[3]);
-
-			std::uint32_t addr = ptr[4] & 0xff;
-			addr <<= 8;
-			addr |= ptr[5] & 0xff;
-			addr <<= 8;
-			addr |= ptr[6] & 0xff;
-			addr <<= 8;
-			addr |= ptr[7] & 0xff;
-
-			std::uint16_t port = ptr[8] & 0xff;
-			port <<= 8;
-			port |= ptr[9] & 0xff;
-
-			asio::ip::udp::endpoint const target(address_v4(addr), port);
-			error_code err;
-			m_udp_associate.send_to(boost::asio::buffer(ptr + 10, bytes_transferred - 10), target, 0, err);
-			if (err) std::printf("send_to failed: %s\n", err.message().c_str());
-		}
-		else
-		{
-			// add UDP ASSOCIATE header and forward to client
-			std::uint32_t const from_addr = m_udp_from.address().to_v4().to_uint();
-			std::uint16_t const from_port = m_udp_from.port();
-			std::array<char, 10> header;
-			header[0] = 0; // RSV
-			header[1] = 0;
-			header[2] = 0; // fragment
-			header[3] = 1; // ATYP
-			header[4] = (from_addr >> 24) & 0xff; // Address
-			header[5] = (from_addr >> 16) & 0xff;
-			header[6] = (from_addr >> 8) & 0xff;
-			header[7] = (from_addr) & 0xff;
-			header[8] = (from_port >> 8) & 0xff;
-			header[9] = from_port & 0xff;
-
-			std::array<boost::asio::const_buffer, 2> vec{{
-				{header.data(), header.size()},
-				{m_udp_buffer.data(), bytes_transferred}}};
-
-			error_code err;
-			m_udp_associate.send_to(vec, m_udp_associate_ep, 0, err);
-			if (err) std::printf("send_to failed: %s\n", err.message().c_str());
-		}
-
-		m_udp_associate.async_receive_from(boost::asio::buffer(m_udp_buffer)
-			, m_udp_from, 0, std::bind(&socks_connection::on_read_udp, this, _1, _2));
-	}
-
-	void socks_connection::start_accept(boost::system::error_code const& ec)
-	{
-		if (ec)
-		{
-			std::printf("socks_connection(%s): error writing to client: (%d) %s\n"
-				, command(), ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		m_bind_socket.listen();
-		m_bind_socket.async_accept(m_server_connection
-			, std::bind(&socks_connection::on_connected
-				, shared_from_this(), _1));
-
-		m_client_connection.async_read_some(
-			sim::asio::buffer(m_out_buffer)
-			, std::bind(&socks_connection::on_client_receive, shared_from_this()
-				, _1, _2));
-	}
-
-	int socks_connection::format_response(address const& addr, int const port
-		, int const response)
-	{
-		int i = 0;
-		if (m_version == 5)
-		{
-// +----+-----+-------+------+----------+----------+
-// |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
-// +----+-----+-------+------+----------+----------+
-// | 1  |  1  | X'00' |  1   | Variable |    2     |
-// +----+-----+-------+------+----------+----------+
-
-			m_in_buffer[i++] = char(m_version); // version
-			m_in_buffer[i++] = char(response); // response
-			m_in_buffer[i++] = 0; // reserved
-			if (addr.is_v4())
-			{
-				m_in_buffer[i++] = 1; // IPv4
-				address_v4::bytes_type b = addr.to_v4().to_bytes();
-				memcpy(&m_in_buffer[i], &b[0], b.size());
-				i += int(b.size());
-			} else {
-				m_in_buffer[i++] = 4; // IPv6
-				address_v6::bytes_type b = addr.to_v6().to_bytes();
-				memcpy(&m_in_buffer[i], &b[0], b.size());
-				i += int(b.size());
-			}
-
-			m_in_buffer[i++] = (port >> 8) & 0xff;
-			m_in_buffer[i++] = port & 0xff;
-		}
-		else
-		{
-			m_in_buffer[i++] = 0; // response version
-			m_in_buffer[i++] = char(response); // return code
-
-			assert(addr.is_v4());
-
-			m_in_buffer[i++] = (port >> 8) & 0xff;
-			m_in_buffer[i++] = port & 0xff;
-
-			address_v4::bytes_type b = addr.to_v4().to_bytes();
-			memcpy(&m_in_buffer[i], &b[0], b.size());
-			i += int(b.size());
-		}
-		return i;
-	}
-
-	void socks_connection::on_connected(boost::system::error_code const& ec)
-	{
-		std::printf("socks_connection(%s): on_connect: (%d) %s\n"
-			, command(), ec.value(), ec.message().c_str());
-
-		if (ec == asio::error::operation_aborted
-			|| ec == boost::system::errc::bad_file_descriptor)
-		{
-			return;
-		}
-
-		boost::system::error_code err;
-		asio::ip::tcp::endpoint const ep = m_server_connection.remote_endpoint(err);
-		if (!err)
-		{
-			std::printf("socks_connection(%s): remote_endpoint: %s %d\n"
-				, command(), ep.address().to_string().c_str(), ep.port());
-		}
-
-		int const response = ec
-			? (m_version == 4 ? 91 : 5)
-			: (m_version == 4 ? 90 : 0);
-		int const len = format_response(ep.address(), ep.port(), response);
-
-		if (ec)
-		{
-			std::printf("socks_connection(%s): failed to connect to/accept from target server: (%d) %s\n"
-				, command(), ec.value(), ec.message().c_str());
-
-			auto self = shared_from_this();
-
-			asio::async_write(m_client_connection
-				, asio::buffer(&m_in_buffer[0], len)
-				, [=](boost::system::error_code const&, size_t)
-				{
-					self->close_connection();
-				});
-			return;
-		}
-
-		auto self = shared_from_this();
-
-		asio::async_write(m_client_connection
-			, asio::buffer(&m_in_buffer[0], len)
-			, [=](boost::system::error_code const& ec, size_t)
-			{
-				if (ec)
-				{
-					std::printf("socks_connection(%s): error writing to client: (%d) %s\n"
-						, command(), ec.value(), ec.message().c_str());
-					return;
-				}
-
-			// read from the client and from the server
-			self->m_server_connection.async_read_some(
-				sim::asio::buffer(m_in_buffer)
-				, std::bind(&socks_connection::on_server_receive, self
-					, _1, _2));
-			self->m_client_connection.async_read_some(
-				sim::asio::buffer(m_out_buffer)
-				, std::bind(&socks_connection::on_client_receive, self
-					, _1, _2));
-			});
-	}
-
-	// we received some data from the client, forward it to the server
-	void socks_connection::on_client_receive(boost::system::error_code const& ec
-		, std::size_t bytes_transferred)
-	{
-		// bad file descriptor means the socket has been closed. Whoever closed
-		// the socket will have opened a new one, we cannot call
-		// close_connection()
-		if (ec == asio::error::operation_aborted
-			|| ec == boost::system::errc::bad_file_descriptor)
-			return;
-
-		if (ec)
-		{
-			std::printf("socks_connection (%s): error reading from client: (%d) %s\n"
-				, command(), ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-		asio::async_write(m_server_connection, asio::buffer(&m_out_buffer[0], bytes_transferred)
-			, std::bind(&socks_connection::on_client_forward, shared_from_this()
-				, _1, _2));
-	}
-
-	void socks_connection::on_client_forward(error_code const& ec
-		, size_t /* bytes_transferred */)
-	{
-		if (ec)
-		{
-			std::printf("socks_connection(%s): error writing to server: (%d) %s\n"
-				, command(), ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		m_client_connection.async_read_some(
-			sim::asio::buffer(m_out_buffer)
-			, std::bind(&socks_connection::on_client_receive, shared_from_this()
-				, _1, _2));
-	}
-
-	// we received some data from the server, forward it to the server
-	void socks_connection::on_server_receive(boost::system::error_code const& ec
-		, std::size_t bytes_transferred)
-	{
-		if (ec)
-		{
-			std::printf("socks_connection(%s): error reading from server: (%d) %s\n"
-				, command(), ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		asio::async_write(m_client_connection, asio::buffer(&m_in_buffer[0], bytes_transferred)
-			, std::bind(&socks_connection::on_server_forward, shared_from_this()
-				, _1, _2));
-	}
-
-	void socks_connection::on_server_forward(error_code const& ec
-		, size_t /* bytes_transferred */)
-	{
-		if (ec)
-		{
-			std::printf("socks_connection(%s): error writing to client: (%d) %s\n"
-				, command(), ec.value(), ec.message().c_str());
-			close_connection();
-			return;
-		}
-
-		m_server_connection.async_read_some(
-			sim::asio::buffer(m_in_buffer)
-			, std::bind(&socks_connection::on_server_receive, shared_from_this()
-				, _1, _2));
-	}
-
-	void socks_connection::close_connection()
-	{
-		error_code err;
-		m_client_connection.close(err);
-		if (err)
-		{
-			std::printf("socks_connection::close: failed to close client connection (%d) %s\n"
-				, err.value(), err.message().c_str());
-		}
-		m_server_connection.close(err);
-		if (err)
-		{
-			std::printf("socks_connection::close: failed to close server connection (%d) %s\n"
-				, err.value(), err.message().c_str());
-		}
-
-		m_bind_socket.close(err);
-		if (err)
-		{
-			std::printf("socks_connection::close: failed to close bind socket (%d) %s\n"
-				, err.value(), err.message().c_str());
-		}
-	}
-
-	char const* socks_connection::command() const
-	{
-		switch (m_command)
-		{
-			case 1: return "CONNECT";
-			case 2: return "BIND";
-			case 3: return "UDP_ASSOCIATE";
-			default: return "UNKNOWN";
-		}
-	}
-}
-
-
diff -Naupr a/simulation/libsimulator/src/tcp_socket.cpp b/simulation/libsimulator/src/tcp_socket.cpp
--- a/simulation/libsimulator/src/tcp_socket.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/tcp_socket.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,884 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/packet.hpp"
-#include "simulator/pcap.hpp"
-#include "simulator/handler_allocator.hpp"
-
-#include <functional>
-#include <cinttypes>
-#include <cstdio> // for printf
-
-#include "simulator/push_warnings.hpp"
-#include <boost/system/error_code.hpp>
-#include <boost/function.hpp>
-#include "simulator/pop_warnings.hpp"
-
-typedef sim::chrono::high_resolution_clock::time_point time_point;
-typedef sim::chrono::high_resolution_clock::duration duration;
-
-using namespace std::placeholders;
-
-namespace sim {
-namespace asio {
-namespace ip {
-
-	tcp::socket::socket(io_context& ios)
-		: socket_base(ios)
-		, m_connect_timer(ios)
-		, m_recv_timer(ios)
-	{}
-
-	tcp::socket::socket(socket&& s)
-		: socket_base(std::move(s))
-		, m_connect_handler(std::move(s.m_connect_handler))
-		, m_connect_timer(std::move(s.m_connect_timer))
-		, m_mss(s.m_mss)
-		, m_send_handler(std::move(s.m_send_handler))
-		, m_wait_send_handler(std::move(s.m_wait_send_handler))
-		, m_send_buffer(std::move(s.m_send_buffer))
-		, m_incoming_queue(std::move(s.m_incoming_queue))
-		, m_queue_size(std::move(s.m_queue_size))
-		, m_recv_handler(std::move(s.m_recv_handler))
-		, m_wait_recv_handler(std::move(s.m_wait_recv_handler))
-		, m_recv_buffer(std::move(s.m_recv_buffer))
-		, m_recv_timer(std::move(s.m_recv_timer))
-		, m_is_v4(std::move(s.m_is_v4))
-		, m_recv_null_buffers(std::move(s.m_recv_null_buffers))
-		, m_send_null_buffers(std::move(s.m_send_null_buffers))
-		, m_channel(std::move(s.m_channel))
-		, m_next_outgoing_seq(std::move(s.m_next_outgoing_seq))
-		, m_next_incoming_seq(std::move(s.m_next_incoming_seq))
-		, m_last_drop_seq(std::move(s.m_last_drop_seq))
-		, m_cwnd(std::move(s.m_cwnd))
-		, m_bytes_in_flight(std::move(s.m_bytes_in_flight))
-		, m_reorder_buffer(std::move(s.m_reorder_buffer))
-		, m_outstanding_packet_sizes(std::move(s.m_outstanding_packet_sizes))
-		, m_outgoing_packets(std::move(s.m_outgoing_packets))
-	{
-		if (m_forwarder) m_forwarder->reset(this);
-		s.m_forwarder.reset();
-		s.m_open = false;
-		s.m_bound_to = ip::tcp::endpoint();
-
-		if (m_bound_to != ip::tcp::endpoint())
-			m_io_service.rebind_socket(this, m_bound_to);
-	}
-
-	tcp::socket::~socket()
-	{
-		boost::system::error_code ec;
-
-		m_channel.reset();
-
-		if (m_bound_to != ip::tcp::endpoint())
-		{
-			m_io_service.unbind_socket(this, m_bound_to);
-			m_bound_to = ip::tcp::endpoint();
-			m_user_bound_to = ip::tcp::endpoint();
-		}
-		m_open = false;
-
-		// prevent any more packets from being delivered to this socket
-		if (m_forwarder)
-		{
-			m_forwarder->reset();
-			m_forwarder.reset();
-		}
-		cancel(ec);
-	}
-
-	void tcp::socket::open(tcp protocol, boost::system::error_code& ec) try
-	{
-		close(ec);
-		m_open = true;
-		m_is_v4 = (protocol == ip::tcp::v4());
-		ec.clear();
-		m_forwarder = std::make_shared<aux::sink_forwarder>(this);
-	}
-	catch (std::bad_alloc const&)
-	{
-		ec = make_error_code(boost::system::errc::not_enough_memory);
-	}
-	catch (boost::system::system_error const& err)
-	{
-		ec = err.code();
-	}
-
-	void tcp::socket::open(tcp protocol)
-	{
-		boost::system::error_code ec;
-		open(protocol, ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	// used to attach an incoming connection to this
-	void tcp::socket::internal_connect(tcp::endpoint const& bind_ip
-		, std::shared_ptr<aux::channel> const& c
-		, boost::system::error_code& ec)
-	{
-		open(m_is_v4 ? tcp::v4() : tcp::v6(), ec);
-		if (ec)
-		{
-			std::printf("tcp::socket::internal_connect() error: (%d) %s\n"
-				, ec.value(), ec.message().c_str());
-			return;
-		}
-		m_bound_to = bind_ip;
-		m_user_bound_to = bind_ip;
-		m_channel = c;
-		assert(m_forwarder);
-		c->hops[1].replace_last(m_forwarder);
-	}
-
-	void tcp::socket::bind(ip::tcp::endpoint const& ep
-		, boost::system::error_code& ec) try
-	{
-		if (!m_open)
-		{
-			ec = error::bad_descriptor;
-			return;
-		}
-
-		if (ep.address().is_v4() != m_is_v4)
-		{
-			ec = error::address_family_not_supported;
-			return;
-		}
-
-		ip::tcp::endpoint addr = m_io_service.bind_socket(this, ep, ec);
-		if (ec) return;
-		m_bound_to = addr;
-		m_user_bound_to = addr;
-	}
-	catch (std::bad_alloc const&)
-	{
-		ec = make_error_code(boost::system::errc::not_enough_memory);
-	}
-	catch (boost::system::system_error const& err)
-	{
-		ec = err.code();
-	}
-
-	void tcp::socket::bind(ip::tcp::endpoint const& ep)
-	{
-		boost::system::error_code ec;
-		bind(ep, ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	void tcp::socket::close()
-	{
-		boost::system::error_code ec;
-		close(ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	void tcp::socket::close(boost::system::error_code& ec) try
-	{
-		if (m_channel)
-		{
-			int const remote = m_channel->remote_idx(m_bound_to);
-			route hops = m_channel->hops[remote];
-
-			// if m_connect_handler is still set, it means the connection hasn't
-			// been established yet, and this channel points to the acceptor
-			// socket, not another open TCP connection.
-			if (!hops.empty() && !m_connect_handler)
-			{
-				aux::packet p;
-				p.type = aux::packet::type_t::error;
-				p.ec = asio::error::eof;
-				p.from = asio::ip::udp::endpoint(
-					m_bound_to.address(), m_bound_to.port());
-				p.overhead = 40;
-				p.hops = hops;
-				p.seq_nr = m_next_outgoing_seq++;
-				send_packet(std::move(p));
-			}
-			m_channel.reset();
-		}
-
-		if (m_bound_to != ip::tcp::endpoint())
-		{
-			m_io_service.unbind_socket(this, m_bound_to);
-			m_bound_to = ip::tcp::endpoint();
-			m_user_bound_to = ip::tcp::endpoint();
-		}
-		m_open = false;
-
-		// prevent any more packets from being delivered to this socket
-		if (m_forwarder)
-		{
-			m_forwarder->reset();
-			m_forwarder.reset();
-		}
-
-		// reset socket state
-		m_queue_size = 0;
-		m_mss = 1475;
-		m_cwnd = m_mss * 2;
-		m_bytes_in_flight = 0;
-		m_outstanding_packet_sizes.clear();
-		m_recv_null_buffers = false;
-		m_send_null_buffers = false;
-		m_next_incoming_seq = 0;
-		m_next_outgoing_seq = 0;
-		m_last_drop_seq = 0;
-
-		cancel(ec);
-
-		ec.clear();
-	}
-	catch (std::bad_alloc const&)
-	{
-		ec = make_error_code(boost::system::errc::not_enough_memory);
-	}
-	catch (boost::system::system_error const& err)
-	{
-		ec = err.code();
-	}
-
-	std::size_t tcp::socket::available(boost::system::error_code& ec) const
-	{
-		if (!m_open)
-		{
-			ec = boost::system::error_code(error::bad_descriptor);
-			return 0;
-		}
-		if (!m_channel)
-		{
-			ec = boost::system::error_code(error::not_connected);
-			return 0;
-		}
-		if (m_incoming_queue.empty())
-		{
-			return 0;
-		}
-
-		std::size_t ret = 0;
-		for (aux::packet const& p : m_incoming_queue)
-		{
-			if (p.type == aux::packet::type_t::error)
-			{
-				if (ret > 0) return ret;
-
-				// if the read buffer is drained and there is an error, report that
-				// error.
-				ec = p.ec;
-				return 0;
-			}
-			ret += p.buffer.size();
-		}
-		return ret;
-	}
-
-	std::size_t tcp::socket::available() const
-	{
-		boost::system::error_code ec;
-		std::size_t ret = available(ec);
-		if (ec) throw boost::system::system_error(ec);
-		return ret;
-	}
-
-	void tcp::socket::cancel(boost::system::error_code&)
-	{
-		abort_recv_handlers();
-		abort_send_handlers();
-
-		if (m_connect_handler)
-		{
-			post(m_io_service, aux::make_malloc(std::bind(std::move(m_connect_handler)
-				, boost::system::error_code(error::operation_aborted))));
-			m_connect_handler = nullptr;
-		}
-	}
-
-	void tcp::socket::cancel()
-	{
-		boost::system::error_code ec;
-		cancel(ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	tcp::endpoint tcp::socket::remote_endpoint(boost::system::error_code& ec) const
-	{
-		if (!m_open)
-		{
-			ec = error::bad_descriptor;
-			return tcp::endpoint();
-		}
-
-		if (!m_channel)
-		{
-			ec = error::not_connected;
-			return tcp::endpoint();
-		}
-
-		int const remote = m_channel->remote_idx(m_bound_to);
-		return m_channel->visible_ep[remote];
-	}
-
-	tcp::endpoint tcp::socket::remote_endpoint() const
-	{
-		boost::system::error_code ec;
-		tcp::endpoint ret = remote_endpoint(ec);
-		if (ec) throw boost::system::system_error(ec);
-		return ret;
-	}
-
-	void tcp::socket::async_connect(tcp::endpoint const& target
-		, aux::function<void(boost::system::error_code const&)> h)
-	{
-		if (!m_open) open(target.protocol());
-
-		assert(h);
-		assert(!m_connect_handler);
-
-		// find remote socket
-		boost::system::error_code ec;
-		if (m_bound_to.address() == ip::address())
-		{
-			auto endpoint = ip::tcp::endpoint();
-			if (target.address().is_v4()) {
-				endpoint.address(ip::address_v4::any());
-			} else {
-				endpoint.address(ip::address_v6::any());
-			}
-			ip::tcp::endpoint addr = m_io_service.bind_socket(this
-				, endpoint, ec);
-			if (ec)
-			{
-				post(m_io_service, aux::make_malloc(std::bind(std::move(h), ec)));
-				return;
-			}
-			m_bound_to = addr;
-			m_user_bound_to = addr;
-		}
-		if (m_bound_to.address().is_v4() != target.address().is_v4())
-		{
-			post(m_io_service, aux::make_malloc(std::bind(std::move(h),
-				boost::system::error_code(error::address_family_not_supported))));
-			return;
-		}
-		m_channel = m_io_service.internal_connect(this, target, ec);
-		m_mss = m_io_service.get_path_mtu(m_bound_to.address(), target.address());
-		m_cwnd = m_mss * 2;
-		if (ec)
-		{
-			m_channel.reset();
-			// TODO: ask the policy object what the round-trip to this endpoint is
-			m_connect_timer.expires_after(chrono::milliseconds(50));
-			m_connect_timer.async_wait(aux::make_malloc(std::bind(std::move(h), ec)));
-			return;
-		}
-
-		m_connect_handler = std::move(h);
-
-		// the acceptor socket will call internal_connect_complete once the
-		// connection is established
-	}
-
-	void tcp::socket::abort_recv_handlers()
-	{
-		if (m_recv_handler) post(m_io_service, aux::make_malloc(std::bind(std::move(m_recv_handler)
-			, boost::system::error_code(error::operation_aborted), std::size_t(0))));
-
-		if (m_wait_recv_handler) post(m_io_service, aux::make_malloc(std::bind(std::move(m_wait_recv_handler)
-			, boost::system::error_code(error::operation_aborted))));
-
-		m_recv_timer.cancel();
-		m_recv_handler = nullptr;
-		m_wait_recv_handler = nullptr;
-		m_recv_buffer.clear();
-		m_recv_null_buffers = false;
-	}
-
-	void tcp::socket::abort_send_handlers()
-	{
-		if (m_send_handler) post(m_io_service, aux::make_malloc(std::bind(std::move(m_send_handler)
-			, boost::system::error_code(error::operation_aborted), std::size_t(0))));
-
-		if (m_wait_send_handler) post(m_io_service, aux::make_malloc(std::bind(std::move(m_wait_send_handler)
-			, boost::system::error_code(error::operation_aborted))));
-
-		m_send_handler = nullptr;
-		m_wait_send_handler = nullptr;
-		m_send_buffer.clear();
-		m_send_null_buffers = false;
-	}
-
-	void tcp::socket::async_write_some_impl(std::vector<boost::asio::const_buffer> const& bufs
-		, aux::function<void(boost::system::error_code const&, std::size_t)> handler)
-	{
-		int buf_size = 0;
-		for (int i = 0; i < int(bufs.size()); ++i)
-			buf_size += int(bufs[i].size());
-
-		boost::system::error_code ec;
-		std::size_t const bytes_transferred = write_some_impl(bufs, ec);
-		if (ec == boost::system::error_code(error::would_block))
-		{
-			m_send_handler = std::move(handler);
-			m_send_buffer = bufs;
-			return;
-		}
-
-		if (ec)
-		{
-			post(m_io_service, aux::make_malloc(std::bind(std::move(handler), ec, std::size_t(0))));
-			m_send_handler = nullptr;
-			m_send_buffer.clear();
-			return;
-		}
-
-		boost::system::error_code no_error;
-		post(m_io_service, aux::make_malloc(std::bind(std::move(handler), no_error
-			, bytes_transferred)));
-		m_send_handler = nullptr;
-		m_send_buffer.clear();
-	}
-
-	std::size_t tcp::socket::write_some_impl(
-		std::vector<boost::asio::const_buffer> const& bufs
-		, boost::system::error_code& ec)
-	{
-		if (!m_open)
-		{
-			ec = boost::system::error_code(error::bad_descriptor);
-			return 0;
-		}
-		if (!m_channel)
-		{
-			ec = boost::system::error_code(error::not_connected);
-			return 0;
-		}
-
-		// the connect handler is used as proxy that this socket has not competed
-		// the connection yet. We're still waiting for SYN+ACK
-		if (m_connect_handler)
-		{
-			ec = boost::system::error_code(error::would_block);
-			return 0;
-		}
-
-		int const remote = m_channel->remote_idx(m_bound_to);
-		route hops = m_channel->hops[remote];
-		if (hops.empty())
-		{
-			ec = boost::system::error_code(error::not_connected);
-			return 0;
-		}
-
-		if (m_bytes_in_flight + m_mss > m_cwnd)
-		{
-			// this indicates that the send buffer is very large, we should
-			// probably not be able to stuff more bytes down it
-			// wait for the receiving end to pop some bytes off
-			ec = boost::system::error_code(error::would_block);
-			return 0;
-		}
-
-		std::size_t ret = 0;
-
-		for (auto const& buf : bufs)
-		{
-			// split up in packets
-			int buf_size = int(buf.size());
-			std::uint8_t const* ptr = static_cast<std::uint8_t const*>(buf.data());
-			while (buf_size > 0)
-			{
-				int packet_size = (std::min)(buf_size, m_mss);
-				aux::packet p;
-				p.type = aux::packet::type_t::payload;
-				p.buffer.assign(ptr, ptr + packet_size);
-				p.from = asio::ip::udp::endpoint(
-					m_bound_to.address(), m_bound_to.port());
-				p.overhead = 40;
-				p.hops = hops;
-				p.seq_nr = m_next_outgoing_seq++;
-				p.drop_fun = std::bind(&tcp::socket::packet_dropped, this, _1);
-
-				send_packet(std::move(p));
-				ptr += packet_size;
-				buf_size -= packet_size;
-				ret += packet_size;
-
-				if (m_bytes_in_flight + m_mss > m_cwnd)
-				{
-					// the congestion window is full
-					if (ret == 0)
-					{
-						ec = boost::system::error_code(error::would_block);
-						return 0;
-					}
-
-					return ret;
-				}
-			}
-		}
-
-		return ret;
-	}
-
-	std::size_t tcp::socket::read_some_impl(
-		std::vector<boost::asio::mutable_buffer> const& bufs
-		, boost::system::error_code& ec)
-	{
-		assert(!bufs.empty());
-		if (!m_open)
-		{
-			ec = boost::system::error_code(error::bad_descriptor);
-			return 0;
-		}
-		if (!m_channel)
-		{
-			ec = boost::system::error_code(error::not_connected);
-			return 0;
-		}
-		if (m_connect_handler)
-		{
-			// the socket is not done connecting yet
-			ec = boost::system::error_code(error::would_block);
-			return 0;
-		}
-
-		if (m_incoming_queue.empty())
-		{
-			ec = boost::system::error_code(error::would_block);
-			return 0;
-		}
-
-		typedef std::vector<boost::asio::mutable_buffer> buffers_t;
-		m_recv_buffer = bufs;
-		buffers_t::iterator recv_iter = m_recv_buffer.begin();
-		int total_received = 0;
-		// the offset in the current receive buffer we're writing to. i.e. the
-		// buffer recv_iter points to
-		int buf_offset = 0;
-
-		while (!m_incoming_queue.empty())
-		{
-			aux::packet& p = m_incoming_queue.front();
-
-			if (p.type == aux::packet::type_t::error)
-			{
-				// if we have received bytes also, first deliver those. In the next
-				// read, deliver the error
-				if (total_received > 0) break;
-
-				assert(p.ec);
-				ec = p.ec;
-				m_incoming_queue.erase(m_incoming_queue.begin());
-				m_channel.reset();
-				return 0;
-			}
-			else if (p.type == aux::packet::type_t::payload)
-			{
-				// copy bytes from the incoming queue into the receive buffer.
-				// both are vectors of buffer, so it can get a bit hairy
-				while (recv_iter != m_recv_buffer.end())
-				{
-					int const buf_size = int(recv_iter->size());
-					int const copy_size = (std::min)(int(p.buffer.size())
-						, buf_size - buf_offset);
-
-					memcpy(static_cast<char*>(recv_iter->data()) + buf_offset
-						, p.buffer.data(), copy_size);
-
-					p.buffer.erase(p.buffer.begin(), p.buffer.begin() + copy_size);
-					m_queue_size -= copy_size;
-
-					buf_offset += copy_size;
-					assert(buf_offset <= buf_size);
-					total_received += copy_size;
-					if (buf_offset == buf_size)
-					{
-						++recv_iter;
-						buf_offset = 0;
-					}
-
-					if (p.buffer.empty())
-					{
-						m_incoming_queue.erase(m_incoming_queue.begin());
-						break;
-					}
-				}
-			}
-			else
-			{
-				assert(false);
-			}
-
-			if (recv_iter == m_recv_buffer.end())
-				break;
-		}
-
-		assert(total_received > 0);
-
-		ec.clear();
-		return total_received;
-	}
-
-	void tcp::socket::async_read_some_impl(std::vector<boost::asio::mutable_buffer> const& bufs
-		, aux::function<void(boost::system::error_code const&, std::size_t)> handler)
-	{
-		assert(!bufs.empty());
-		assert(bufs[0].size());
-
-		boost::system::error_code ec;
-		std::size_t bytes_transferred = read_some_impl(bufs, ec);
-		if (ec == boost::system::error_code(error::would_block))
-		{
-			assert(m_incoming_queue.empty());
-
-			m_recv_buffer = bufs;
-			m_recv_handler = std::move(handler);
-			m_recv_null_buffers = false;
-			return;
-		}
-
-		if (ec)
-		{
-			post(m_io_service, aux::make_malloc(std::bind(std::move(handler), ec, std::size_t(0))));
-			m_recv_handler = nullptr;
-			m_recv_buffer.clear();
-			return;
-		}
-
-		post(m_io_service, aux::make_malloc(std::bind(std::move(handler), ec, bytes_transferred)));
-		m_recv_handler = nullptr;
-		m_recv_buffer.clear();
-	}
-
-	void tcp::socket::async_wait_read_impl(
-		aux::function<void(boost::system::error_code const&)> handler)
-	{
-		boost::system::error_code ec;
-		// null_buffers notifies the handler when data is available, without
-		// reading any
-		int const bytes = int(available(ec));
-		if (ec)
-		{
-			post(m_io_service, aux::make_malloc(std::bind(std::move(handler), ec)));
-			m_recv_handler = nullptr;
-			m_recv_buffer.clear();
-			return;
-		}
-
-		if (bytes > 0)
-		{
-			post(m_io_service, aux::make_malloc(std::bind(std::move(handler), ec)));
-			m_recv_handler = nullptr;
-			m_recv_buffer.clear();
-			return;
-		}
-
-		m_wait_recv_handler = std::move(handler);
-		m_recv_null_buffers = true;
-	}
-
-	// if there is an outstanding read operation, and this was the first incoming
-	// operation since we last drained, wake up the reader
-	void tcp::socket::maybe_wakeup_reader()
-	{
-		if (m_incoming_queue.size() != 1 || (!m_recv_handler && !m_wait_recv_handler)) return;
-
-		if (m_recv_null_buffers)
-		{
-			async_wait_read_impl(std::move(m_wait_recv_handler));
-		}
-		else
-		{
-			// we have an async. read operation outstanding, and we just put one
-			// packet in our incoming queue.
-
-			// try to read from it and potentially fire the handler
-			async_read_some_impl(m_recv_buffer, std::move(m_recv_handler));
-		}
-	}
-
-	void tcp::socket::maybe_wakeup_writer()
-	{
-		if (!m_send_handler) return;
-
-		if (m_send_null_buffers)
-		{
-			assert(false && "not supported yet");
-//			async_wait_write_impl(m_recv_handler);
-		}
-		else
-		{
-			// we have an async. write operation outstanding
-			async_write_some_impl(m_send_buffer, std::move(m_send_handler));
-		}
-	}
-
-	bool tcp::socket::internal_is_listening() { return false; }
-
-	void tcp::socket::send_packet(aux::packet p)
-	{
-		m_bytes_in_flight += int(p.buffer.size());
-		m_outstanding_packet_sizes[p.seq_nr] = int(p.buffer.size());
-
-		int const idx = m_channel->self_idx(m_bound_to);
-		p.byte_counter = m_channel->bytes_sent[idx];
-		m_channel->bytes_sent[idx] += std::uint32_t(p.buffer.size());
-
-		auto* log = m_io_service.sim().get_pcap();
-		if (log)
-		{
-			int const remote = m_channel->remote_idx(m_bound_to);
-			log->log_tcp(p, m_bound_to, m_channel->ep[remote]);
-		}
-
-		forward_packet(std::move(p));
-	}
-
-	void tcp::socket::packet_dropped(aux::packet p)
-	{
-		int remote = m_channel->remote_idx(m_bound_to);
-		p.hops = m_channel->hops[remote];
-		m_outgoing_packets.push_back(std::move(p));
-
-		const int packets_in_cwnd = m_cwnd / m_mss;
-
-		// we just recently dropped a packet and cut the cwnd in half,
-		// don't do it again already
-		if (m_last_drop_seq > 0 && p.seq_nr < m_last_drop_seq + packets_in_cwnd) return;
-
-		m_cwnd /= 2;
-		m_last_drop_seq = p.seq_nr;
-
-		// TODO: this should really happen one second later to be accurate
-		if (m_cwnd < m_mss) m_cwnd = m_mss;
-	}
-
-	void tcp::socket::incoming_packet(aux::packet p)
-	{
-		switch (p.type)
-		{
-			case aux::packet::type_t::uninitialized:
-			{
-				assert(false && "uninitialized packet");
-				return;
-			}
-			case aux::packet::type_t::ack:
-			{
-				// if the socket just became writeable, we need to notify the
-				// client. First we want to know whether it was not writeable.
-				const bool was_writeable = m_bytes_in_flight + m_mss > m_cwnd;
-
-				auto it = m_outstanding_packet_sizes.find(p.seq_nr);
-				assert(it != m_outstanding_packet_sizes.end());
-				const int acked_bytes = it->second;
-				m_outstanding_packet_sizes.erase(it);
-				assert(m_bytes_in_flight >= acked_bytes);
-				m_bytes_in_flight -= acked_bytes;
-
-				// potentially resend packets
-				while (!m_outgoing_packets.empty()
-					&& m_bytes_in_flight
-						+ int(m_outgoing_packets.front().buffer.size()) <= m_cwnd)
-				{
-					aux::packet pkt = std::move(m_outgoing_packets.front());
-					m_outgoing_packets.erase(m_outgoing_packets.begin());
-					send_packet(std::move(pkt));
-				}
-
-				// update cwnd based on the number of bytes ACKed.
-				// every round-trip, increase the window size by one packet
-				// (MSS)
-				m_cwnd += m_mss * acked_bytes / m_cwnd;
-
-				// TODO: implement slow-start
-
-				const bool is_writeable = m_bytes_in_flight + m_mss <= m_cwnd;
-
-				if (!was_writeable && is_writeable)
-					maybe_wakeup_writer();
-
-				return;
-			}
-			case aux::packet::type_t::syn:
-			{
-				// TODO: return connection refused
-				return;
-			}
-			case aux::packet::type_t::syn_ack:
-			{
-				assert(m_connect_handler);
-				boost::system::error_code ec;
-				post(m_io_service, aux::make_malloc(std::bind(std::move(m_connect_handler), ec)));
-				m_connect_handler = nullptr;
-				if (ec) m_channel.reset();
-				else maybe_wakeup_writer();
-				return;
-			}
-			case aux::packet::type_t::error:
-			case aux::packet::type_t::payload:
-			{
-				aux::packet ack;
-				ack.type = aux::packet::type_t::ack;
-				ack.seq_nr = p.seq_nr;
-
-				int remote = m_channel->remote_idx(m_bound_to);
-				ack.hops = m_channel->hops[remote];
-				forward_packet(std::move(ack));
-
-				// if the sequence number is out-of-order, put it in the
-				// m_incoming_packets queue
-				if (p.seq_nr != m_next_incoming_seq)
-				{
-					if (p.seq_nr < m_next_incoming_seq)
-					{
-						std::printf("TCP: incoming sequence number lower (%" PRId64 ") "
-							"than expected: %" PRId64 "\n", p.seq_nr, m_next_incoming_seq);
-					}
-
-					m_reorder_buffer.emplace(p.seq_nr, std::move(p));
-					return;
-				}
-
-				// this packet was in-order. increment the expected next sequence
-				// number.
-				++m_next_incoming_seq;
-				m_incoming_queue.push_back(std::move(p));
-
-				// also, perhaps there are some packets that arrived out-of-order,
-				// check to see
-				auto it = m_reorder_buffer.find(m_next_incoming_seq);
-				while (it != m_reorder_buffer.end())
-				{
-					aux::packet pkt = std::move(it->second);
-					m_reorder_buffer.erase(it);
-					m_incoming_queue.push_back(std::move(pkt));
-					++m_next_incoming_seq;
-					it = m_reorder_buffer.find(m_next_incoming_seq);
-				}
-
-				maybe_wakeup_reader();
-				return;
-			}
-		}
-	}
-}
-}
-}
-
diff -Naupr a/simulation/libsimulator/src/udp_socket.cpp b/simulation/libsimulator/src/udp_socket.cpp
--- a/simulation/libsimulator/src/udp_socket.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/libsimulator/src/udp_socket.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,497 +0,0 @@
-/*
-
-Copyright (c) 2015, Arvid Norberg
-All rights reserved.
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "simulator/simulator.hpp"
-#include "simulator/packet.hpp"
-#include "simulator/pcap.hpp"
-#include "simulator/handler_allocator.hpp"
-
-#include <functional>
-
-#include "simulator/push_warnings.hpp"
-#include <boost/system/error_code.hpp>
-#include <boost/function.hpp>
-#include "simulator/pop_warnings.hpp"
-
-typedef sim::chrono::high_resolution_clock::time_point time_point;
-typedef sim::chrono::high_resolution_clock::duration duration;
-
-namespace sim {
-namespace asio {
-namespace ip {
-
-	udp::socket::socket(io_context& ios)
-		: socket_base(ios)
-		, m_next_send(chrono::high_resolution_clock::now())
-		, m_recv_sender(nullptr)
-		, m_recv_timer(ios)
-		, m_send_timer(ios)
-		, m_recv_null_buffers(0)
-		, m_queue_size(0)
-		, m_is_v4(true)
-	{}
-
-	udp::socket::socket(socket&& s)
-		: socket_base(std::move(s))
-		, m_next_send(std::move(s.m_next_send))
-		, m_send_handler(std::move(s.m_send_handler))
-		, m_wait_send_handler(std::move(s.m_wait_send_handler))
-		, m_recv_handler(std::move(s.m_recv_handler))
-		, m_wait_recv_handler(std::move(s.m_wait_recv_handler))
-		, m_recv_buffer(std::move(s.m_recv_buffer))
-		, m_recv_sender(std::move(s.m_recv_sender))
-		, m_recv_timer(std::move(s.m_recv_timer))
-		, m_send_timer(std::move(s.m_send_timer))
-		, m_incoming_queue(std::move(s.m_incoming_queue))
-		, m_recv_null_buffers(std::move(s.m_recv_null_buffers))
-		, m_queue_size(std::move(s.m_queue_size))
-		, m_is_v4(s.m_is_v4)
-	{
-		if (m_forwarder) m_forwarder->reset(this);
-		s.m_forwarder.reset();
-		s.m_open = false;
-		s.m_bound_to = ip::udp::endpoint();
-		if (m_bound_to != ip::udp::endpoint())
-			m_io_service.rebind_udp_socket(this, m_bound_to);
-	}
-
-	udp::socket::~socket()
-	{
-		boost::system::error_code ec;
-		close(ec);
-	}
-
-	void udp::socket::bind(ip::udp::endpoint const& ep
-		, boost::system::error_code& ec) try
-	{
-		if (!m_open)
-		{
-			ec = error::bad_descriptor;
-			return;
-		}
-
-		if (ep.address().is_v4() != m_is_v4)
-		{
-			ec = error::address_family_not_supported;
-			return;
-		}
-
-		ip::udp::endpoint addr = m_io_service.bind_udp_socket(this, ep, ec);
-		if (ec) return;
-		m_bound_to = addr;
-		m_user_bound_to = addr;
-	}
-	catch (std::bad_alloc const&)
-	{
-		ec = make_error_code(boost::system::errc::not_enough_memory);
-	}
-	catch (boost::system::system_error const& err)
-	{
-		ec = err.code();
-	}
-
-	void udp::socket::bind(ip::udp::endpoint const& ep)
-	{
-		boost::system::error_code ec;
-		bind(ep, ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	void udp::socket::open(udp protocol
-		, boost::system::error_code& ec) try
-	{
-		// TODO: what if it's already open?
-		close(ec);
-		m_open = true;
-		m_is_v4 = (protocol == ip::udp::v4());
-		m_forwarder = std::make_shared<aux::sink_forwarder>(this);
-	}
-	catch (std::bad_alloc const&)
-	{
-		ec = make_error_code(boost::system::errc::not_enough_memory);
-	}
-	catch (boost::system::system_error const& err)
-	{
-		ec = err.code();
-	}
-
-	void udp::socket::open(udp protocol)
-	{
-		boost::system::error_code ec;
-		open(protocol, ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	void udp::socket::close()
-	{
-		boost::system::error_code ec;
-		close(ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	void udp::socket::close(boost::system::error_code& ec) try
-	{
-		if (m_bound_to != ip::udp::endpoint())
-		{
-			m_io_service.unbind_udp_socket(this, m_bound_to);
-			m_bound_to = ip::udp::endpoint();
-			m_user_bound_to = ip::udp::endpoint();
-		}
-		m_open = false;
-
-		// prevent any more packets from being delivered to this socket
-		if (m_forwarder)
-		{
-			m_forwarder->reset();
-			m_forwarder.reset();
-		}
-
-		cancel(ec);
-	}
-	catch (std::bad_alloc const&)
-	{
-		ec = make_error_code(boost::system::errc::not_enough_memory);
-	}
-	catch (boost::system::system_error const& err)
-	{
-		ec = err.code();
-	}
-
-	void udp::socket::cancel(boost::system::error_code&)
-	{
-		// cancel outstanding async operations
-		abort_recv_handlers();
-		abort_send_handlers();
-		m_recv_timer.cancel();
-		m_send_timer.cancel();
-		return;
-	}
-
-	void udp::socket::cancel()
-	{
-		boost::system::error_code ec;
-		cancel(ec);
-		if (ec) throw boost::system::system_error(ec);
-	}
-
-	void udp::socket::abort_send_handlers()
-	{
-		if (m_send_handler)
-			post(m_io_service, make_malloc(std::bind(std::ref(m_send_handler)
-				, boost::system::error_code(error::operation_aborted), std::size_t(0))));
-
-		if (m_wait_send_handler)
-			post(m_io_service, make_malloc(std::bind(std::ref(m_wait_send_handler)
-				, boost::system::error_code(error::operation_aborted))));
-
-		m_send_timer.cancel();
-		m_send_handler = nullptr;
-		m_wait_send_handler = nullptr;
-//		m_send_buffer.clear();
-	}
-
-	void udp::socket::abort_recv_handlers()
-	{
-		if (m_recv_handler)
-			post(m_io_service, make_malloc(std::bind(std::move(m_recv_handler)
-				, boost::system::error_code(error::operation_aborted), std::size_t(0))));
-
-		if (m_wait_recv_handler)
-			post(m_io_service, make_malloc(std::bind(std::move(m_wait_recv_handler)
-				, boost::system::error_code(error::operation_aborted))));
-
-		m_recv_timer.cancel();
-		m_recv_handler = nullptr;
-		m_wait_recv_handler = nullptr;
-		m_recv_buffer.clear();
-	}
-
-	void udp::socket::async_wait(socket_base::wait_type_t const w
-		, aux::function<void(boost::system::error_code const&)> handler)
-	{
-		if (w == wait_type_t::wait_write)
-		{
-			abort_send_handlers();
-
-			// TODO: make the send buffer size configurable
-			time_point const now = chrono::high_resolution_clock::now();
-			boost::system::error_code no_error;
-			if (m_next_send - now > chrono::milliseconds(1000))
-			{
-				// our send queue is too large. Defer
-				m_recv_timer.expires_at(m_next_send - chrono::milliseconds(1000) / 2);
-
-				m_wait_send_handler = std::move(handler);
-				m_recv_timer.async_wait(make_malloc(std::bind(std::ref(m_wait_send_handler), no_error)));
-				return;
-			}
-
-			// the socket is writable, post the completion handler immediately
-			post(m_io_service, make_malloc(std::bind(std::move(handler), no_error)));
-		}
-		else if (w == wait_type_t::wait_read)
-		{
-			abort_recv_handlers();
-			async_wait_receive_impl(nullptr, std::move(handler));
-		}
-	}
-
-	std::size_t udp::socket::receive_from_impl(
-		std::vector<asio::mutable_buffer> const& bufs
-		, udp::endpoint* sender
-		, socket_base::message_flags /* flags */
-		, boost::system::error_code& ec)
-	{
-		assert(!bufs.empty());
-		if (!m_open)
-		{
-			ec = boost::system::error_code(error::bad_descriptor);
-			return 0;
-		}
-
-		if (m_bound_to == udp::endpoint())
-		{
-			ec = boost::system::error_code(error::invalid_argument);
-			return 0;
-		}
-
-		if (m_incoming_queue.empty())
-		{
-			ec = boost::system::error_code(error::would_block);
-			return 0;
-		}
-
-		aux::packet& p = m_incoming_queue.front();
-		if (sender) *sender = p.from;
-
-		int read = 0;
-		for (auto const& buf : bufs)
-		{
-			char* ptr = static_cast<char*>(buf.data());
-			int const len = int(buf.size());
-			int const to_copy = (std::min)(int(p.buffer.size()), len);
-			memcpy(ptr, p.buffer.data(), to_copy);
-			read += to_copy;
-			p.buffer.erase(p.buffer.begin(), p.buffer.begin() + to_copy);
-			m_queue_size -= to_copy;
-			if (p.buffer.empty()) break;
-		}
-
-		m_incoming_queue.erase(m_incoming_queue.begin());
-		return read;
-	}
-
-	void udp::socket::async_wait_receive_impl(
-		udp::endpoint* sender
-		, aux::function<void(boost::system::error_code const&)> handler)
-	{
-		if (!m_open)
-		{
-			post(m_io_service, make_malloc(std::bind(std::move(handler)
-				, boost::system::error_code(error::bad_descriptor))));
-			return;
-		}
-
-		if (m_bound_to == udp::endpoint())
-		{
-			post(m_io_service, make_malloc(std::bind(std::move(handler)
-				, boost::system::error_code(error::invalid_argument))));
-			return;
-		}
-
-		if (!m_incoming_queue.empty())
-		{
-			post(m_io_service, make_malloc(std::bind(std::move(handler), boost::system::error_code())));
-			return;
-		}
-
-		m_recv_null_buffers = true;
-		m_wait_recv_handler = std::move(handler);
-		m_recv_sender = sender;
-	}
-
-	void udp::socket::async_receive_from_impl(
-		std::vector<asio::mutable_buffer> const& bufs
-		, udp::endpoint* sender
-		, socket_base::message_flags /* flags */
-		, aux::function<void(boost::system::error_code const&
-			, std::size_t)> handler)
-	{
-		assert(!bufs.empty());
-
-		boost::system::error_code ec;
-		std::size_t bytes_transferred = receive_from_impl(bufs, sender, 0, ec);
-		if (ec == boost::system::error_code(error::would_block))
-		{
-			m_recv_buffer = bufs;
-			m_recv_handler = std::move(handler);
-			m_recv_sender = sender;
-			m_recv_null_buffers = false;
-
-			return;
-		}
-
-		if (ec)
-		{
-			post(m_io_service, make_malloc(std::bind(std::move(handler), ec, std::size_t(0))));
-			m_recv_handler = nullptr;
-			m_recv_buffer.clear();
-			m_recv_sender = nullptr;
-			m_recv_null_buffers = false;
-			return;
-		}
-
-		post(m_io_service, make_malloc(std::bind(std::move(handler), ec, bytes_transferred)));
-		m_recv_handler = nullptr;
-		m_recv_buffer.clear();
-		m_recv_sender = nullptr;
-		m_recv_null_buffers = false;
-	}
-
-	std::size_t udp::socket::send_to_impl(std::vector<asio::const_buffer> const& b
-		, udp::endpoint const& dst, message_flags /* flags */
-		, boost::system::error_code& ec)
-	{
-		assert(m_non_blocking && "blocking operations not supported");
-
-		if (m_bound_to == ip::udp::endpoint())
-		{
-			// the socket was not bound, bind to anything
-			bind(udp::endpoint(), ec);
-			if (ec) return 0;
-		}
-
-		ec.clear();
-		std::size_t ret = 0;
-		for (std::vector<asio::const_buffer>::const_iterator i = b.begin()
-			, end(b.end()); i != end; ++i)
-		{
-			ret += i->size();
-		}
-		if (ret == 0)
-		{
-			ec = boost::system::error_code(error::invalid_argument);
-			return 0;
-		}
-
-		time_point now = chrono::high_resolution_clock::now();
-
-		// this is outgoing NIC bandwidth
-		// TODO: make this configurable
-		const int bandwidth = 100000000; // 100 MB/s
-		const int mtu = m_io_service.get_path_mtu(m_bound_to.address(), dst.address());
-
-		if (int(ret) > 65535)
-		{
-			ec = boost::system::error_code(error::message_size);
-			return 0;
-		}
-
-		if (m_dont_fragment && int(ret) > mtu)
-		{
-			// silently drop packet
-			ec.clear();
-			return ret;
-		}
-
-		// determine the bandwidth in terms of nanoseconds / byte
-		const double nanoseconds_per_byte = 1000000000.0
-			/ double(bandwidth);
-
-		// TODO: make the send buffer size configurable
-		if (m_next_send - now > chrono::milliseconds(500))
-		{
-			// our send queue is too large.
-			ec = boost::system::error_code(asio::error::would_block);
-			return 0;
-		}
-
-		route hops = m_io_service.find_udp_socket(*this, dst);
-		if (hops.empty())
-		{
-			// the packet is silently dropped
-			// TODO: it would be nice if this would result in a round-trip time
-			// with an ICMP host unreachable or connection_refused error
-			return ret;
-		}
-
-		hops.prepend(m_io_service.get_outgoing_route(m_bound_to.address()));
-
-		m_next_send = std::max(now, m_next_send);
-
-		aux::packet p;
-		p.overhead = 28;
-		p.type = aux::packet::type_t::payload;
-		p.from = m_bound_to;
-		p.hops = hops;
-		for (std::vector<asio::const_buffer>::const_iterator i = b.begin()
-			, end(b.end()); i != end; ++i)
-		{
-			p.buffer.insert(p.buffer.end(), static_cast<std::uint8_t const*>(i->data())
-				, static_cast<std::uint8_t const*>(i->data()) + i->size());
-		}
-
-		auto* log = m_io_service.sim().get_pcap();
-		if (log) log->log_udp(p, m_bound_to, dst);
-
-		int const packet_size = int(p.buffer.size() + p.overhead);
-		forward_packet(std::move(p));
-
-		m_next_send += chrono::duration_cast<duration>(chrono::nanoseconds(
-			boost::int64_t(nanoseconds_per_byte * packet_size)));
-
-		return ret;
-	}
-
-	void udp::socket::incoming_packet(aux::packet p)
-	{
-		int const packet_size = int(p.buffer.size() + p.overhead);
-
-		// silent drop. If the application isn't reading fast enough, drop packets
-		// TODO: make this limit controlled by SO_RECVBUF socket option
-		if (m_queue_size + packet_size > 256 * 1024) return;
-
-		m_queue_size += int(p.buffer.size());
-		m_incoming_queue.push_back(std::move(p));
-
-		maybe_wakeup_reader();
-	}
-
-	void udp::socket::maybe_wakeup_reader()
-	{
-		if (m_incoming_queue.size() != 1 || (!m_recv_handler && !m_wait_recv_handler)) return;
-
-		// there is an outstanding operation waiting for an incoming packet
-		if (m_recv_null_buffers)
-		{
-			async_wait_receive_impl(m_recv_sender, std::move(m_wait_recv_handler));
-		}
-		else
-		{
-			async_receive_from_impl(m_recv_buffer, m_recv_sender, 0, std::move(m_recv_handler));
-		}
-
-//		m_recv_handler = nullptr;
-//		m_recv_buffer.clear();
-//		m_recv_sender = nullptr;
-	}
-
-} // ip
-} // asio
-} // sim
-
diff -Naupr a/simulation/test_file_pool.cpp b/simulation/test_file_pool.cpp
--- a/simulation/test_file_pool.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/simulation/test_file_pool.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,138 @@
+/*
+
+Copyright (c) 2008, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "setup_swarm.hpp"
+#include "test.hpp"
+#include "utils.hpp"
+#include "libtorrent/alert.hpp"
+#include "libtorrent/alert_types.hpp"
+#include "libtorrent/session.hpp"
+#include "libtorrent/session_stats.hpp"
+#include "libtorrent/torrent_info.hpp"
+#include "libtorrent/disk_interface.hpp"
+
+using namespace lt;
+
+// the disk I/O thread is not simulated with high enough fidelity for this to
+// work
+TORRENT_TEST(close_file_interval)
+{
+	bool ran_to_completion = false;
+
+	// with seed mode
+	setup_swarm(2, swarm_test::download
+		// add session
+		, [](lt::settings_pack& pack) {
+			pack.set_int(settings_pack::close_file_interval, 20);
+		}
+		// add torrent
+		, [](lt::add_torrent_params&) {}
+		// on alert
+		, [](lt::alert const* a, lt::session& ses) {}
+		// terminate
+		, [&](int ticks, lt::session& ses) -> bool
+		{
+			// terminate after 40 seconds
+			if (ticks > 24)
+			{
+				ran_to_completion = true;
+				return true;
+			}
+
+			torrent_handle h = ses.get_torrents().front();
+			std::vector<open_file_state> const file_status = h.file_status();
+			printf("%d: %d files\n", ticks, int(file_status.size()));
+			if (ticks > 0 && ticks < 19)
+			{
+				TEST_EQUAL(file_status.size(), 1);
+			}
+			else if (ticks > 21)
+			{
+				// the close file timer shuold have kicked in at 20 seconds
+				// and closed the file
+				TEST_EQUAL(file_status.size(), 0);
+			}
+			return false;
+		});
+	TEST_CHECK(ran_to_completion);
+}
+
+TORRENT_TEST(file_pool_size)
+{
+	bool ran_to_completion = false;
+	int max_files = 0;
+
+	setup_swarm(2, swarm_test::download
+		// add session
+		, [](lt::settings_pack& pack)
+		{
+			pack.set_int(lt::settings_pack::file_pool_size, 5);
+		}
+		// add torrent
+		, [](lt::add_torrent_params& atp) {
+			// we need a torrent with lots of files in it, to hit the
+			// file_size_limit we set.
+			file_storage fs;
+			for (int i = 0; i < 0x10 * 9; ++i)
+			{
+				char filename[50];
+				snprintf(filename, sizeof(filename), "root/file-%d", i);
+				fs.add_file(filename, 0x400);
+			}
+			atp.ti = std::make_shared<torrent_info>(*atp.ti);
+			atp.ti->remap_files(fs);
+		}
+		// on alert
+		, [&](lt::alert const*, lt::session&) {}
+		// terminate
+		, [&](int ticks, lt::session& ses) -> bool
+		{
+			if (ticks > 80)
+			{
+				TEST_ERROR("timeout");
+				return true;
+			}
+
+			std::vector<open_file_state> const status = ses.get_torrents().at(0).file_status();
+			printf("open files: %d\n", int(status.size()));
+			max_files = std::max(max_files, int(status.size()));
+			if (!is_seed(ses)) return false;
+			printf("completed in %d ticks\n", ticks);
+			ran_to_completion = true;
+			return true;
+		});
+
+	TEST_CHECK(max_files <= 5);
+	TEST_CHECK(max_files >= 4);
+	TEST_CHECK(ran_to_completion);
+}
+
diff -Naupr a/simulation/test_timeout.cpp b/simulation/test_timeout.cpp
--- a/simulation/test_timeout.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/simulation/test_timeout.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,308 @@
+/*
+
+Copyright (c) 2021, Arvid Norberg
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <functional>
+
+#include "libtorrent/session.hpp"
+#include "libtorrent/torrent_handle.hpp"
+#include "libtorrent/settings_pack.hpp"
+#include "libtorrent/alert_types.hpp"
+#include "libtorrent/deadline_timer.hpp"
+#include "libtorrent/disabled_disk_io.hpp"
+#include "settings.hpp"
+#include "fake_peer.hpp"
+#include "utils.hpp"
+#include "setup_transfer.hpp"
+#include "create_torrent.hpp"
+#include "simulator/simulator.hpp"
+#include "simulator/utils.hpp"
+#include "simulator/queue.hpp"
+
+using namespace sim;
+using namespace lt;
+
+using disconnects_t = std::vector<std::pair<lt::seconds, lt::error_code>>;
+
+disconnects_t test_timeout(sim::configuration& cfg)
+{
+	sim::simulation sim{cfg};
+	auto const start_time = lt::clock_type::now();
+	std::unique_ptr<sim::asio::io_context> ios = make_io_context(sim, 0);
+	lt::session_proxy zombie;
+
+	lt::session_params sp;
+	sp.settings = settings();
+	sp.settings.set_int(settings_pack::alert_mask, alert_category::all & ~alert_category::stats);
+	sp.settings.set_bool(settings_pack::disable_hash_checks, true);
+	sp.disk_io_constructor = lt::disabled_disk_io_constructor;
+
+	// create session
+	std::shared_ptr<lt::session> ses = std::make_shared<lt::session>(sp, *ios);
+
+	fake_peer p1(sim, "60.0.0.0");
+
+	// add torrent
+	lt::add_torrent_params params = ::create_torrent(0, false);
+	params.flags &= ~lt::torrent_flags::auto_managed;
+	params.flags &= ~lt::torrent_flags::paused;
+	params.flags |= lt::torrent_flags::seed_mode;
+	lt::sha1_hash info_hash = params.ti->info_hash();
+	ses->async_add_torrent(std::move(params));
+
+	disconnects_t disconnects;
+
+	lt::torrent_handle h;
+	print_alerts(*ses, [&](lt::session& ses, lt::alert const* a) {
+		if (auto* at = lt::alert_cast<add_torrent_alert>(a))
+		{
+			h = at->handle;
+
+			p1.connect_to(ep("50.0.0.1", 6881), info_hash);
+			p1.send_interested();
+			p1.send_request(piece_index_t{0}, 0);
+		}
+		else if (auto* pd = lt::alert_cast<peer_disconnected_alert>(a))
+		{
+			disconnects.emplace_back(duration_cast<lt::seconds>(pd->timestamp() - start_time), pd->error);
+		}
+	});
+
+	// set up a timer to fire later, to shut down
+	sim::timer t2(sim, lt::seconds(400)
+		, [&](boost::system::error_code const&)
+	{
+		// shut down
+		zombie = ses->abort();
+		ses.reset();
+	});
+
+	sim.run();
+
+	return disconnects;
+}
+
+// the inactive timeout is 60 seconds. If we don't receive a request from a peer
+// that's interested in us for 60 seconds, we disconnect them.
+TORRENT_TEST(no_request_timeout)
+{
+	sim::default_config network_cfg;
+	auto disconnects = test_timeout(network_cfg);
+	TEST_CHECK((disconnects == disconnects_t{{lt::seconds{60}, lt::errors::timed_out_no_request}}));
+}
+
+struct slow_upload : sim::default_config
+{
+	sim::route outgoing_route(asio::ip::address ip) override
+	{
+	// only affect the libtorrent instance, not the fake peer
+		if (ip != addr("50.0.0.1")) return sim::default_config::outgoing_route(ip);
+
+		int const rate = 1;
+
+		using duration = sim::chrono::high_resolution_clock::duration;
+
+		auto it = m_outgoing.find(ip);
+		if (it != m_outgoing.end()) return sim::route().append(it->second);
+		it = m_outgoing.insert(it, std::make_pair(ip, std::make_shared<queue>(
+			std::ref(m_sim->get_io_context())
+			, rate * 1000
+			, lt::duration_cast<duration>(milliseconds(rate / 2))
+			, 200 * 1000, "slow upload rate")));
+		return sim::route().append(it->second);
+	}
+};
+
+// if the upload capacity is so low, that we're still trying to respond to the
+// last request, we don't trigger the inactivity timeout, we don't expect the
+// other peer to keep requesting more pieces before receiving the previous ones
+TORRENT_TEST(no_request_timeout_slow_upload)
+{
+	slow_upload cfg;
+	auto disconnects = test_timeout(cfg);
+	TEST_CHECK((disconnects == disconnects_t{{lt::seconds{73}, lt::errors::timed_out_no_request}}));
+}
+
+disconnects_t test_no_interest_timeout(int const num_peers
+	, lt::session_params sp
+	, bool const redundant_no_interest)
+{
+	sim::default_config cfg;
+	sim::simulation sim{cfg};
+	auto const start_time = lt::clock_type::now();
+	std::unique_ptr<sim::asio::io_context> ios = make_io_context(sim, 0);
+	lt::session_proxy zombie;
+
+	sp.settings.set_int(settings_pack::alert_mask, alert_category::all & ~alert_category::stats);
+
+	// create session
+	std::shared_ptr<lt::session> ses = std::make_shared<lt::session>(sp, *ios);
+
+	std::vector<std::unique_ptr<fake_peer>> peers;
+	for (int i = 0; i < num_peers; ++i)
+	{
+		char ip[50];
+		std::snprintf(ip, sizeof(ip), "60.0.0.%d", i + 1);
+		peers.emplace_back(new fake_peer(sim, ip));
+	}
+
+	// add torrent
+	lt::add_torrent_params params = ::create_torrent(0, false);
+	params.flags &= ~lt::torrent_flags::auto_managed;
+	params.flags &= ~lt::torrent_flags::paused;
+	lt::sha1_hash info_hash = params.ti->info_hash();
+	ses->async_add_torrent(std::move(params));
+
+	disconnects_t disconnects;
+
+	lt::torrent_handle h;
+	print_alerts(*ses, [&](lt::session& ses, lt::alert const* a) {
+		if (auto* at = lt::alert_cast<add_torrent_alert>(a))
+		{
+			h = at->handle;
+			for (auto& p : peers)
+				p->connect_to(ep("50.0.0.1", 6881), info_hash);
+		}
+		else if (auto* pd = lt::alert_cast<peer_disconnected_alert>(a))
+		{
+			disconnects.emplace_back(duration_cast<lt::seconds>(pd->timestamp() - start_time), pd->error);
+		}
+	});
+
+	std::function<void(boost::system::error_code const&)> keep_alive
+		= [&](boost::system::error_code const&)
+	{
+		for (auto& p : peers)
+		{
+			p->send_keepalive();
+			p->flush_send_buffer();
+		}
+	};
+
+	std::function<void(boost::system::error_code const&)> send_not_interested
+		= [&](boost::system::error_code const&)
+	{
+		for (auto& p : peers)
+		{
+			p->send_not_interested();
+			p->flush_send_buffer();
+		}
+	};
+
+	auto const& tick = redundant_no_interest ? send_not_interested : keep_alive;
+
+	sim::timer t3(sim, lt::seconds(100), tick);
+	sim::timer t4(sim, lt::seconds(200), tick);
+	sim::timer t5(sim, lt::seconds(300), tick);
+	sim::timer t6(sim, lt::seconds(400), tick);
+	sim::timer t7(sim, lt::seconds(500), tick);
+	sim::timer t8(sim, lt::seconds(599), tick);
+
+	// set up a timer to fire later, to shut down
+	sim::timer t2(sim, lt::seconds(700)
+		, [&](boost::system::error_code const&)
+	{
+		// shut down
+		zombie = ses->abort();
+		ses.reset();
+	});
+
+	sim.run();
+
+	return disconnects;
+}
+
+// if a peer is not interested in us, and we're not interested in it for long
+// enoguh, we disconenct it, but only if we are close to peer connection capacity
+TORRENT_TEST(no_interest_timeout)
+{
+	// with 10 peers, we're close enough to the connection limit to enable
+	// inactivity timeout
+
+	lt::session_params sp;
+	sp.disk_io_constructor = lt::disabled_disk_io_constructor;
+	sp.settings = settings();
+	sp.settings.set_int(settings_pack::connections_limit, 15);
+	auto disconnects = test_no_interest_timeout(10, std::move(sp), false);
+	TEST_EQUAL(disconnects.size(), 10);
+	for (auto const& e : disconnects)
+	{
+		TEST_CHECK(e.first == lt::seconds{600});
+		TEST_CHECK(e.second == lt::errors::timed_out_no_interest);
+	}
+}
+
+TORRENT_TEST(no_interest_timeout_redundant_not_interested)
+{
+	// even though the peers keep sending not-interested, our clock should not
+	// restart
+	lt::session_params sp;
+	sp.disk_io_constructor = lt::disabled_disk_io_constructor;
+	sp.settings = settings();
+	sp.settings.set_int(settings_pack::connections_limit, 15);
+	auto disconnects = test_no_interest_timeout(10, std::move(sp), true);
+	TEST_EQUAL(disconnects.size(), 10);
+	for (auto const& e : disconnects)
+	{
+		TEST_CHECK(e.first == lt::seconds{600});
+		TEST_CHECK(e.second == lt::errors::timed_out_no_interest);
+	}
+}
+
+TORRENT_TEST(no_interest_timeout_zero)
+{
+	// if we set inactivity_timeout to 0, all peers should be disconnected
+	// immediately
+	lt::session_params sp;
+	sp.disk_io_constructor = lt::disabled_disk_io_constructor;
+	sp.settings = settings();
+	sp.settings.set_int(settings_pack::connections_limit, 15);
+	sp.settings.set_int(settings_pack::inactivity_timeout, 0);
+	auto disconnects = test_no_interest_timeout(10, std::move(sp), false);
+	TEST_EQUAL(disconnects.size(), 10);
+	for (auto const& e : disconnects)
+	{
+		TEST_CHECK(e.first == lt::seconds{0});
+		TEST_CHECK(e.second == lt::errors::timed_out_no_interest);
+	}
+}
+
+TORRENT_TEST(no_interest_timeout_few_peers)
+{
+	// with a higher connections limit we're not close enough to enable
+	// inactivity timeout
+	lt::session_params sp;
+	sp.disk_io_constructor = lt::disabled_disk_io_constructor;
+	sp.settings = settings();
+	sp.settings.set_int(settings_pack::connections_limit, 20);
+	auto disconnects = test_no_interest_timeout(10, std::move(sp), false);
+	TEST_CHECK(disconnects == disconnects_t{});
+}
diff -Naupr a/simulation/test_transfer.cpp b/simulation/test_transfer.cpp
--- a/simulation/test_transfer.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/simulation/test_transfer.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -31,6 +31,7 @@ POSSIBILITY OF SUCH DAMAGE.
 */
 
 #include <array>
+#include <iostream>
 #include "test.hpp"
 #include "create_torrent.hpp"
 #include "settings.hpp"
@@ -41,6 +42,7 @@ POSSIBILITY OF SUCH DAMAGE.
 #include "libtorrent/alert_types.hpp"
 #include "libtorrent/aux_/proxy_settings.hpp"
 #include "libtorrent/settings_pack.hpp"
+#include "libtorrent/create_torrent.hpp"
 #include "simulator/simulator.hpp"
 #include "simulator/socks_server.hpp"
 #include "simulator/utils.hpp"
@@ -522,3 +524,182 @@ TORRENT_TEST(disk_full_recover)
 		, lt::seconds(65)
 	);
 }
+
+// Below is a series of tests to transfer torrents with varying pad-file related
+// traits
+void run_torrent_test(std::shared_ptr<lt::torrent_info> ti)
+{
+	using namespace lt;
+
+	using asio::ip::address;
+	address peer0 = addr("50.0.0.1");
+	address peer1 = addr("50.0.0.2");
+
+	// setup the simulation
+	sim::default_config network_cfg;
+	sim::simulation sim{network_cfg};
+	sim::asio::io_context ios0 { sim, peer0 };
+	sim::asio::io_context ios1 { sim, peer1 };
+
+	lt::session_proxy zombie[2];
+
+	lt::session_params params;
+	// setup settings pack to use for the session (customization point)
+	lt::settings_pack& pack = params.settings;
+	pack = settings();
+	pack.set_bool(settings_pack::disable_hash_checks, false);
+
+	// disable utp by default
+	pack.set_bool(settings_pack::enable_outgoing_utp, false);
+	pack.set_bool(settings_pack::enable_incoming_utp, false);
+
+	// disable encryption by default
+	pack.set_bool(settings_pack::prefer_rc4, false);
+	pack.set_int(settings_pack::in_enc_policy, settings_pack::pe_disabled);
+	pack.set_int(settings_pack::out_enc_policy, settings_pack::pe_disabled);
+	pack.set_int(settings_pack::allowed_enc_level, settings_pack::pe_plaintext);
+
+	pack.set_str(settings_pack::listen_interfaces, "50.0.0.1:6881");
+
+	// create session
+	std::shared_ptr<lt::session> ses[2];
+
+	// session 0 is a downloader, session 1 is a seed
+
+	params.disk_io_constructor = test_disk();
+	ses[0] = std::make_shared<lt::session>(params, ios0);
+
+	pack.set_str(settings_pack::listen_interfaces, "50.0.0.2:6881");
+
+	params.disk_io_constructor = test_disk().set_seed();
+	ses[1] = std::make_shared<lt::session>(params, ios1);
+
+	// only monitor alerts for session 0 (the downloader)
+	print_alerts(*ses[0], [=](lt::session& ses, lt::alert const* a) {
+		if (auto ta = alert_cast<lt::add_torrent_alert>(a))
+		{
+			ta->handle.connect_peer(lt::tcp::endpoint(peer1, 6881));
+		}
+	}, 0);
+
+	print_alerts(*ses[1], [](lt::session&, lt::alert const*){}, 1);
+
+	lt::add_torrent_params atp;
+	atp.ti = ti;
+	atp.save_path = ".";
+
+	atp.flags &= ~lt::torrent_flags::auto_managed;
+	atp.flags &= ~lt::torrent_flags::paused;
+
+	ses[1]->async_add_torrent(atp);
+	auto torrent = atp.ti;
+
+	ses[0]->async_add_torrent(atp);
+
+	sim::timer t(sim, lt::seconds(10), [&](boost::system::error_code const&)
+	{
+		auto h = ses[0]->get_torrents();
+		auto ti = h[0].torrent_file_with_hashes();
+
+		if (ti->v2())
+			TEST_EQUAL(ti->v2_piece_hashes_verified(), true);
+
+		auto downloaded = serialize(*ti);
+		auto added = serialize(*torrent);
+		TEST_CHECK(downloaded == added);
+
+		TEST_CHECK(is_seed(*ses[0]));
+		TEST_CHECK(is_seed(*ses[1]));
+
+		h[0].force_recheck();
+	});
+
+	sim::timer t2(sim, lt::minutes(1), [&](boost::system::error_code const&)
+	{
+		// shut down
+		int idx = 0;
+		for (auto& s : ses)
+		{
+			zombie[idx++] = s->abort();
+			s.reset();
+		}
+	});
+
+	sim.run();
+}
+
+namespace {
+
+std::shared_ptr<lt::torrent_info> test_torrent(lt::file_storage fs, lt::create_flags_t const flags)
+{
+	lt::create_torrent ct(fs, fs.piece_length(), flags);
+	lt::settings_pack pack;
+	lt::error_code ec;
+	lt::set_piece_hashes(ct, "", pack, test_disk().set_seed()
+		, [](lt::piece_index_t p) { std::cout << "."; std::cout.flush();}, ec);
+
+	auto e = ct.generate();
+	return std::make_shared<lt::torrent_info>(e);
+}
+
+}
+
+TORRENT_TEST(simple_torrent)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x3ff0, false}, {0x10, true}}, 0x4000), {}));
+}
+
+TORRENT_TEST(odd_last_pad_file)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x4100, false}, {0x10, true}}, 0x4000), {}));
+}
+
+TORRENT_TEST(small_piece_size)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x3ff0, false}, {0x10, true}}, 0x2000), {}));
+}
+
+TORRENT_TEST(odd_piece_size)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x1ffe, false}, {0x1, true}}, 0x1fff), {}));
+}
+
+TORRENT_TEST(large_pad_file)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x5000, false}, {0x100000000 - 0x5000, true}}, 0x100000), {}));
+}
+
+TORRENT_TEST(unaligned_pad_file)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x3fff, false}, {0x10, true}}, 0x4000), {}));
+}
+
+TORRENT_TEST(piece_size_pad_file)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x8000, false}, {0x8000, true}}, 0x8000), {}));
+}
+
+TORRENT_TEST(block_size_pad_file)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x4000, false}, {0x4000, true}}, 0x4000), {}));
+}
+
+TORRENT_TEST(back_to_back_pad_file)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x3000, false}, {0x800, true}, {0x800, true}}, 0x4000), {}));
+}
+
+TORRENT_TEST(small_file_large_piece)
+{
+	run_torrent_test(test_torrent(make_files(
+		{{0x833ed, false}, {0x7cc13, true}, {0x3d, false}, {0x7ffc3, true}, {0x14000, false}}, 0x80000), {}));
+}
diff -Naupr a/src/bt_peer_connection.cpp b/src/bt_peer_connection.cpp
--- a/src/bt_peer_connection.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/bt_peer_connection.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -1120,6 +1120,7 @@ namespace {
 		if (!m_recv_buffer.packet_finished()) return;
 
 		incoming_piece(p, recv_buffer.data() + header_size);
+		maybe_send_hash_request();
 	}
 
 	// -----------------------------
@@ -1190,7 +1191,8 @@ namespace {
 #ifndef TORRENT_DISABLE_LOGGING
 		if (should_log(peer_log_alert::incoming_message))
 		{
-			peer_log(peer_log_alert::incoming_message, "HASH_REQUEST", "%d %d %d %d %d"
+			peer_log(peer_log_alert::incoming_message, "HASH_REQUEST"
+				, "file: %d base: %d idx: %d cnt: %d proofs: %d"
 				, static_cast<int>(hr.file), hr.base, hr.index, hr.count, hr.proof_layers);
 		}
 #endif
@@ -1291,7 +1293,8 @@ namespace {
 #ifndef TORRENT_DISABLE_LOGGING
 		if (should_log(peer_log_alert::incoming_message))
 		{
-			peer_log(peer_log_alert::incoming_message, "HASHES", "%d %d %d %d %d"
+			peer_log(peer_log_alert::incoming_message, "HASHES"
+				, "file: %d base: %d idx: %d cnt: %d proofs: %d"
 				, static_cast<int>(hr.file), hr.base, hr.index, hr.count, hr.proof_layers);
 		}
 #endif
@@ -1343,7 +1346,8 @@ namespace {
 #ifndef TORRENT_DISABLE_LOGGING
 		if (should_log(peer_log_alert::incoming_message))
 		{
-			peer_log(peer_log_alert::incoming_message, "HASH_REJECT", "%d %d %d %d %d"
+			peer_log(peer_log_alert::incoming_message, "HASH_REJECT"
+				, "file: %d base: %d idx: %d cnt: %d proofs: %d"
 				, static_cast<int>(hr.file), hr.base, hr.index, hr.count, hr.proof_layers);
 		}
 #endif
@@ -1738,7 +1742,8 @@ namespace {
 		if (should_log(peer_log_alert::outgoing_message))
 		{
 			peer_log(peer_log_alert::outgoing_message, "HASH_REQUEST"
-				, "%d %d %d %d %d", int(req.file), req.base, req.index, req.count, req.proof_layers);
+				, "file: %d base: %d idx: %d cnt: %d proofs: %d"
+				, int(req.file), req.base, req.index, req.count, req.proof_layers);
 		}
 #endif
 
@@ -1779,7 +1784,8 @@ namespace {
 		if (should_log(peer_log_alert::outgoing_message))
 		{
 			peer_log(peer_log_alert::outgoing_message, "HASHES"
-				, "%d %d %d %d %d", static_cast<int>(req.file), req.base, req.index, req.count, req.proof_layers);
+				, "file: %d base: %d idx: %d cnt: %d proofs: %d"
+				, static_cast<int>(req.file), req.base, req.index, req.count, req.proof_layers);
 		}
 #endif
 
@@ -1810,7 +1816,8 @@ namespace {
 		if (should_log(peer_log_alert::outgoing_message))
 		{
 			peer_log(peer_log_alert::outgoing_message, "HASH_REJECT"
-				, "%d %d %d %d", req.base, req.index, req.count, req.proof_layers);
+				, "base: %d idx: %d cnt: %d proofs: %d"
+				, req.base, req.index, req.count, req.proof_layers);
 		}
 #endif
 
@@ -2078,7 +2085,7 @@ namespace {
 #ifndef TORRENT_DISABLE_SHARE_MODE
 			&& !t->share_mode()
 #endif
-			)
+			&& can_disconnect(errors::upload_upload_connection))
 			disconnect(errors::upload_upload_connection, operation_t::bittorrent);
 
 		stats_counters().inc_stats_counter(counters::num_incoming_ext_handshake);
diff -Naupr a/src/create_torrent.cpp b/src/create_torrent.cpp
--- a/src/create_torrent.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/create_torrent.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -295,6 +295,13 @@ namespace {
 		, settings_interface const& sett
 		, std::function<void(piece_index_t)> const& f, error_code& ec)
 	{
+		set_piece_hashes(t, p, sett, default_disk_io_constructor, f, ec);
+	}
+
+	void set_piece_hashes(create_torrent& t, std::string const& p
+		, settings_interface const& sett, disk_io_constructor_type disk_io
+		, std::function<void(piece_index_t)> const& f, error_code& ec)
+	{
 		// optimized path
 #ifdef TORRENT_BUILD_SIMULATOR
 		sim::default_config conf;
@@ -324,7 +331,7 @@ namespace {
 
 		counters cnt;
 		int const num_threads = sett.get_int(settings_pack::hashing_threads);
-		std::unique_ptr<disk_interface> disk_thread = default_disk_io_constructor(ios, sett, cnt);
+		std::unique_ptr<disk_interface> disk_thread = disk_io(ios, sett, cnt);
 		disk_aborter da(*disk_thread.get());
 
 		aux::vector<download_priority_t, file_index_t> priorities;
diff -Naupr a/src/enum_net.cpp b/src/enum_net.cpp
--- a/src/enum_net.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/enum_net.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -1029,9 +1029,21 @@ int _System __libsocket_sysctl(int* mib,
 		return {};
 	}
 
+	bool has_any_internet_route(span<ip_route const> routes)
+	{
+		return std::any_of(routes.begin(), routes.end()
+			, [&](ip_route const& r) -> bool
+			{
+				// if *any* global IP can be routed to this interface, it's
+				// considered able to reach the internet
+				return r.destination.is_unspecified()
+					|| aux::is_global(r.destination) ;
+			});
+	}
+
 	bool has_internet_route(string_view device, int const fam, span<ip_route const> routes)
 	{
-		return std::find_if(routes.begin(), routes.end()
+		return std::any_of(routes.begin(), routes.end()
 			, [&](ip_route const& r) -> bool
 			{
 				// if *any* global IP can be routed to this interface, it's
@@ -1041,7 +1053,7 @@ int _System __libsocket_sysctl(int* mib,
 					&& (r.destination.is_unspecified()
 						|| aux::is_global(r.destination)
 					);
-			}) != routes.end();
+			});
 	}
 
 	std::vector<ip_route> enum_routes(io_context& ios, error_code& ec)
diff -Naupr a/src/file_progress.cpp b/src/file_progress.cpp
--- a/src/file_progress.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/file_progress.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -52,8 +52,13 @@ namespace libtorrent { namespace aux {
 		m_have_pieces.resize(num_pieces, false);
 		m_file_sizes.clear();
 		m_file_sizes.reserve(num_files);
-		for (file_index_t i(0); i < fs.end_file(); ++i)
+		m_pad_file.clear();
+		m_pad_file.reserve(num_files);
+		for (file_index_t i : fs.file_range())
+		{
 			m_file_sizes.push_back(fs.file_size(i));
+			m_pad_file.push_back(fs.pad_file_at(i));
+		}
 #endif
 
 		m_file_progress.resize(num_files, 0);
@@ -93,6 +98,10 @@ namespace libtorrent { namespace aux {
 			{
 				std::int64_t const add = std::min(size, fs.file_size(file_index) - file_offset);
 				TORRENT_ASSERT(add >= 0);
+
+				if (!fs.pad_file_at(file_index))
+					m_total_on_disk += add;
+
 				m_file_progress[file_index] += add;
 
 				TORRENT_ASSERT(m_file_progress[file_index]
@@ -120,6 +129,7 @@ namespace libtorrent { namespace aux {
 	void file_progress::clear()
 	{
 		INVARIANT_CHECK;
+		m_total_on_disk = 0;
 		m_file_progress.clear();
 		m_file_progress.shrink_to_fit();
 #if TORRENT_USE_INVARIANT_CHECKS
@@ -154,6 +164,11 @@ namespace libtorrent { namespace aux {
 			TORRENT_ASSERT(file_offset <= fs.file_size(file_index));
 			std::int64_t const add = std::min(fs.file_size(file_index)
 				- file_offset, size);
+
+			bool const is_pad_file = fs.pad_file_at(file_index);
+			if (!is_pad_file)
+				m_total_on_disk += add;
+
 			m_file_progress[file_index] += add;
 
 			TORRENT_ASSERT(m_file_progress[file_index]
@@ -161,7 +176,7 @@ namespace libtorrent { namespace aux {
 
 			if (m_file_progress[file_index] >= fs.file_size(file_index) && completed_cb)
 			{
-				if (!fs.pad_file_at(file_index))
+				if (!is_pad_file)
 					completed_cb(file_index);
 			}
 			size -= add;
@@ -173,13 +188,21 @@ namespace libtorrent { namespace aux {
 #if TORRENT_USE_INVARIANT_CHECKS
 	void file_progress::check_invariant() const
 	{
-		if (m_file_progress.empty()) return;
+		if (m_file_progress.empty())
+		{
+			TORRENT_ASSERT(m_total_on_disk == 0);
+			return;
+		}
 
 		file_index_t index(0);
+		std::int64_t total_on_disk = 0;
 		for (std::int64_t progress : m_file_progress)
 		{
-			TORRENT_ASSERT(progress <= m_file_sizes[index++]);
+			total_on_disk += m_pad_file[index] ? 0 : progress;
+			TORRENT_ASSERT(progress <= m_file_sizes[index]);
+			++index;
 		}
+		TORRENT_ASSERT(m_total_on_disk == total_on_disk);
 	}
 #endif
 } }
diff -Naupr a/src/file_storage.cpp b/src/file_storage.cpp
--- a/src/file_storage.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/file_storage.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -1564,5 +1564,16 @@ namespace aux {
 			(fs.total_size() + fs.piece_length() - 1) / fs.piece_length());
 	}
 
+	std::int64_t size_on_disk(file_storage const& fs)
+	{
+		std::int64_t ret = 0;
+		for (file_index_t i : fs.file_range())
+		{
+			if (fs.pad_file_at(i)) continue;
+			ret += fs.file_size(i);
+		}
+		return ret;
+	}
+
 	} // namespace aux
 }
diff -Naupr a/src/hash_picker.cpp b/src/hash_picker.cpp
--- a/src/hash_picker.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/hash_picker.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -109,19 +109,25 @@ bool validate_hash_request(hash_request
 			if (m_files.pad_file_at(f)) continue;
 
 			auto const& tree = m_merkle_trees[f];
+			auto& v = m_hash_verified[f];
 
 			// TODO: allocate m_hash_verified lazily when a hash conflist occurs?
 			// would save memory in the common case of no hash failures
-			m_hash_verified[f].resize(std::size_t(m_files.file_num_blocks(f)), all_verified);
-			if (m_hash_verified[f].size() == 1)
+			v.resize(std::size_t(m_files.file_num_blocks(f)), all_verified);
+			if (v.size() == 1)
 			{
 				// the root hash comes from the metadata so it is always verified
 				TORRENT_ASSERT(!tree.root().is_all_zeros());
-				m_hash_verified[f][0] = true;
+				v[0] = true;
 			}
 
 			if (m_files.file_size(f) <= m_files.piece_length())
+			{
+#if TORRENT_USE_INVARIANT_CHECKS
+				check_invariant(f);
+#endif
 				continue;
+			}
 
 			m_piece_hash_requested[f].resize((m_files.file_num_pieces(f) + 511) / 512);
 
@@ -140,12 +146,26 @@ bool validate_hash_request(hash_request
 						m_piece_hash_requested[f][i].have = true;
 						break;
 					}
-					if ((m_files.piece_length() == default_block_size && !m_hash_verified[f][std::size_t(j)])
+					if ((m_files.piece_length() == default_block_size && !v[std::size_t(j)])
 						|| (m_files.piece_length() > default_block_size
 							&& !tree.has_node(piece_layer_start + j)))
 						break;
 				}
 			}
+
+			// The verified bitfield may be invalid. If so, correct it to
+			// maintain the invariant of this class
+			int block_index = m_files.file_first_block_node(f);
+			for (auto i = v.begin(); i != v.end(); ++i)
+			{
+				if (*i && !tree.has_node(block_index))
+					*i = false;
+				++block_index;
+			}
+
+#if TORRENT_USE_INVARIANT_CHECKS
+			check_invariant(f);
+#endif
 		}
 	}
 
@@ -331,6 +351,10 @@ bool validate_hash_request(hash_request
 				, file_piece_offset, hashes);
 		}
 
+#if TORRENT_USE_INVARIANT_CHECKS
+		check_invariant(req.file);
+#endif
+
 		return ret;
 	}
 
@@ -375,10 +399,18 @@ bool validate_hash_request(hash_request
 		std::tie(result, leafs_index, leafs_size) = merkle_tree.set_block(block_index, h);
 
 		if (result == aux::merkle_tree::set_block_result::unknown)
+		{
+#if TORRENT_USE_INVARIANT_CHECKS
+			check_invariant(f);
+#endif
 			return set_block_hash_result::unknown();
+		}
 
 		if (result == aux::merkle_tree::set_block_result::hash_failed)
 		{
+#if TORRENT_USE_INVARIANT_CHECKS
+			check_invariant(f);
+#endif
 			// If the hash failure was detected within a single piece then report a piece failure
 			// otherwise report unknown. The pieces will be checked once their hashes have been
 			// downloaded.
@@ -391,6 +423,9 @@ bool validate_hash_request(hash_request
 		{
 			int const file_num_blocks = m_files.file_num_blocks(f);
 			std::fill_n(m_hash_verified[f].begin() + leafs_index, std::min(leafs_size, file_num_blocks - leafs_index), true);
+#if TORRENT_USE_INVARIANT_CHECKS
+			check_invariant(f);
+#endif
 		}
 
 		int const blocks_per_piece = m_files.piece_length() / default_block_size;
@@ -498,4 +533,27 @@ bool validate_hash_request(hash_request
 	{
 		return merkle_num_layers(merkle_num_leafs(m_files.file_num_blocks(idx)));
 	}
+
+#if TORRENT_USE_INVARIANT_CHECKS
+	void hash_picker::check_invariant(file_index_t const idx) const
+	{
+		TORRENT_UNUSED(idx);
+#ifdef TORRENT_EXPENSIVE_INVARIANT_CHECKS
+		auto const& verified = m_hash_verified[idx];
+		if (verified.empty()) return;
+
+		auto const& merkle_tree = m_merkle_trees[idx];
+
+		int block_index = m_files.file_first_block_node(idx);
+
+		for (bool const v : verified)
+		{
+			// v implies has_node(). If v == false, has_node may or may not be
+			// true
+			TORRENT_ASSERT(!v || merkle_tree.has_node(block_index));
+			++block_index;
+		}
+#endif
+	}
+#endif
 }
diff -Naupr a/src/kademlia/dht_tracker.cpp b/src/kademlia/dht_tracker.cpp
--- a/src/kademlia/dht_tracker.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/kademlia/dht_tracker.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -141,7 +141,7 @@ namespace libtorrent { namespace dht {
 		if (m_log->should_log(dht_logger::tracker))
 		{
 			m_log->log(dht_logger::tracker, "starting %s DHT tracker with node id: %s"
-				, local_address.is_v4() ? "IPv4" : "IPv6"
+				, local_address.to_string().c_str()
 				, aux::to_hex(n.first->second.dht.nid()).c_str());
 		}
 #endif
@@ -158,6 +158,14 @@ namespace libtorrent { namespace dht {
 
 	void dht_tracker::delete_socket(aux::listen_socket_handle const& s)
 	{
+#ifndef TORRENT_DISABLE_LOGGING
+		if (m_log->should_log(dht_logger::tracker))
+		{
+			address const local_address = s.get_local_endpoint().address();
+			m_log->log(dht_logger::tracker, "removing DHT node on %s"
+				, local_address.to_string().c_str());
+		}
+#endif
 		m_nodes.erase(s);
 
 		update_storage_node_ids();
@@ -207,7 +215,6 @@ namespace libtorrent { namespace dht {
 		s.dht_nodes = 0;
 		s.dht_node_cache = 0;
 		s.dht_global_nodes = 0;
-		s.dht_torrents = 0;
 		s.active_requests.clear();
 		s.dht_total_allocations = 0;
 
@@ -289,7 +296,8 @@ namespace libtorrent { namespace dht {
 			n.second.dht.new_write_key();
 
 #ifndef TORRENT_DISABLE_LOGGING
-		m_log->log(dht_logger::tracker, "*** new write key***");
+		m_log->log(dht_logger::tracker, "*** new write key*** %d nodes"
+			, int(m_nodes.size()));
 #endif
 	}
 
diff -Naupr a/src/magnet_uri.cpp b/src/magnet_uri.cpp
--- a/src/magnet_uri.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/magnet_uri.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -52,17 +52,15 @@ namespace libtorrent {
 
 		if (handle.info_hashes().has_v1())
 		{
-			sha1_hash const& ih = handle.info_hashes().v1;
 			ret += "xt=urn:btih:";
-			ret += aux::to_hex(ih);
+			ret += aux::to_hex(handle.info_hashes().v1);
 		}
 
 		if (handle.info_hashes().has_v2())
 		{
 			if (handle.info_hashes().has_v1()) ret += '&';
-			sha256_hash const& ih = handle.info_hashes().v2;
 			ret += "xt=urn:btmh:1220";
-			ret += aux::to_hex(ih);
+			ret += aux::to_hex(handle.info_hashes().v2);
 		}
 
 		torrent_status st = handle.status(torrent_handle::query_name);
@@ -93,17 +91,15 @@ namespace libtorrent {
 
 		if (info.info_hashes().has_v1())
 		{
-			sha1_hash const& ih = info.info_hashes().v1;
 			ret += "xt=urn:btih:";
-			ret += aux::to_hex(ih);
+			ret += aux::to_hex(info.info_hashes().v1);
 		}
 
 		if (info.info_hashes().has_v2())
 		{
 			if (info.info_hashes().has_v1()) ret += '&';
-			sha256_hash const& ih = info.info_hashes().v2;
 			ret += "xt=urn:btmh:1220";
-			ret += aux::to_hex(ih);
+			ret += aux::to_hex(info.info_hashes().v2);
 		}
 
 		std::string const& name = info.name();
diff -Naupr a/src/merkle.cpp b/src/merkle.cpp
--- a/src/merkle.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/merkle.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -77,6 +77,7 @@ namespace libtorrent {
 	{
 		TORRENT_ASSERT(leafs > 0);
 		TORRENT_ASSERT(leafs <= (std::numeric_limits<int>::max() / 2) + 1);
+		TORRENT_ASSERT((leafs & (leafs - 1)) == 0);
 		// This is a way to calculate: (leafs << 1) - 1 without requiring an extra
 		// bit in the far left. The first 1 we subtract is worth 2 after we
 		// multiply by 2, so by just adding back one, we have effectively
@@ -424,6 +425,5 @@ namespace libtorrent {
 
 		return std::make_tuple(leafs_start, leafs_size, root_index);
 	}
-
 }
 
diff -Naupr a/src/peer_connection.cpp b/src/peer_connection.cpp
--- a/src/peer_connection.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/peer_connection.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -907,11 +907,6 @@ namespace libtorrent {
 		TORRENT_ASSERT(t);
 		if (!t) return {};
 
-		if (t->num_time_critical_pieces() > 0)
-		{
-			ret |= piece_picker::time_critical_mode;
-		}
-
 		if (t->is_sequential_download())
 		{
 			ret |= piece_picker::sequential;
diff -Naupr a/src/piece_picker.cpp b/src/piece_picker.cpp
--- a/src/piece_picker.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/piece_picker.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -129,7 +129,6 @@ namespace libtorrent {
 	constexpr picker_options_t piece_picker::on_parole;
 	constexpr picker_options_t piece_picker::prioritize_partials;
 	constexpr picker_options_t piece_picker::sequential;
-	constexpr picker_options_t piece_picker::time_critical_mode;
 	constexpr picker_options_t piece_picker::align_expanded_pieces;
 	constexpr picker_options_t piece_picker::piece_extent_affinity;
 
@@ -145,10 +144,11 @@ namespace libtorrent {
 	// the max number of blocks to create an affinity for
 	constexpr int max_piece_affinity_extent = 4 * 1024 * 1024 / default_block_size;
 
-	piece_picker::piece_picker(int const blocks_per_piece
-		, int const blocks_in_last_piece, int const total_num_pieces)
+	piece_picker::piece_picker(std::int64_t const total_size, int const piece_size)
 		: m_priority_boundaries(1, m_pieces.end_index())
 	{
+		TORRENT_ASSERT(total_size > 0);
+		TORRENT_ASSERT(piece_size > 0);
 #ifdef TORRENT_PICKER_LOG
 		std::cerr << "[" << this << "] " << "new piece_picker" << std::endl;
 #endif
@@ -156,25 +156,33 @@ namespace libtorrent {
 		check_invariant();
 #endif
 
-		resize(blocks_per_piece, blocks_in_last_piece, total_num_pieces);
+		resize(total_size, piece_size);
 	}
 
-	void piece_picker::resize(int const blocks_per_piece
-		, int const blocks_in_last_piece, int const total_num_pieces)
+	void piece_picker::resize(std::int64_t const total_size, int const piece_size)
 	{
-		TORRENT_ASSERT(blocks_per_piece > 0);
-		TORRENT_ASSERT(total_num_pieces > 0);
+		TORRENT_ASSERT(total_size > 0);
+		TORRENT_ASSERT(piece_size > 0);
+
+		m_total_size = total_size;
+		m_piece_size = piece_size;
+
+		int const blocks_in_piece
+			= (piece_size + block_size() - 1) / block_size();
+		int const blocks_in_last_piece
+			= ((total_size % piece_size) + block_size() - 1) / block_size();
+		int const num_pieces = int((total_size + piece_size - 1) / piece_size);
 
 #ifdef TORRENT_PICKER_LOG
 		std::cerr << "[" << this << "] " << "piece_picker::resize()" << std::endl;
 #endif
 
-		if (blocks_per_piece > max_blocks_per_piece)
+		if (blocks_in_piece > max_blocks_per_piece)
 			throw system_error(errors::invalid_piece_size);
 
 		// allocate the piece_map to cover all pieces
 		// and make them invalid (as if we don't have a single piece)
-		m_piece_map.resize(total_num_pieces, piece_pos(0, 0));
+		m_piece_map.resize(num_pieces, piece_pos(0, 0));
 		m_reverse_cursor = m_piece_map.end_index();
 		m_cursor = piece_index_t(0);
 
@@ -185,9 +193,9 @@ namespace libtorrent {
 		m_num_filtered += m_num_have_filtered;
 		m_num_have_filtered = 0;
 		m_num_have = 0;
-		m_have_pad_blocks = 0;
-		m_filtered_pad_blocks = 0;
-		m_have_filtered_pad_blocks = 0;
+		m_have_pad_bytes = 0;
+		m_filtered_pad_bytes = 0;
+		m_have_filtered_pad_bytes = 0;
 		m_num_passed = 0;
 		m_dirty = true;
 		for (auto& m : m_piece_map)
@@ -208,11 +216,10 @@ namespace libtorrent {
 			m_reverse_cursor > piece_index_t(0) && (i->have() || i->filtered());
 			++i, --m_reverse_cursor);
 
-		m_blocks_per_piece = aux::numeric_cast<std::uint16_t>(blocks_per_piece);
 		m_blocks_in_last_piece = aux::numeric_cast<std::uint16_t>(blocks_in_last_piece);
-		if (m_blocks_in_last_piece == 0) m_blocks_in_last_piece = aux::numeric_cast<std::uint16_t>(blocks_per_piece);
+		if (m_blocks_in_last_piece == 0) m_blocks_in_last_piece = aux::numeric_cast<std::uint16_t>(blocks_per_piece());
 
-		TORRENT_ASSERT(m_blocks_in_last_piece <= m_blocks_per_piece);
+		TORRENT_ASSERT(m_blocks_in_last_piece <= blocks_per_piece());
 	}
 
 	void piece_picker::piece_info(piece_index_t const index, piece_picker::downloading_piece& st) const
@@ -267,9 +274,10 @@ namespace libtorrent {
 		if (m_free_block_infos.empty())
 		{
 			// we need to allocate more space in m_block_info
-			block_index = int(m_block_info.size() / m_blocks_per_piece);
-			TORRENT_ASSERT((m_block_info.size() % m_blocks_per_piece) == 0);
-			m_block_info.resize(m_block_info.size() + m_blocks_per_piece);
+			int const blocks = blocks_per_piece();
+			block_index = int(m_block_info.size()) / blocks;
+			TORRENT_ASSERT((m_block_info.size() % std::size_t(blocks)) == 0);
+			m_block_info.resize(m_block_info.size() + std::size_t(blocks));
 		}
 		else
 		{
@@ -289,15 +297,20 @@ namespace libtorrent {
 		TORRENT_ASSERT(block_index >= 0);
 		TORRENT_ASSERT(block_index < std::numeric_limits<std::uint16_t>::max());
 		ret.info_idx = std::uint16_t(block_index);
-		TORRENT_ASSERT(int(ret.info_idx) * m_blocks_per_piece
-			+ m_blocks_per_piece <= int(m_block_info.size()));
+		TORRENT_ASSERT(int(ret.info_idx) * blocks_per_piece()
+			+ blocks_per_piece() <= int(m_block_info.size()));
+
+		// the number of non-pad blocks in this piece. Any blocks past this will
+		// be assumed we have already
+
+		int const payload_blocks = blocks_per_piece() - pad_bytes_in_piece(piece) / block_size();
 
 		int block_idx = 0;
 		for (auto& info : mutable_blocks_for_piece(ret))
 		{
 			info.num_peers = 0;
 			info.state = block_info::state_none;
-			if (!m_pad_blocks.empty() && m_pad_blocks.get_bit(static_cast<int>(piece) * m_blocks_per_piece + block_idx))
+			if (block_idx >= payload_blocks)
 			{
 				info.state = block_info::state_finished;
 				++ret.finished;
@@ -383,8 +396,8 @@ namespace libtorrent {
 	span<piece_picker::block_info> piece_picker::mutable_blocks_for_piece(
 		downloading_piece const& dp)
 	{
-		int idx = int(dp.info_idx) * m_blocks_per_piece;
-		TORRENT_ASSERT(idx + m_blocks_per_piece <= int(m_block_info.size()));
+		int idx = int(dp.info_idx) * blocks_per_piece();
+		TORRENT_ASSERT(idx + blocks_per_piece() <= int(m_block_info.size()));
 		return { &m_block_info[idx], blocks_in_piece(dp.index) };
 	}
 
@@ -406,8 +419,8 @@ namespace libtorrent {
 				downloading_piece const& dp = *i;
 				downloading_piece const& next = *(i + 1);
 				TORRENT_ASSERT(dp.index < next.index);
-				TORRENT_ASSERT(int(dp.info_idx) * m_blocks_per_piece
-					+ m_blocks_per_piece <= int(m_block_info.size()));
+				TORRENT_ASSERT(int(dp.info_idx) * blocks_per_piece()
+					+ blocks_per_piece() <= int(m_block_info.size()));
 				for (auto const& bl : blocks_for_piece(dp))
 				{
 					if (!bl.peer) continue;
@@ -468,14 +481,14 @@ namespace libtorrent {
 		TORRENT_ASSERT(m_num_have_filtered + m_num_filtered <= num_pieces());
 		TORRENT_ASSERT(m_num_filtered >= 0);
 		TORRENT_ASSERT(m_seeds >= 0);
-		TORRENT_ASSERT(m_have_pad_blocks <= num_pad_blocks());
-		TORRENT_ASSERT(m_have_pad_blocks >= 0);
-		TORRENT_ASSERT(m_filtered_pad_blocks <= num_pad_blocks());
-		TORRENT_ASSERT(m_filtered_pad_blocks >= 0);
-		TORRENT_ASSERT(m_have_filtered_pad_blocks <= num_pad_blocks());
-		TORRENT_ASSERT(m_have_filtered_pad_blocks >= 0);
-		TORRENT_ASSERT(m_have_filtered_pad_blocks + m_filtered_pad_blocks <= num_pad_blocks());
-		TORRENT_ASSERT(m_have_filtered_pad_blocks <= m_have_pad_blocks);
+		TORRENT_ASSERT(m_have_pad_bytes <= num_pad_bytes());
+		TORRENT_ASSERT(m_have_pad_bytes >= 0);
+		TORRENT_ASSERT(m_filtered_pad_bytes <= num_pad_bytes());
+		TORRENT_ASSERT(m_filtered_pad_bytes >= 0);
+		TORRENT_ASSERT(m_have_filtered_pad_bytes <= num_pad_bytes());
+		TORRENT_ASSERT(m_have_filtered_pad_bytes >= 0);
+		TORRENT_ASSERT(m_have_filtered_pad_bytes + m_filtered_pad_bytes <= num_pad_bytes());
+		TORRENT_ASSERT(m_have_filtered_pad_bytes <= m_have_pad_bytes);
 
 		// make sure the priority boundaries are monotonically increasing. The
 		// difference between two cursors cannot be negative, but ranges are
@@ -611,9 +624,9 @@ namespace libtorrent {
 		int num_filtered = 0;
 		int num_have_filtered = 0;
 		int num_have = 0;
-		int num_have_pad_blocks = 0;
-		int num_filtered_pad_blocks = 0;
-		int num_have_filtered_pad_blocks = 0;
+		int num_have_pad_bytes = 0;
+		int num_filtered_pad_bytes = 0;
+		int num_have_filtered_pad_bytes = 0;
 		piece_index_t piece(0);
 		for (auto i = m_piece_map.begin(); i != m_piece_map.end(); ++i, ++piece)
 		{
@@ -624,12 +637,12 @@ namespace libtorrent {
 				if (p.index != piece_pos::we_have_index)
 				{
 					++num_filtered;
-					num_filtered_pad_blocks += pad_blocks_in_piece(piece);
+					num_filtered_pad_bytes += pad_bytes_in_piece(piece);
 				}
 				else
 				{
 					++num_have_filtered;
-					num_have_filtered_pad_blocks += pad_blocks_in_piece(piece);
+					num_have_filtered_pad_bytes += pad_bytes_in_piece(piece);
 				}
 			}
 
@@ -639,7 +652,7 @@ namespace libtorrent {
 			if (p.index == piece_pos::we_have_index)
 			{
 				++num_have;
-				num_have_pad_blocks += pad_blocks_in_piece(piece);
+				num_have_pad_bytes += pad_bytes_in_piece(piece);
 			}
 
 			if (p.index == piece_pos::we_have_index)
@@ -728,9 +741,9 @@ namespace libtorrent {
 		TORRENT_ASSERT(num_have == m_num_have);
 		TORRENT_ASSERT(num_filtered == m_num_filtered);
 		TORRENT_ASSERT(num_have_filtered == m_num_have_filtered);
-		TORRENT_ASSERT(num_have_pad_blocks == m_have_pad_blocks);
-		TORRENT_ASSERT(num_filtered_pad_blocks == m_filtered_pad_blocks);
-		TORRENT_ASSERT(num_have_filtered_pad_blocks == m_have_filtered_pad_blocks);
+		TORRENT_ASSERT(num_have_pad_bytes == m_have_pad_bytes);
+		TORRENT_ASSERT(num_filtered_pad_bytes == m_filtered_pad_bytes);
+		TORRENT_ASSERT(num_have_filtered_pad_bytes == m_have_filtered_pad_bytes);
 
 		if (!m_dirty)
 		{
@@ -1073,8 +1086,8 @@ namespace libtorrent {
 		auto i = find_dl_piece(download_state, index);
 
 		TORRENT_ASSERT(i != m_downloads[download_state].end());
-		TORRENT_ASSERT(int(i->info_idx) * m_blocks_per_piece
-			+ m_blocks_per_piece <= int(m_block_info.size()));
+		TORRENT_ASSERT(int(i->info_idx) * blocks_per_piece()
+			+ blocks_per_piece() <= int(m_block_info.size()));
 
 		i->locked = false;
 
@@ -1640,11 +1653,11 @@ namespace libtorrent {
 		--m_num_passed;
 		if (p.filtered())
 		{
-			m_filtered_pad_blocks += pad_blocks_in_piece(index);
+			m_filtered_pad_bytes += pad_bytes_in_piece(index);
 			++m_num_filtered;
 
-			TORRENT_ASSERT(m_have_filtered_pad_blocks >= pad_blocks_in_piece(index));
-			m_have_filtered_pad_blocks -= pad_blocks_in_piece(index);
+			TORRENT_ASSERT(m_have_filtered_pad_bytes >= pad_bytes_in_piece(index));
+			m_have_filtered_pad_bytes -= pad_bytes_in_piece(index);
 			TORRENT_ASSERT(m_num_have_filtered > 0);
 			--m_num_have_filtered;
 		}
@@ -1661,8 +1674,8 @@ namespace libtorrent {
 		}
 
 		--m_num_have;
-		m_have_pad_blocks -= pad_blocks_in_piece(index);
-		TORRENT_ASSERT(m_have_pad_blocks >= 0);
+		m_have_pad_bytes -= pad_bytes_in_piece(index);
+		TORRENT_ASSERT(m_have_pad_bytes >= 0);
 		p.set_not_have();
 
 		if (m_dirty) return;
@@ -1703,18 +1716,18 @@ namespace libtorrent {
 
 		if (p.filtered())
 		{
-			TORRENT_ASSERT(m_filtered_pad_blocks >= pad_blocks_in_piece(index));
-			m_filtered_pad_blocks -= pad_blocks_in_piece(index);
+			TORRENT_ASSERT(m_filtered_pad_bytes >= pad_bytes_in_piece(index));
+			m_filtered_pad_bytes -= pad_bytes_in_piece(index);
 			TORRENT_ASSERT(m_num_filtered > 0);
 			--m_num_filtered;
 
-			m_have_filtered_pad_blocks += pad_blocks_in_piece(index);
+			m_have_filtered_pad_bytes += pad_bytes_in_piece(index);
 			++m_num_have_filtered;
 		}
 		++m_num_have;
 		++m_num_passed;
-		m_have_pad_blocks += pad_blocks_in_piece(index);
-		TORRENT_ASSERT(m_have_pad_blocks <= num_pad_blocks());
+		m_have_pad_bytes += pad_bytes_in_piece(index);
+		TORRENT_ASSERT(m_have_pad_bytes <= num_pad_bytes());
 		p.set_have();
 		if (m_cursor == prev(m_reverse_cursor)
 			&& m_cursor == index)
@@ -1765,8 +1778,8 @@ namespace libtorrent {
 		m_dirty = false;
 		m_num_have_filtered += m_num_filtered;
 		m_num_filtered = 0;
-		m_have_filtered_pad_blocks += m_filtered_pad_blocks;
-		m_filtered_pad_blocks = 0;
+		m_have_filtered_pad_bytes += m_filtered_pad_bytes;
+		m_filtered_pad_bytes = 0;
 		m_cursor = m_piece_map.end_index();
 		m_reverse_cursor = piece_index_t{0};
 		m_num_passed = num_pieces();
@@ -1809,12 +1822,12 @@ namespace libtorrent {
 			// the piece just got filtered
 			if (p.have())
 			{
-				m_have_filtered_pad_blocks += pad_blocks_in_piece(index);
+				m_have_filtered_pad_bytes += pad_bytes_in_piece(index);
 				++m_num_have_filtered;
 			}
 			else
 			{
-				m_filtered_pad_blocks += pad_blocks_in_piece(index);
+				m_filtered_pad_bytes += pad_bytes_in_piece(index);
 				++m_num_filtered;
 
 				// update m_cursor
@@ -1848,15 +1861,15 @@ namespace libtorrent {
 			// the piece just got unfiltered
 			if (p.have())
 			{
-				TORRENT_ASSERT(m_have_filtered_pad_blocks >= pad_blocks_in_piece(index));
-				m_have_filtered_pad_blocks -= pad_blocks_in_piece(index);
+				TORRENT_ASSERT(m_have_filtered_pad_bytes >= pad_bytes_in_piece(index));
+				m_have_filtered_pad_bytes -= pad_bytes_in_piece(index);
 				TORRENT_ASSERT(m_num_have_filtered > 0);
 				--m_num_have_filtered;
 			}
 			else
 			{
-				TORRENT_ASSERT(m_filtered_pad_blocks >= pad_blocks_in_piece(index));
-				m_filtered_pad_blocks -= pad_blocks_in_piece(index);
+				TORRENT_ASSERT(m_filtered_pad_bytes >= pad_bytes_in_piece(index));
+				m_filtered_pad_bytes -= pad_bytes_in_piece(index);
 				TORRENT_ASSERT(m_num_filtered > 0);
 				--m_num_filtered;
 				// update cursors
@@ -1934,13 +1947,9 @@ namespace {
 
 		// if the availability is the same, prefer the piece that's closest to
 		// being complete.
-		int lhs_blocks_left = m_blocks_per_piece - lhs->finished - lhs->writing
-			- lhs->requested;
-		TORRENT_ASSERT(lhs_blocks_left > 0);
-		int rhs_blocks_left = m_blocks_per_piece - rhs->finished - rhs->writing
-			- rhs->requested;
-		TORRENT_ASSERT(rhs_blocks_left > 0);
-		return lhs_blocks_left < rhs_blocks_left;
+		int lhs_blocks = lhs->finished + lhs->writing + lhs->requested;
+		int rhs_blocks = rhs->finished + rhs->writing + rhs->requested;
+		return lhs_blocks > rhs_blocks;
 	}
 
 	// pieces describes which pieces the peer we're requesting from has.
@@ -1993,7 +2002,7 @@ namespace {
 		// TODO: 2 make the 2048 limit configurable
 		const int num_partials = int(m_downloads[piece_pos::piece_downloading].size());
 		if (num_partials > num_peers * 3 / 2
-			|| num_partials * m_blocks_per_piece > 2048)
+			|| num_partials * blocks_per_piece() > 2048)
 		{
 			// if we have too many partial pieces, prioritize completing
 			// them. In order for this to have an affect, also disable
@@ -2048,11 +2057,6 @@ namespace {
 			{
 				pc.inc_stats_counter(counters::piece_picker_partial_loops);
 
-				// in time critical mode, only pick high priority pieces
-				if ((options & time_critical_mode)
-					&& piece_priority(dp.index) != top_priority)
-					continue;
-
 				if (!is_piece_free(dp.index, pieces)) continue;
 
 				TORRENT_ASSERT(m_piece_map[dp.index].download_queue()
@@ -2102,11 +2106,6 @@ namespace {
 		{
 			for (piece_index_t i : suggested_pieces)
 			{
-				// in time critical mode, only pick high priority pieces
-				if ((options & time_critical_mode)
-					&& piece_priority(i) != top_priority)
-					continue;
-
 				pc.inc_stats_counter(counters::piece_picker_suggest_loops);
 				if (!is_piece_free(i, pieces)) continue;
 
@@ -2144,44 +2143,40 @@ namespace {
 				if (num_blocks <= 0) return ret;
 			}
 
-			// in time critical mode, only pick high priority pieces
-			if (!(options & time_critical_mode))
+			if (options & reverse)
 			{
-				if (options & reverse)
+				for (piece_index_t i = prev(m_reverse_cursor); i >= m_cursor; --i)
 				{
-					for (piece_index_t i = prev(m_reverse_cursor); i >= m_cursor; --i)
-					{
-						if (!is_piece_free(i, pieces)) continue;
-						// we've already added high priority pieces
-						if (piece_priority(i) == top_priority) continue;
+					if (!is_piece_free(i, pieces)) continue;
+					// we've already added high priority pieces
+					if (piece_priority(i) == top_priority) continue;
 
-						ret |= picker_log_alert::reverse_sequential;
+					ret |= picker_log_alert::reverse_sequential;
 
-						num_blocks = add_blocks(i, pieces
-							, interesting_blocks, backup_blocks
-							, backup_blocks2, num_blocks
-							, prefer_contiguous_blocks, peer, ignored_pieces
-							, options);
-						if (num_blocks <= 0) return ret;
-					}
+					num_blocks = add_blocks(i, pieces
+						, interesting_blocks, backup_blocks
+						, backup_blocks2, num_blocks
+						, prefer_contiguous_blocks, peer, ignored_pieces
+						, options);
+					if (num_blocks <= 0) return ret;
 				}
-				else
+			}
+			else
+			{
+				for (piece_index_t i = m_cursor; i < m_reverse_cursor; ++i)
 				{
-					for (piece_index_t i = m_cursor; i < m_reverse_cursor; ++i)
-					{
-						if (!is_piece_free(i, pieces)) continue;
-						// we've already added high priority pieces
-						if (piece_priority(i) == top_priority) continue;
+					if (!is_piece_free(i, pieces)) continue;
+					// we've already added high priority pieces
+					if (piece_priority(i) == top_priority) continue;
 
-						ret |= picker_log_alert::sequential_pieces;
+					ret |= picker_log_alert::sequential_pieces;
 
-						num_blocks = add_blocks(i, pieces
-							, interesting_blocks, backup_blocks
-							, backup_blocks2, num_blocks
-							, prefer_contiguous_blocks, peer, ignored_pieces
-							, options);
-						if (num_blocks <= 0) return ret;
-					}
+					num_blocks = add_blocks(i, pieces
+						, interesting_blocks, backup_blocks
+						, backup_blocks2, num_blocks
+						, prefer_contiguous_blocks, peer, ignored_pieces
+						, options);
+					if (num_blocks <= 0) return ret;
 				}
 			}
 		}
@@ -2194,7 +2189,7 @@ namespace {
 			// pieces. This is why reverse mode is disabled when we're in
 			// time-critical mode, because all high priority pieces are at the
 			// front of the list
-			if ((options & reverse) && !(options & time_critical_mode))
+			if (options & reverse)
 			{
 				for (int i = int(m_priority_boundaries.size()) - 1; i >= 0; --i)
 				{
@@ -2258,14 +2253,6 @@ namespace {
 				{
 					pc.inc_stats_counter(counters::piece_picker_rare_loops);
 
-					// in time critical mode, only pick high priority pieces
-					// it's safe to break here because in this mode we
-					// pick pieces in priority order. Once we hit a lower priority
-					// piece, we won't encounter any more high priority ones
-					if ((options & time_critical_mode)
-						&& piece_priority(i) != top_priority)
-						break;
-
 					if (!is_piece_free(i, pieces)) continue;
 
 					ret |= picker_log_alert::rarest_first;
@@ -2279,25 +2266,6 @@ namespace {
 				}
 			}
 		}
-		else if (options & time_critical_mode)
-		{
-			// if we're in time-critical mode, we are only allowed to pick
-			// high priority pieces.
-			for (auto i = m_pieces.begin();
-				i != m_pieces.end() && piece_priority(*i) == top_priority; ++i)
-			{
-				if (!is_piece_free(*i, pieces)) continue;
-
-				ret |= picker_log_alert::time_critical;
-
-				num_blocks = add_blocks(*i, pieces
-					, interesting_blocks, backup_blocks
-					, backup_blocks2, num_blocks
-					, prefer_contiguous_blocks, peer, ignored_pieces
-					, options);
-				if (num_blocks <= 0) return ret;
-			}
-		}
 		else
 		{
 			// we're not using rarest first (only for the first
@@ -2427,10 +2395,6 @@ get_out:
 		{
 			downloading_piece const& dp = *i;
 
-			if ((options & time_critical_mode)
-				&& piece_priority(dp.index) != top_priority)
-				continue;
-
 			// we either don't have this piece, or we've already requested from it
 			if (!pieces[dp.index]) continue;
 
@@ -2470,10 +2434,6 @@ get_out:
 			// don't pick pieces with priority 0
 			TORRENT_ASSERT(piece_priority(dp.index) > dont_download);
 
-			if ((options & time_critical_mode)
-				&& piece_priority(dp.index) != top_priority)
-				continue;
-
 			partials[c++] = &dp;
 		}
 
@@ -2523,10 +2483,6 @@ get_out:
 			if (piece_priority(i.index) == dont_download) continue;
 			if (i.locked) continue;
 
-			if ((options & time_critical_mode)
-				&& piece_priority(i.index) != top_priority)
-				continue;
-
 			int idx = -1;
 			for (auto const& info : blocks_for_piece(i))
 			{
@@ -2596,7 +2552,7 @@ get_out:
 		if (next(index) == m_piece_map.end_index())
 			return m_blocks_in_last_piece;
 		else
-			return m_blocks_per_piece;
+			return blocks_per_piece();
 	}
 
 	bool piece_picker::is_piece_free(piece_index_t const piece
@@ -2721,17 +2677,20 @@ get_out:
 				, num_blocks, prefer_contiguous_blocks, peer, options);
 		}
 
-		int num_blocks_in_piece = blocks_in_piece(piece);
-
 		// pick a new piece
+		int payload_blocks = blocks_in_piece(piece) - pad_bytes_in_piece(piece) / block_size();
+
 		if (prefer_contiguous_blocks == 0)
 		{
-			if (num_blocks_in_piece > num_blocks)
-				num_blocks_in_piece = num_blocks;
+			if (payload_blocks > num_blocks)
+				payload_blocks = num_blocks;
 			TORRENT_ASSERT(is_piece_free(piece, pieces));
-			for (int j = 0; j < num_blocks_in_piece; ++j)
+			for (int j = 0; j < payload_blocks; ++j)
+			{
+				TORRENT_ASSERT(j < blocks_in_piece(piece));
 				interesting_blocks.emplace_back(piece, j);
-			num_blocks -= num_blocks_in_piece;
+			}
+			num_blocks -= payload_blocks;
 		}
 		else
 		{
@@ -2749,10 +2708,11 @@ get_out:
 				ignore.push_back(k);
 
 				TORRENT_ASSERT(m_piece_map[k].priority(this) > 0);
-				num_blocks_in_piece = blocks_in_piece(k);
+				payload_blocks = blocks_in_piece(k) - pad_bytes_in_piece(k) / block_size();
 				TORRENT_ASSERT(is_piece_free(k, pieces));
-				for (int j = 0; j < num_blocks_in_piece; ++j)
+				for (int j = 0; j < payload_blocks; ++j)
 				{
+					TORRENT_ASSERT(j < blocks_in_piece(k));
 					interesting_blocks.emplace_back(k, j);
 					--num_blocks;
 					--prefer_contiguous_blocks;
@@ -2871,8 +2831,8 @@ get_out:
 
 		// round to even pieces and expand in order to get the number of
 		// contiguous pieces we want
-		int const whole_pieces = (contiguous_blocks + m_blocks_per_piece - 1)
-			/ m_blocks_per_piece;
+		int const blocks = blocks_per_piece();
+		int const whole_pieces = (contiguous_blocks + blocks - 1) / blocks;
 
 		piece_index_t start = piece;
 		piece_index_t lower_limit;
@@ -2923,7 +2883,7 @@ get_out:
 		}
 		auto const i = find_dl_piece(state, index);
 		TORRENT_ASSERT(i != m_downloads[state].end());
-		TORRENT_ASSERT(int(i->finished) <= m_blocks_per_piece);
+		TORRENT_ASSERT(int(i->finished) <= blocks_per_piece());
 		int const max_blocks = blocks_in_piece(index);
 		if (int(i->finished) + int(i->writing) < max_blocks) return false;
 		TORRENT_ASSERT(int(i->finished) + int(i->writing) == max_blocks);
@@ -3137,13 +3097,13 @@ get_out:
 
 	piece_extent_t piece_picker::extent_for(piece_index_t const p) const
 	{
-		int const extent_size = max_piece_affinity_extent / m_blocks_per_piece;
+		int const extent_size = max_piece_affinity_extent / blocks_per_piece();
 		return piece_extent_t{static_cast<int>(p) / extent_size};
 	}
 
 	index_range<piece_index_t> piece_picker::extent_for(piece_extent_t const e) const
 	{
-		int const extent_size = max_piece_affinity_extent / m_blocks_per_piece;
+		int const extent_size = max_piece_affinity_extent / blocks_per_piece();
 		int const begin = static_cast<int>(e) * extent_size;
 		int const end = std::min(begin + extent_size, num_pieces());
 		return { piece_index_t{begin}, piece_index_t{end}};
@@ -3153,7 +3113,7 @@ get_out:
 	{
 		// if a single piece is large enough, don't bother with the affinity of
 		// adjecent pieces.
-		if (m_blocks_per_piece >= max_piece_affinity_extent) return;
+		if (blocks_per_piece() >= max_piece_affinity_extent) return;
 
 		piece_extent_t const this_extent = extent_for(p);
 
@@ -3745,48 +3705,66 @@ get_out:
 #endif
 	}
 
-	void piece_picker::mark_as_pad(piece_block block)
+	void piece_picker::set_pad_bytes(piece_index_t const piece, int const bytes)
 	{
-		// if this is the first block we mark as a pad, allocate the bitfield
-		if (m_pad_blocks.empty())
-		{
-			m_pad_blocks.resize(int(m_piece_map.size() * m_blocks_per_piece));
-		}
-
-		int const block_index = static_cast<int>(block.piece_index) * m_blocks_per_piece + block.block_index;
-		TORRENT_ASSERT(block_index < m_pad_blocks.size());
-		TORRENT_ASSERT(block_index >= 0);
-		TORRENT_ASSERT(m_pad_blocks.get_bit(block_index) == false);
+		TORRENT_ASSERT(bytes <= piece_size(piece));
+		TORRENT_ASSERT(m_pads_in_piece.find(piece) == m_pads_in_piece.end());
+		// it doesn't make sense to call this with 0. All pieces have 0 pad
+		// bytes implicitly
+		TORRENT_ASSERT(bytes > 0);
+		TORRENT_ASSERT(bytes <= piece_size(piece));
 
-		m_pad_blocks.set_bit(block_index);
-		++m_num_pad_blocks;
-		TORRENT_ASSERT(m_pad_blocks.count() == m_num_pad_blocks);
+		m_num_pad_bytes += bytes;
+		m_pads_in_piece[piece] = bytes;
 
-		++m_pads_in_piece[block.piece_index];
-
-		piece_pos& p = m_piece_map[block.piece_index];
-		if (p.filtered())
+		piece_pos& p = m_piece_map[piece];
+		if (p.have())
 		{
-			++m_filtered_pad_blocks;
+			m_have_pad_bytes += bytes;
+			if (p.filtered())
+				m_have_filtered_pad_bytes += bytes;
+		}
+		else if (p.filtered())
+		{
+			m_filtered_pad_bytes += bytes;
 		}
 
 		// if we mark and entire piece as a pad file, we need to also
 		// consder that piece as "had" and increment some counters
-		int const blocks = blocks_in_piece(block.piece_index);
-		if (pad_blocks_in_piece(block.piece_index) == blocks)
+		if (piece_size(piece) == bytes)
 		{
 			// the entire piece is a pad file
-			we_have(block.piece_index);
+			we_have(piece);
 		}
 	}
 
-	int piece_picker::pad_blocks_in_piece(piece_index_t const index) const
+	int piece_picker::pad_bytes_in_piece(piece_index_t const index) const
 	{
 		auto const it = m_pads_in_piece.find(index);
 		if (it == m_pads_in_piece.end()) return 0;
 		return it->second;
 	}
 
+	int piece_picker::piece_size(piece_index_t const p) const
+	{
+		int const pieces = num_pieces();
+		if (static_cast<int>(p) != pieces - 1)
+			return m_piece_size;
+
+		std::int64_t const size_except_last
+			= (pieces - 1) * std::int64_t(m_piece_size);
+		std::int64_t const size = m_total_size - size_except_last;
+		return int(size);
+	}
+
+	int piece_picker::blocks_per_piece() const
+	{
+		int const blk_size = block_size();
+		int ret = (m_piece_size + blk_size - 1) / blk_size;
+		TORRENT_ASSERT(ret > 0);
+		return ret;
+	}
+
 	std::vector<torrent_peer*> piece_picker::get_downloaders(piece_index_t const index) const
 	{
 		std::vector<torrent_peer*> d;
@@ -3909,10 +3887,10 @@ get_out:
 	{
 		bool const want_last = piece_priority(piece_index_t(num_pieces() - 1)) != dont_download;
 		piece_count ret{ num_pieces() - m_num_filtered - m_num_have_filtered
-			, num_pad_blocks() - m_filtered_pad_blocks - m_have_filtered_pad_blocks
+			, num_pad_bytes() - m_filtered_pad_bytes - m_have_filtered_pad_bytes
 			, want_last };
 		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.last_piece == true));
-		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.pad_blocks > 0));
+		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.pad_bytes > 0));
 		TORRENT_ASSERT(!(ret.num_pieces == num_pieces() && ret.last_piece == false));
 		return ret;
 	}
@@ -3922,10 +3900,10 @@ get_out:
 		bool const have_last = have_piece(piece_index_t(num_pieces() - 1));
 		bool const want_last = piece_priority(piece_index_t(num_pieces() - 1)) != dont_download;
 		piece_count ret{ m_num_have - m_num_have_filtered
-			, m_have_pad_blocks - m_have_filtered_pad_blocks
+			, m_have_pad_bytes - m_have_filtered_pad_bytes
 			, have_last && want_last };
 		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.last_piece == true));
-		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.pad_blocks > 0));
+		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.pad_bytes > 0));
 		TORRENT_ASSERT(!(ret.num_pieces == num_pieces() && ret.last_piece == false));
 		return ret;
 	}
@@ -3934,10 +3912,10 @@ get_out:
 	{
 		bool const have_last = have_piece(piece_index_t(num_pieces() - 1));
 		piece_count ret{ m_num_have
-			, m_have_pad_blocks
+			, m_have_pad_bytes
 			, have_last };
 		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.last_piece == true));
-		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.pad_blocks > 0));
+		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.pad_bytes > 0));
 		TORRENT_ASSERT(!(ret.num_pieces == num_pieces() && ret.last_piece == false));
 		return ret;
 	}
@@ -3945,10 +3923,10 @@ get_out:
 	piece_count piece_picker::all_pieces() const
 	{
 		piece_count ret{ num_pieces()
-			, num_pad_blocks()
+			, num_pad_bytes()
 			, true};
 		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.last_piece == true));
-		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.pad_blocks > 0));
+		TORRENT_ASSERT(!(ret.num_pieces == 0 && ret.pad_bytes > 0));
 		TORRENT_ASSERT(!(ret.num_pieces == num_pieces() && ret.last_piece == false));
 		return ret;
 	}
diff -Naupr a/src/request_blocks.cpp b/src/request_blocks.cpp
--- a/src/request_blocks.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/request_blocks.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -84,8 +84,7 @@ namespace libtorrent {
 
 		// in time critical mode, only have 1 outstanding request at a time
 		// via normal requests
-		int const desired_queue_size = time_critical_mode
-			? 1 : c.desired_queue_size();
+		int const desired_queue_size = c.desired_queue_size();
 
 		int num_requests = desired_queue_size
 			- int(c.download_queue().size())
@@ -207,8 +206,7 @@ namespace libtorrent {
 		bool const dont_pick_busy_blocks
 			= ((ses.settings().get_bool(settings_pack::strict_end_game_mode)
 				&& p.get_download_queue_size() < p.num_want_left())
-				|| dq.size() + rq.size() > 0)
-				&& !time_critical_mode;
+				|| dq.size() + rq.size() > 0);
 
 		// this is filled with an interesting piece
 		// that some other peer is currently downloading
@@ -218,13 +216,6 @@ namespace libtorrent {
 		{
 			if (prefer_contiguous_blocks == 0 && num_requests <= 0) break;
 
-			if (time_critical_mode && p.piece_priority(pb.piece_index) != top_priority)
-			{
-				// assume the subsequent pieces are not prio 7 and
-				// be done
-				break;
-			}
-
 			int num_block_requests = p.num_peers(pb);
 			if (num_block_requests > 0)
 			{
diff -Naupr a/src/session_handle.cpp b/src/session_handle.cpp
--- a/src/session_handle.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/session_handle.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -399,10 +399,8 @@ namespace {
 		TORRENT_ASSERT_PRECOND(!params.save_path.empty());
 
 #if TORRENT_ABI_VERSION < 3
-		if (params.info_hashes.v1.is_all_zeros())
+		if (!params.info_hashes.has_v1() && !params.info_hashes.has_v2() && !params.ti)
 			params.info_hashes.v1 = params.info_hash;
-		if (params.info_hash.is_all_zeros())
-			params.info_hash = params.info_hashes.v1;
 #endif
 
 		// the internal torrent object keeps and mutates state in the
@@ -431,10 +429,8 @@ namespace {
 		TORRENT_ASSERT_PRECOND(!params.save_path.empty());
 
 #if TORRENT_ABI_VERSION < 3
-		if (params.info_hashes.v1.is_all_zeros())
+		if (!params.info_hashes.has_v1() && !params.info_hashes.has_v2() && !params.ti)
 			params.info_hashes.v1 = params.info_hash;
-		if (params.info_hash.is_all_zeros())
-			params.info_hash = params.info_hashes.v1;
 #endif
 
 		// the internal torrent object keeps and mutates state in the
@@ -465,10 +461,8 @@ namespace {
 		TORRENT_ASSERT_PRECOND(!params.save_path.empty());
 
 #if TORRENT_ABI_VERSION < 3
-		if (params.info_hashes.v1.is_all_zeros())
+		if (!params.info_hashes.has_v1() && !params.info_hashes.has_v2() && !params.ti)
 			params.info_hashes.v1 = params.info_hash;
-		if (params.info_hash.is_all_zeros())
-			params.info_hash = params.info_hashes.v1;
 #endif
 
 		// the internal torrent object keeps and mutates state in the
diff -Naupr a/src/session_impl.cpp b/src/session_impl.cpp
--- a/src/session_impl.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/session_impl.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -320,12 +320,16 @@ void apply_deprecated_dht_settings(setti
 
 				// we assume this listen_socket_t is local-network under some
 				// conditions, meaning we won't announce it to internet trackers
+				// if "routes" does not contain a single route to the internet,
+				// we don't use the last case. On MacOS, we can be notified of
+				// network changes *before* the routing table is updated
 				bool const local
 					= ipface.interface_address.is_loopback()
 					|| is_link_local(ipface.interface_address)
 					|| (ipface.flags & if_flags::loopback)
 					|| (!is_global(ipface.interface_address)
 						&& !(ipface.flags & if_flags::pointopoint)
+						&& has_any_internet_route(routes)
 						&& !has_internet_route(ipface.name, family(ipface.interface_address), routes));
 
 				eps.emplace_back(ipface.interface_address, uep.port, uep.device
@@ -1069,12 +1073,14 @@ bool ssl_server_name_callback(ssl::strea
 		m_lsd_announce_timer.cancel();
 
 #ifdef TORRENT_SSL_PEERS
-		for (auto& s : m_incoming_sockets)
 		{
-			s->close(ec);
-			TORRENT_ASSERT(!ec);
+			auto const sockets = std::move(m_incoming_sockets);
+			for (auto const& s : sockets)
+			{
+				s->close(ec);
+				TORRENT_ASSERT(!ec);
+			}
 		}
-		m_incoming_sockets.clear();
 #endif
 
 #if TORRENT_USE_I2P
@@ -5031,8 +5037,16 @@ namespace {
 			l.reserve(num_torrents + 1);
 		}
 
-		torrent_ptr = std::make_shared<torrent>(*this, m_paused, std::move(params));
-		torrent_ptr->set_queue_position(m_download_queue.end_index());
+		try
+		{
+			torrent_ptr = std::make_shared<torrent>(*this, m_paused, std::move(params));
+			torrent_ptr->set_queue_position(m_download_queue.end_index());
+		}
+		catch (system_error const& e)
+		{
+			ec = e.code();
+			return ret_t{ptr_t(), params.info_hashes, false};
+		}
 
 		// it's fine to copy this moved-from info_hash_t object, since its move
 		// construction is just a copy.
diff -Naupr a/src/storage_utils.cpp b/src/storage_utils.cpp
--- a/src/storage_utils.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/storage_utils.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -413,7 +413,7 @@ namespace libtorrent { namespace aux {
 	void delete_files(file_storage const& fs, std::string const& save_path
 		, std::string const& part_file_name, remove_flags_t const options, storage_error& ec)
 	{
-		if (options == session::delete_files)
+		if (options & session::delete_files)
 		{
 			// delete the files from disk
 			std::set<std::string> directories;
@@ -455,8 +455,9 @@ namespace libtorrent { namespace aux {
 			}
 		}
 
-		if (options == session::delete_files
-			|| options == session::delete_partfile)
+		// when we're deleting "files", we also delete the part file
+		if ((options & session::delete_partfile)
+			|| (options & session::delete_files))
 		{
 			error_code error;
 			remove(combine_path(save_path, part_file_name), error);
diff -Naupr a/src/torrent.cpp b/src/torrent.cpp
--- a/src/torrent.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/torrent.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -109,6 +109,7 @@ POSSIBILITY OF SUCH DAMAGE.
 #include "libtorrent/aux_/generate_peer_id.hpp"
 #include "libtorrent/aux_/announce_entry.hpp"
 #include "libtorrent/ssl.hpp"
+#include "libtorrent/aux_/apply_pad_files.hpp"
 
 #ifdef TORRENT_SSL_PEERS
 #include "libtorrent/ssl_stream.hpp"
@@ -256,7 +257,11 @@ bool is_downloading_state(int const st)
 			m_torrent_file = (p.ti ? p.ti : std::make_shared<torrent_info>(m_info_hash));
 
 		if (m_torrent_file->is_valid())
-			initialize_merkle_trees();
+		{
+			error_code ec = initialize_merkle_trees();
+			if (ec) throw system_error(ec);
+			m_size_on_disk = aux::size_on_disk(m_torrent_file->files());
+		}
 
 		// --- WEB SEEDS ---
 
@@ -1181,15 +1186,8 @@ bool is_downloading_state(int const st)
 			|| settings().get_int(settings_pack::suggest_mode)
 			== settings_pack::suggest_read_cache);
 
-		int const blocks_per_piece
-			= (m_torrent_file->piece_length() + block_size() - 1) / block_size();
-		int const blocks_in_last_piece
-			= ((m_torrent_file->total_size() % m_torrent_file->piece_length())
-			+ block_size() - 1) / block_size();
-
-		auto pp = std::make_unique<piece_picker>(blocks_per_piece
-			, blocks_in_last_piece
-			, m_torrent_file->num_pieces());
+		auto pp = std::make_unique<piece_picker>(m_torrent_file->total_size()
+			, m_torrent_file->piece_length());
 
 		if (m_have_all) pp->we_have_all();
 
@@ -1818,56 +1816,25 @@ bool is_downloading_state(int const st)
 
 			TORRENT_ASSERT(block_size() > 0);
 
-			for (auto const i : fs.file_range())
-			{
-				if (!fs.pad_file_at(i) || fs.file_size(i) == 0) continue;
+			m_padding_bytes = 0;
+			std::vector<piece_index_t> have_pieces;
 
-				peer_request pr = m_torrent_file->map_file(i, 0, int(fs.file_size(i)));
-				int off = pr.start & (block_size() - 1);
-				if (off != 0) { pr.length -= block_size() - off; pr.start += block_size() - off; }
-				TORRENT_ASSERT((pr.start & (block_size() - 1)) == 0);
-
-				int block = block_size();
-				piece_block pb(pr.piece, pr.start / block);
-				for (; pr.length >= block; pr.length -= block, ++pb.block_index)
-				{
-					if (pb.block_index == blocks_per_piece) { pb.block_index = 0; ++pb.piece_index; }
-					m_picker->mark_as_pad(pb);
-					++m_padding_blocks;
-				}
-				// ugly edge case where padfiles are not used they way they're
-				// supposed to be. i.e. added back-to back or at the end
-				if (pb.block_index == blocks_per_piece) { pb.block_index = 0; ++pb.piece_index; }
-				if (pr.length > 0 && ((next(i) != fs.end_file() && fs.pad_file_at(next(i)))
-					|| next(i) == fs.end_file()))
-				{
-					m_picker->mark_as_finished(pb, nullptr);
-				}
-			}
-
-			if (m_padding_blocks > 0)
+			aux::apply_pad_files(fs, [&](piece_index_t const piece, int const bytes)
 			{
-				// if we marked an entire piece as finished, we actually
-				// need to consider it finished
-
-				std::vector<piece_picker::downloading_piece> dq
-					= m_picker->get_download_queue();
-
-				std::vector<piece_index_t> have_pieces;
-
-				for (auto const& p : dq)
-				{
-					int const num_blocks = m_picker->blocks_in_piece(p.index);
-					if (p.finished < num_blocks) continue;
-					have_pieces.push_back(p.index);
-				}
+				m_padding_bytes += bytes;
+				if (bytes == fs.piece_size(piece))
+					have_pieces.push_back(piece);
+				m_picker->set_pad_bytes(piece, bytes);
+			});
 
-				for (auto i : have_pieces)
-				{
-					picker().piece_passed(i);
-					TORRENT_ASSERT(picker().have_piece(i));
-					we_have(i);
-				}
+			for (auto i : have_pieces)
+			{
+				// we may have this piece already, if we picked it up from
+				// resume data.
+				if (m_picker->have_piece(i)) continue;
+//				picker().piece_passed(i);
+//				TORRENT_ASSERT(picker().have_piece(i));
+				we_have(i);
 			}
 		}
 
@@ -2261,10 +2228,7 @@ bool is_downloading_state(int const st)
 // instead, just clear which pieces we have
 		if (m_picker)
 		{
-			int const blocks_per_piece = (m_torrent_file->piece_length() + block_size() - 1) / block_size();
-			int const blocks_in_last_piece = ((m_torrent_file->total_size() % m_torrent_file->piece_length())
-				+ block_size() - 1) / block_size();
-			m_picker->resize(blocks_per_piece, blocks_in_last_piece, m_torrent_file->num_pieces());
+			m_picker->resize(m_torrent_file->total_size(), m_torrent_file->piece_length());
 
 			m_file_progress.clear();
 			m_file_progress.init(picker(), m_torrent_file->files());
@@ -2356,6 +2320,19 @@ bool is_downloading_state(int const st)
 
 		for (int i = 0; i < num_outstanding; ++i)
 		{
+			if (has_picker())
+			{
+				// skip pieces we already have
+				while (m_checking_piece < m_torrent_file->end_piece()
+					&& m_picker->have_piece(m_checking_piece))
+				{
+					++m_checking_piece;
+					++m_num_checked_pieces;
+				}
+			}
+
+			if (m_checking_piece >= m_torrent_file->end_piece()) break;
+
 			auto flags = disk_interface::sequential_access | disk_interface::volatile_read;
 			if (torrent_file().info_hashes().has_v1())
 				flags |= disk_interface::v1_hash;
@@ -2497,17 +2474,25 @@ bool is_downloading_state(int const st)
 				m_picker->mark_as_finished(piece_block(piece, i), nullptr);
 		}
 
-		if (m_num_checked_pieces < m_torrent_file->end_piece())
+		if (m_checking_piece < m_torrent_file->end_piece())
 		{
-			// we're not done yet, issue another job
-			if (m_checking_piece >= m_torrent_file->end_piece())
+			// skip pieces we already have
+			while (m_picker->have_piece(m_checking_piece))
 			{
-				// actually, we already have outstanding jobs for
-				// the remaining pieces. We just need to wait for them
-				// to finish
-				return;
+				++m_checking_piece;
+				++m_num_checked_pieces;
+				if (m_checking_piece >= m_torrent_file->end_piece())
+				{
+					// actually, we already have outstanding jobs for
+					// the remaining pieces. We just need to wait for them
+					// to finish
+					break;
+				}
 			}
+		}
 
+		if (m_num_checked_pieces < m_torrent_file->end_piece())
+		{
 			// we paused the checking
 			if (!should_check_files())
 			{
@@ -2524,6 +2509,9 @@ bool is_downloading_state(int const st)
 				return;
 			}
 
+			if (m_checking_piece >= m_torrent_file->end_piece())
+				return;
+
 			auto flags = disk_interface::sequential_access | disk_interface::volatile_read;
 
 			if (torrent_file().info_hashes().has_v1())
@@ -3757,18 +3745,17 @@ namespace {
 		TORRENT_ASSERT(!(pc.num_pieces == 0 && pc.last_piece == true));
 
 		// if we have 0 pieces, we can't have any pad blocks either
-		TORRENT_ASSERT(!(pc.num_pieces == 0 && pc.pad_blocks > 0));
+		TORRENT_ASSERT(!(pc.num_pieces == 0 && pc.pad_bytes > 0));
 
 		// if we have all pieces, we must also have the last one
 		TORRENT_ASSERT(!(pc.num_pieces == fs.num_pieces() && pc.last_piece == false));
-		int const block_size = std::min(default_block_size, fs.piece_length());
 
 		// every block should not be a pad block
-		TORRENT_ASSERT(pc.pad_blocks <= std::int64_t(pc.num_pieces) * fs.piece_length() / block_size);
+		TORRENT_ASSERT(pc.pad_bytes <= std::int64_t(pc.num_pieces) * fs.piece_length());
 
 		return std::int64_t(pc.num_pieces) * fs.piece_length()
 			- (pc.last_piece ? fs.piece_length() - fs.piece_size(fs.last_piece()) : 0)
-			- std::int64_t(pc.pad_blocks) * block_size;
+			- std::int64_t(pc.pad_bytes);
 	}
 
 	// fills in total_wanted, total_wanted_done and total_done
@@ -3779,34 +3766,32 @@ namespace {
 
 		st.total_done = 0;
 		st.total_wanted_done = 0;
-		st.total_wanted = m_torrent_file->total_size();
+		st.total_wanted = m_size_on_disk;
 
-		TORRENT_ASSERT(st.total_wanted >= m_padding_blocks * default_block_size);
+		TORRENT_ASSERT(st.total_wanted <= m_torrent_file->total_size());
 		TORRENT_ASSERT(st.total_wanted >= 0);
 
 		TORRENT_ASSERT(!valid_metadata() || m_torrent_file->num_pieces() > 0);
 		if (!valid_metadata()) return;
 
-		TORRENT_ASSERT(st.total_wanted >= std::int64_t(m_torrent_file->piece_length())
-			* (m_torrent_file->num_pieces() - 1));
-
 		if (m_seed_mode || is_seed())
 		{
 			// once we're a seed and remove the piece picker, we stop tracking
 			// piece- and file priority. We consider everything as being
 			// "wanted"
-			st.total_done = m_torrent_file->total_size()
-				- m_padding_blocks * default_block_size;
-			st.total_wanted_done = st.total_done;
-			st.total_wanted = st.total_done;
+			st.total_done = m_torrent_file->total_size() - m_padding_bytes;
+			st.total_wanted_done = m_size_on_disk;
+			st.total_wanted = m_size_on_disk;
+			TORRENT_ASSERT(st.total_wanted <= st.total_done);
+			TORRENT_ASSERT(st.total_wanted_done <= st.total_wanted);
+			TORRENT_ASSERT(st.total_done <= m_torrent_file->total_size());
 			return;
 		}
 		else if (!has_picker())
 		{
 			st.total_done = 0;
 			st.total_wanted_done = 0;
-			st.total_wanted = m_torrent_file->total_size()
-				- m_padding_blocks * default_block_size;
+			st.total_wanted = m_size_on_disk;
 			return;
 		}
 
@@ -3814,8 +3799,9 @@ namespace {
 
 		file_storage const& files = m_torrent_file->files();
 
-		st.total_wanted = calc_bytes(files, m_picker->want());
-		st.total_wanted_done = calc_bytes(files, m_picker->have_want());
+		st.total_wanted = std::min(m_size_on_disk, calc_bytes(files, m_picker->want()));
+		st.total_wanted_done = std::min(m_file_progress.total_on_disk()
+			, calc_bytes(files, m_picker->have_want()));
 		st.total_done = calc_bytes(files, m_picker->have());
 		st.total = calc_bytes(files, m_picker->all_pieces());
 
@@ -3846,16 +3832,18 @@ namespace {
 			if (m_picker->have_piece(index)) continue;
 
 			TORRENT_ASSERT(i->finished + i->writing <= m_picker->blocks_in_piece(index));
-			TORRENT_ASSERT(i->finished + i->writing >= m_picker->pad_blocks_in_piece(index));
-
-			int const blocks = i->finished + i->writing - m_picker->pad_blocks_in_piece(index);
-			TORRENT_ASSERT(blocks >= 0);
 
-			auto const additional_bytes = std::int64_t(blocks) * block_size();
+			auto const additional_bytes = std::int64_t(i->finished + i->writing
+				- m_picker->pad_bytes_in_piece(index) / block_size())
+				* block_size();
+			TORRENT_ASSERT(additional_bytes >= 0);
 			st.total_done += additional_bytes;
 			if (m_picker->piece_priority(index) > dont_download)
 				st.total_wanted_done += additional_bytes;
 		}
+
+		TORRENT_ASSERT(st.total_wanted_done >= 0);
+		TORRENT_ASSERT(st.total_done >= st.total_wanted_done);
 	}
 
 	void torrent::on_piece_verified(aux::vector<sha256_hash> block_hashes
@@ -3974,10 +3962,14 @@ namespace {
 			, settings().get_int(settings_pack::max_suggest_pieces));
 	}
 
-	// this is called once we have completely downloaded piece
-	// 'index', its hash has been verified. It's also called
-	// during initial file check when we find a piece whose hash
-	// is correct
+	// this is called when either:
+	// * we have completely downloaded piece 'index' and its hash has been verified.
+	// * during initial file check when we find a piece whose hash is correct
+	// * if there's a pad-file that extends over the entire piece
+	// this function does not update the piece picker, telling it we have the
+	// piece, it just does all the torrent-level accounting that needs to
+	// happen. It may not be called twice for the same piece (if it is,
+	// file_progress will assert)
 	void torrent::we_have(piece_index_t const index)
 	{
 		TORRENT_ASSERT(is_single_thread());
@@ -4112,11 +4104,8 @@ namespace {
 		{
 			// if there was an enoent or eof error the block hashes array may be incomplete
 			// bail if we've hit the end of the valid hashes
-			if (block_hashes[i].is_all_zeros())
-			{
-				ret = false;
-				break;
-			}
+			if (block_hashes[i].is_all_zeros()) return false;
+
 			auto const result = get_hash_picker().set_block_hash(piece
 				, i * default_block_size, block_hashes[i]);
 
@@ -4128,9 +4117,12 @@ namespace {
 				// all verified ranges should always be full pieces or less
 				TORRENT_ASSERT(result.first_verified_block >= 0
 					|| (result.first_verified_block % blocks_per_piece) == 0);
-				TORRENT_ASSERT(result.num_verified <= blocks_in_piece
+				TORRENT_ASSERT(result.num_verified <= blocks_per_piece
 					|| (result.num_verified % blocks_per_piece) == 0);
 
+				// note that result.num_verified may cover pad blocks too, and
+				// so may be > blocks_in_piece
+
 				// sometimes, completing a single block may "unlock" validating
 				// multiple pieces. e.g. if we don't have the piece layer yet,
 				// but we completed the last block in the whole torrent, now we
@@ -4346,7 +4338,7 @@ namespace {
 			// request them from. For now be conservative and re-request
 			// the block without waiting for block hashes.
 
-			get_hash_picker().verify_block_hashes(index);
+			verify_block_hashes(index);
 			return;
 		}
 
@@ -7386,9 +7378,9 @@ namespace {
 		return peerinfo->connection != nullptr;
 	}
 
-	void torrent::initialize_merkle_trees()
+	error_code torrent::initialize_merkle_trees()
 	{
-		if (!info_hash().has_v2()) return;
+		if (!info_hash().has_v2()) return {};
 
 		bool valid = m_torrent_file->v2_piece_hashes_verified();
 
@@ -7412,16 +7404,20 @@ namespace {
 
 			if (!m_merkle_trees[i].load_piece_layer(piece_layer))
 			{
-				set_error(errors::torrent_invalid_piece_layer
-					, torrent_status::error_file_metadata);
-				valid = false;
 				m_merkle_trees[i] = aux::merkle_tree();
+				m_v2_piece_layers_validated = false;
+				return errors::torrent_invalid_piece_layer;
 			}
+#if TORRENT_USE_INVARIANT_CHECKS
+			if (m_hash_picker)
+				m_hash_picker->check_invariant(i);
+#endif
 		}
 
 		m_v2_piece_layers_validated = valid;
 
 		m_torrent_file->free_piece_layers();
+		return {};
 	}
 
 	bool torrent::set_metadata(span<char const> metadata_buf)
@@ -7507,9 +7503,17 @@ namespace {
 
 		m_info_hash = m_torrent_file->info_hashes();
 
+		m_size_on_disk = aux::size_on_disk(m_torrent_file->files());
+
 		m_ses.update_torrent_info_hash(shared_from_this(), old_ih);
 
-		initialize_merkle_trees();
+		ec = initialize_merkle_trees();
+		if (ec)
+		{
+			set_error(ec, torrent_status::error_file_metadata);
+			pause();
+			return false;
+		}
 
 		update_gauge();
 		update_want_tick();
@@ -8100,7 +8104,7 @@ namespace {
 			{
 				TORRENT_INCREMENT(m_iterating_connections);
 				TORRENT_ASSERT(p->associated_torrent().lock().get() == this);
-				if (p->upload_only())
+				if (p->upload_only() && p->can_disconnect(errors::torrent_finished))
 				{
 #ifndef TORRENT_DISABLE_LOGGING
 					p->peer_log(peer_log_alert::info, "SEED", "CLOSING CONNECTION");
@@ -9101,7 +9105,11 @@ namespace {
 		int seeds = 0;
 		int downloaders = 0;
 
-		if (m_complete != 0xffffff) seeds = m_complete;
+		// If we're currently seeding and using tracker supplied scrape
+		// data, we should remove ourselves from the seed count
+		int const self_seed = is_seed() && !is_paused() ? 1 : 0;
+
+		if (m_complete != 0xffffff) seeds = std::max(0, int(m_complete) - self_seed);
 		else seeds = m_peer_list ? m_peer_list->num_seeds() : 0;
 
 		if (m_incomplete != 0xffffff) downloaders = m_incomplete;
@@ -11150,7 +11158,8 @@ namespace {
 		if (flags & torrent_handle::piece_granularity)
 			return;
 
-		TORRENT_ASSERT(has_picker());
+		if (!has_picker())
+			return;
 
 		std::vector<piece_picker::downloading_piece> q = m_picker->get_download_queue();
 
diff -Naupr a/src/torrent_info.cpp b/src/torrent_info.cpp
--- a/src/torrent_info.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/torrent_info.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -1446,7 +1446,7 @@ namespace {
 	{
 		std::map<sha256_hash, string_view> piece_layers;
 
-		if (!e || e.type() != bdecode_node::dict_t)
+		if (e.type() != bdecode_node::dict_t)
 		{
 			ec = errors::torrent_missing_piece_layer;
 			return false;
@@ -1458,7 +1458,10 @@ namespace {
 			if (f.first.size() != static_cast<std::size_t>(sha256_hash::size())
 				|| f.second.type() != bdecode_node::string_t
 				|| f.second.string_length() % sha256_hash::size() != 0)
-				continue;
+			{
+				ec = errors::torrent_invalid_piece_layer;
+				return false;
+			}
 
 			piece_layers.emplace(sha256_hash(f.first), f.second.string_value());
 		}
@@ -1471,11 +1474,7 @@ namespace {
 				continue;
 
 			auto const piece_layer = piece_layers.find(orig_files().root(i));
-			if (piece_layer == piece_layers.end())
-			{
-				ec = errors::torrent_missing_piece_layer;
-				return false;
-			}
+			if (piece_layer == piece_layers.end()) continue;
 
 			int const num_pieces = orig_files().file_num_pieces(i);
 
@@ -1576,11 +1575,19 @@ namespace {
 		if (!parse_info_section(info, ec, piece_limit)) return false;
 		resolve_duplicate_filenames();
 
-		if (m_info_hash.has_v2() && !parse_piece_layers(torrent_file.dict_find_dict("piece layers"), ec))
+		if (m_info_hash.has_v2())
 		{
-			// mark the torrent as invalid
-			m_files.set_piece_length(0);
-			return false;
+			// allow torrent files without piece layers, just like we allow magnet
+			// links. However, if there are piece layers, make sure they're
+			// valid
+			bdecode_node const& e = torrent_file.dict_find_dict("piece layers");
+			if (e && !parse_piece_layers(e, ec))
+			{
+				TORRENT_ASSERT(ec);
+				// mark the torrent as invalid
+				m_files.set_piece_length(0);
+				return false;
+			}
 		}
 
 #ifndef TORRENT_DISABLE_MUTABLE_TORRENTS
diff -Naupr a/src/web_connection_base.cpp b/src/web_connection_base.cpp
--- a/src/web_connection_base.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/web_connection_base.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -92,6 +92,7 @@ namespace libtorrent {
 			m_basic_auth = base64encode(m_basic_auth);
 
 		m_server_string = m_host;
+		aux::verify_encoding(m_server_string);
 	}
 
 	int web_connection_base::timeout() const
diff -Naupr a/src/write_resume_data.cpp b/src/write_resume_data.cpp
--- a/src/write_resume_data.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/src/write_resume_data.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -42,8 +42,33 @@ POSSIBILITY OF SUCH DAMAGE.
 #include "libtorrent/aux_/numeric_cast.hpp"
 #include "libtorrent/torrent.hpp" // for default_piece_priority
 #include "libtorrent/aux_/numeric_cast.hpp" // for clamp
+#include "libtorrent/aux_/merkle.hpp" // for merkle_
 
 namespace libtorrent {
+namespace {
+	entry build_tracker_list(std::vector<std::string> const& trackers
+		, std::vector<int> const& tracker_tiers)
+	{
+		entry ret;
+		entry::list_type& tr_list = ret.list();
+		if (trackers.empty()) return ret;
+
+		tr_list.emplace_back(entry::list_type());
+		std::size_t tier = 0;
+		auto tier_it = tracker_tiers.begin();
+		for (std::string const& tr : trackers)
+		{
+			if (tier_it != tracker_tiers.end())
+				tier = aux::clamp(std::size_t(*tier_it++), std::size_t{0}, std::size_t{1024});
+
+			if (tr_list.size() <= tier)
+				tr_list.resize(tier + 1);
+
+			tr_list[tier].list().emplace_back(tr);
+		}
+		return ret;
+	}
+}
 
 	entry write_resume_data(add_torrent_params const& atp)
 	{
@@ -176,25 +201,11 @@ namespace libtorrent {
 		}
 
 		// save trackers
-		entry::list_type& tr_list = ret["trackers"].list();
-		if (!atp.trackers.empty())
-		{
-			tr_list.emplace_back(entry::list_type());
-			std::size_t tier = 0;
-			auto tier_it = atp.tracker_tiers.begin();
-			for (std::string const& tr : atp.trackers)
-			{
-				if (tier_it != atp.tracker_tiers.end())
-					tier = aux::clamp(std::size_t(*tier_it++), std::size_t{0}, std::size_t{1024});
-
-				if (tr_list.size() <= tier)
-					tr_list.resize(tier + 1);
-
-				tr_list[tier].list().emplace_back(tr);
-			}
-		}
+		ret["trackers"] = build_tracker_list(atp.trackers, atp.tracker_tiers);
 
 		// save web seeds
+		// if we removed the web seeds, make sure to record that in the resume
+		// data
 		entry::list_type& url_list = ret["url-list"].list();
 		std::copy(atp.url_seeds.begin(), atp.url_seeds.end(), std::back_inserter(url_list));
 
@@ -284,6 +295,86 @@ namespace libtorrent {
 
 		return ret;
 	}
+
+	entry write_torrent_file(add_torrent_params const& atp)
+	{
+		entry ret;
+		if (!atp.ti)
+			aux::throw_ex<system_error>(errors::torrent_missing_info);
+
+		auto const info = atp.ti->info_section();
+		ret["info"].preformatted().assign(info.data(), info.data() + info.size());
+		if (!atp.ti->comment().empty())
+			ret["comment"] = atp.ti->comment();
+		if (atp.ti->creation_date() != 0)
+			ret["creation date"] = atp.ti->creation_date();
+		if (!atp.ti->creator().empty())
+			ret["created by"] = atp.ti->creator();
+
+		if (!atp.merkle_trees.empty())
+		{
+			file_storage const& fs = atp.ti->files();
+			auto& trees = atp.merkle_trees;
+			if (int(trees.size()) != fs.num_files())
+				aux::throw_ex<system_error>(errors::torrent_missing_piece_layer);
+
+			auto& piece_layers = ret["piece layers"].dict();
+			for (file_index_t f : fs.file_range())
+			{
+				if (fs.pad_file_at(f) || fs.file_size(f) < fs.piece_length())
+					continue;
+
+				aux::merkle_tree t(fs.file_num_blocks(f)
+					, fs.piece_length() / default_block_size, fs.root_ptr(f));
+
+				auto const& tree = trees[f];
+				if (f < atp.merkle_tree_mask.end_index() && !atp.merkle_tree_mask[f].empty())
+				{
+					t.load_sparse_tree(tree, atp.merkle_tree_mask[f]);
+				}
+				else
+				{
+					t.load_tree(tree);
+				}
+
+				auto const piece_layer = t.get_piece_layer();
+				if (int(piece_layer.size()) != fs.file_num_pieces(f))
+					aux::throw_ex<system_error>(errors::torrent_invalid_piece_layer);
+
+				auto& layer = piece_layers[t.root().to_string()].string();
+
+				for (auto const& h : piece_layer)
+					layer += h.to_string();
+			}
+		}
+		else if (atp.ti->v2())
+		{
+			// we must have piece layers for v2 torrents for them to be valid
+			// .torrent files
+			aux::throw_ex<system_error>(errors::torrent_missing_piece_layer);
+		}
+
+		// save web seeds
+		if (!atp.url_seeds.empty())
+		{
+			entry::list_type& url_list = ret["url-list"].list();
+			std::copy(atp.url_seeds.begin(), atp.url_seeds.end(), std::back_inserter(url_list));
+		}
+
+		if (!atp.http_seeds.empty())
+		{
+			entry::list_type& httpseeds_list = ret["httpseeds"].list();
+			std::copy(atp.http_seeds.begin(), atp.http_seeds.end(), std::back_inserter(httpseeds_list));
+		}
+
+		// save trackers
+		if (atp.trackers.size() == 1)
+			ret["announce"] = atp.trackers.front();
+		else if (atp.trackers.size() > 1)
+			ret["announce-list"] = build_tracker_list(atp.trackers, atp.tracker_tiers);
+
+		return ret;
+	}
 
 	std::vector<char> write_resume_data_buf(add_torrent_params const& atp)
 	{
diff -Naupr a/tools/benchmark_checking.py b/tools/benchmark_checking.py
--- a/tools/benchmark_checking.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/benchmark_checking.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,104 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+import argparse
+import os
+import shutil
+import subprocess
+import sys
+
+
+def main():
+    args = parse_args()
+
+    ret = os.system('cd ../examples && b2 release %s stage_client_test stage_connection_tester'
+                    % args.toolset)
+    if ret != 0:
+        print('ERROR: build failed: %d' % ret)
+        sys.exit(1)
+
+    rm_file_or_dir(".ses_state")
+    rm_file_or_dir(".resume")
+
+    if not os.path.exists('checking_benchmark.torrent'):
+        ret = os.system('../examples/connection_tester gen-torrent -s 10000 -n 15 -t checking_benchmark.torrent')
+        if ret != 0:
+            print('ERROR: connection_tester failed: %d' % ret)
+            sys.exit(1)
+
+    if not os.path.exists('checking_benchmark'):
+        ret = os.system('../examples/connection_tester gen-data -t checking_benchmark.torrent -p .')
+        if ret != 0:
+            print('ERROR: connection_tester failed: %d' % ret)
+            sys.exit(1)
+
+    for threads in [4, 8, 16, 32, 64]:
+        run_test('%d' % threads, '--hashing_threads=%d' % threads)
+
+
+def run_test(name, client_arg):
+    output_dir = 'logs_checking_%s' % name
+
+    timing_path = os.path.join(output_dir, 'timing.txt')
+    if os.path.exists(timing_path):
+        print('file "{path}" exists, skipping test "{name}"'.format(path=timing_path, name=name))
+        return
+
+    rm_file_or_dir(output_dir)
+    try:
+        os.mkdir(output_dir)
+    except Exception:
+        pass
+
+    rm_file_or_dir(".resume")
+
+    client_cmd = ('../examples/client_test checking_benchmark.torrent '
+                  '--enable_dht=0 --enable_lsd=0 --enable_upnp=0 --enable_natpmp=0 '
+                  '-1 %s -s . -f %s/events.log --alert_mask=all'
+                  ) % (client_arg, output_dir)
+
+    client_out = open('%s/client.out' % output_dir, 'w+')
+    print('client_cmd: "{cmd}"'.format(cmd=client_cmd))
+    c = subprocess.Popen(client_cmd.split(' '), stdout=client_out, stderr=client_out, stdin=subprocess.PIPE)
+    c.wait()
+
+    client_out.close()
+
+    start_time = 0
+    end_time = 0
+    for l in open('%s/events.log' % output_dir, 'r'):
+        if 'checking_benchmark: start_checking, m_checking_piece: ' in l \
+                and start_time == 0:
+            start_time = int(l.split(' ')[0][1:-1])
+        if 'state changed to: finished' in l \
+                and start_time != 0:
+            end_time = int(l.split(' ')[0][1:-1])
+
+    print('%s: %d' % (name, end_time - start_time))
+    with open('%s/timing.txt' % output_dir, 'w+') as f:
+        f.write('%s: %d\n' % (name, end_time - start_time))
+
+
+def rm_file_or_dir(path):
+    """ Attempt to remove file or directory at path
+    """
+    try:
+        shutil.rmtree(path)
+    except Exception:
+        pass
+
+    try:
+        os.remove(path)
+    except Exception:
+        pass
+
+
+def parse_args():
+    p = argparse.ArgumentParser()
+    p.add_argument('--toolset', default="")
+
+    return p.parse_args()
+
+
+if __name__ == '__main__':
+    main()
\ Manca newline alla fine del file
diff -Naupr a/tools/clean.py b/tools/clean.py
--- a/tools/clean.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/clean.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,88 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+import os
+import shutil
+import glob
+
+
+def clean():
+    to_delete = [
+        'session_stats',
+        'libtorrent_logs*',
+        'round_trip_ms.log',
+        'dht.log',
+        'upnp.log',
+        'natpmp.log',
+        'bin',
+        'build-aux',
+        '.deps',
+        'test_tmp_*',
+        'bjam_build.*.xml',
+        '*.exe',
+        '*.pdb',
+        '*.pyd',
+        'dist',
+        'build',
+        '.libs',
+        '*.cpp.orig',
+        '*.cpp.rej',
+        '*.hpp.orig',
+        '*.hpp.rej',
+        '*.gcov',
+        '*.gcno',
+        '*.gcda',
+        'lib*.a',
+        'Jamfile.rej',
+        'Jamfile.orig',
+        '*.o',
+        '*.lo',
+        'autom4te.cache',
+        'configure',
+        'config.report',
+        'config.log',
+        '.lib',
+        'CMakeFiles',
+        'CMakeCache.txt',
+        'checking_benchmark',
+        'cpu_benchmark',
+    ]
+
+    directories = [
+        'examples',
+        'test',
+        '.',
+        'tools',
+        'src',
+        'simulation',
+        'fuzzers',
+        os.path.join('src', 'kademlia'),
+        os.path.join('include', 'libtorrent'),
+        os.path.join('include', os.path.join('libtorrent', '_aux')),
+        os.path.join('include', os.path.join('libtorrent', 'kademlia')),
+        os.path.join('bindings', 'python'),
+        os.path.join('bindings', os.path.join('python', 'src')),
+        os.path.join('bindings', 'c'),
+        os.path.join('bindings', os.path.join('c', 'src')),
+        os.path.join('simulation', 'libsimulator')
+    ]
+
+    for d in directories:
+        for f in to_delete:
+            path = os.path.join(d, f)
+            entries = glob.glob(path)
+            for p in entries:
+                try:
+                    shutil.rmtree(p)
+                    print(p)
+                except Exception as e:
+                    print(p, e)
+                    try:
+                        os.remove(p)
+                        print(p)
+                    except Exception as e:
+                        print(p, e)
+
+
+if __name__ == "__main__":
+    clean()
diff -Naupr a/tools/copyright.py b/tools/copyright.py
--- a/tools/copyright.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/copyright.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,137 @@
+#!/usr/bin/python
+
+# essentially copy pasted from http://0pointer.de/blog/projects/copyright.html
+
+from subprocess import Popen, PIPE
+from datetime import datetime
+
+
+def pretty_years(s):
+
+    li = list(s)
+    li.sort()
+
+    start = None
+    prev = None
+    r = []
+
+    for x in li:
+        if prev is None:
+            start = x
+            prev = x
+            continue
+
+        if x == prev + 1:
+            prev = x
+            continue
+
+        if prev == start:
+            r.append("%i" % prev)
+        else:
+            r.append("%i-%i" % (start, prev))
+
+        start = x
+        prev = x
+
+    if prev is not None:
+        if prev == start:
+            r.append("%i" % prev)
+        else:
+            r.append("%i-%i" % (start, prev))
+
+    return ", ".join(r)
+
+
+def order_by_year(a, b):
+
+    la = list(a[2])
+    la.sort()
+
+    lb = list(b[2])
+    lb.sort()
+
+    if la[0] < lb[0]:
+        return -1
+    elif la[0] > lb[0]:
+        return 1
+    else:
+        return 0
+
+
+author_map = {
+    'arvidn': 'Arvid Norberg',
+    'pavel.pimenov': 'Pavel Pimenov',
+    'd_komarov': 'd-komarov',
+    'Chocobo1': 'Mike Tzou',
+    'unsh': 'Un Shyam',
+    'toinetoine': 'Antoine Dahan'
+}
+
+
+def map_author(a):
+    if a in author_map:
+        return author_map[a]
+    else:
+        return a
+
+
+def get_authors(f):
+
+    print("File: %s" % f)
+
+    commits = []
+    data = {}
+
+    for ln in Popen(["git", "blame", "--incremental", f], stdout=PIPE).stdout:
+
+        if ln.startswith("filename "):
+            if len(data) > 0:
+                commits.append(data)
+            data = {}
+
+        elif ln.startswith("author "):
+            data["author"] = map_author(ln[7:].strip())
+
+        elif ln.startswith("author-mail <"):
+            data["author-mail"] = ln[12:].strip()
+
+        elif ln.startswith("author-time "):
+            data["author-time"] = ln[11:].strip()
+
+        elif ln.startswith("author-tz "):
+            data["author-tz"] = ln[9:].strip()
+
+    by_author = {}
+
+    for c in commits:
+        try:
+            if c['author'] == 'Not Committed Yet':
+                continue
+            n = by_author[c["author"]]
+        except KeyError:
+            n = (c["author"], c["author-mail"], set())
+            by_author[c["author"]] = n
+
+        # FIXME: Handle time zones properly
+        year = datetime.fromtimestamp(int(c["author-time"])).year
+
+        n[2].add(year)
+
+    for an, a in list(by_author.iteritems()):
+        for bn, b in list(by_author.iteritems()):
+            if a is b:
+                continue
+
+            if a[1] == b[1]:
+                a[2].update(b[2])
+
+                if an in by_author and bn in by_author:
+                    del by_author[bn]
+
+    copyright = list(by_author.itervalues())
+    copyright.sort(order_by_year)
+
+    ret = ''
+    for name, mail, years in copyright:
+        ret += "Copyright (c) %s, %s\n" % (pretty_years(years), name)
+    return ret
diff -Naupr a/tools/dht_flood.py b/tools/dht_flood.py
--- a/tools/dht_flood.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/dht_flood.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+import socket
+import sys
+from types import StringType, IntType, LongType, DictType, ListType, TupleType
+import random
+
+port = int(sys.argv[1])
+
+# from BitTorrent 4.3.0
+
+
+def encode_bencached(x, r):
+    r.append(x.bencoded)
+
+
+def encode_int(x, r):
+    r.extend(('i', str(x), 'e'))
+
+
+def encode_string(x, r):
+    r.extend((str(len(x)), ':', x))
+
+
+def encode_list(x, r):
+    r.append('l')
+    for i in x:
+        encode_func[type(i)](i, r)
+    r.append('e')
+
+
+def encode_dict(x, r):
+    r.append('d')
+    ilist = sorted(x.items())
+    for k, v in ilist:
+        r.extend((str(len(k)), ':', k))
+        encode_func[type(v)](v, r)
+    r.append('e')
+
+
+encode_func = {}
+encode_func[IntType] = encode_int
+encode_func[LongType] = encode_int
+encode_func[StringType] = encode_string
+encode_func[ListType] = encode_list
+encode_func[TupleType] = encode_list
+encode_func[DictType] = encode_dict
+
+
+def bencode(x):
+    r = []
+    encode_func[type(x)](x, r)
+    return ''.join(r)
+
+
+def send_dht_message(msg):
+    s.sendto(bencode(msg), 0, ('127.0.0.1', port))
+
+
+def random_key():
+    ret = ''
+    for i in range(0, 20):
+        ret += chr(random.randint(0, 255))
+    return ret
+
+
+s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+node_id = '1' * 20
+query = 'get_peers'
+
+print('test random info-hashes')
+for i in range(1, 30000):
+    send_dht_message({'a': {'id': node_id, 'info_hash': random_key()}, 'q': query, 'y': 'q', 't': '%d' % i})
+
+print('test random peer-ids')
+for i in range(1, 30000):
+    send_dht_message({'a': {'id': random_key(), 'info_hash': random_key()}, 'q': query, 'y': 'q', 't': '%d' % i})
diff -Naupr a/tools/dht_put.cpp b/tools/dht_put.cpp
--- a/tools/dht_put.cpp	2021-06-07 01:41:30.000000000 +0200
+++ b/tools/dht_put.cpp	2021-08-13 13:03:08.000000000 +0200
@@ -66,6 +66,9 @@ int main(int argc, char* argv[])
 
 namespace {
 
+bool log_pkts = false;
+bool log_dht = false;
+
 std::string to_hex(lt::span<char const> key)
 {
 	std::string out;
@@ -106,7 +109,7 @@ bool from_hex(span<char const> in, span<
 [[noreturn]] void usage()
 {
 	std::fprintf(stderr,
-		"USAGE:\ndht <command> <arg>\n\nCOMMANDS:\n"
+		"USAGE:\ndht [options] <command> <arg>\n\nCOMMANDS:\n"
 		"get <hash>                - retrieves and prints out the immutable\n"
 		"                            item stored under hash.\n"
 		"put <string>              - puts the specified string as an immutable\n"
@@ -121,6 +124,10 @@ bool from_hex(span<char const> in, span<
 		"                            and optionally specified salt\n"
 		"mget <public-key> [salt]  - get a mutable object under the specified\n"
 		"                            public key, and salt (optional)\n"
+		"\n"
+		"OPTIONS:\n"
+		"--log-packets               print DHT messages as they are sent and received\n"
+		"--log-dht                   print DHT log messages\n"
 		);
 	exit(1);
 }
@@ -128,8 +135,7 @@ bool from_hex(span<char const> in, span<
 alert* wait_for_alert(lt::session& s, int alert_type)
 {
 	alert* ret = nullptr;
-	bool found = false;
-	while (!found)
+	while (!ret)
 	{
 		s.wait_for_alert(seconds(5));
 
@@ -137,21 +143,25 @@ alert* wait_for_alert(lt::session& s, in
 		s.pop_alerts(&alerts);
 		for (auto const a : alerts)
 		{
-			if (a->type() != alert_type)
+			if (!log_pkts && !log_dht)
 			{
 				static int spinner = 0;
 				static const char anim[] = {'-', '\\', '|', '/'};
 				std::printf("\r%c", anim[spinner]);
 				std::fflush(stdout);
 				spinner = (spinner + 1) & 3;
-				//print some alerts?
-				continue;
 			}
+			if (a->type() == dht_pkt_alert::alert_type && log_pkts)
+				std::printf("%s\n", a->message().c_str());
+			else if (a->type() == dht_log_alert::alert_type && log_dht)
+				std::printf("%s\n", a->message().c_str());
+			else if (a->type() == dht_error_alert::alert_type)
+				std::printf("%s\n", a->message().c_str());
+			if (a->type() != alert_type) continue;
 			ret = a;
-			found = true;
 		}
 	}
-	std::printf("\n");
+	std::printf("\r");
 	return ret;
 }
 
@@ -228,7 +238,7 @@ lt::session_params load_dht_state()
 	std::vector<char> const state(std::istream_iterator<char>{f}
 		, std::istream_iterator<char>{});
 
-	if (f.bad())
+	if (f.bad() || state.empty())
 	{
 		std::fprintf(stderr, "failed to read .dht\n");
 		return {};
@@ -246,6 +256,21 @@ int main(int argc, char* argv[])
 
 	if (argc < 1) usage();
 
+	while (argc > 1)
+	{
+		lt::string_view const option(argv[0]);
+		if (option.substr(0, 2) != "--"_sv)
+			break;
+
+		if (option == "--log-packets"_sv)
+			log_pkts = true;
+		else if (option == "--log-dht"_sv)
+			log_dht = true;
+
+		++argv;
+		--argc;
+	}
+
 	if (argv[0] == "dump-key"_sv)
 	{
 		++argv;
diff -Naupr a/tools/gen_convenience_header.py b/tools/gen_convenience_header.py
--- a/tools/gen_convenience_header.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/gen_convenience_header.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+import os
+from pathlib import Path
+
+excludes = ['libtorrent.hpp', 'storage.hpp', 'io_service.hpp']
+
+os.remove('include/libtorrent/libtorrent.hpp')
+with open('include/libtorrent/libtorrent.hpp', 'w+') as f:
+    f.write('''
+// This header is generated by tools/gen_convenience_header.py
+
+''')
+
+    for fn in os.popen('git ls-files include/libtorrent/*.hpp include/libtorrent/kademlia/*.hpp include/libtorrent/extensions/*.hpp'):
+
+        fn = Path(fn.strip())
+
+        if fn.name in excludes: continue
+
+        f.write('#include "%s"\n' % fn.relative_to('include'))
diff -Naupr a/tools/gen_fwd.py b/tools/gen_fwd.py
--- a/tools/gen_fwd.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/gen_fwd.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,140 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+import os
+
+file_header = '''/*
+
+Copyright (c) 2017-2018, Steven Siloti
+Copyright (c) 2017-2021, Arvid Norberg
+Copyright (c) 2020, Alden Torres
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution.
+    * Neither the name of the author nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef TORRENT_FWD_HPP
+#define TORRENT_FWD_HPP
+
+#include "libtorrent/config.hpp"
+
+namespace libtorrent {
+'''
+
+file_footer = '''
+
+}
+
+namespace lt = libtorrent;
+
+#endif // TORRENT_FWD_HPP
+'''
+
+classes = os.popen(
+    r'git grep "\(TORRENT_EXPORT\|TORRENT_DEPRECATED_EXPORT\|^TORRENT_[A-Z0-9]\+_NAMESPACE\)"').read().split('\n')
+
+
+def print_classes(out, classes, keyword):
+    current_file = ''
+
+    # [(file, decl), ...]
+    classes = [(x.split(':')[0].strip(), ':'.join(x.split(':')[1:]).strip()) for x in classes]
+
+    # we only care about header files
+    # ignore the forward header itself, that's the one we're generating
+    # also ignore any header in the aux_ directory, those are private
+    classes = [x for x in classes if x[0].endswith('.hpp') and not x[0].endswith('/fwd.hpp') and '/aux_/' not in x[0]]
+
+    namespaces = ['TORRENT_VERSION_NAMESPACE_3',
+                  'TORRENT_VERSION_NAMESPACE_3_END',
+                  'TORRENT_VERSION_NAMESPACE_2',
+                  'TORRENT_VERSION_NAMESPACE_2_END',
+                  'TORRENT_CRYPTO_NAMESPACE',
+                  'TORRENT_CRYPTO_NAMESPACE_END']
+
+    # only include classes with the right kind of export
+    classes = [
+        x for x in classes if x[1] in namespaces or (
+            x[1].split(' ')[0] in [
+                'class',
+                'struct'] and x[1].split(' ')[1] == keyword)]
+
+    # collapse empty namespaces
+    classes2 = []
+    skip = 0
+    for i in range(len(classes)):
+        if skip > 0:
+            skip -= 1
+            continue
+        if classes[i][1] in namespaces \
+                and len(classes) > i + 1 \
+                and classes[i + 1][1] == ('%s_END' % classes[i][1]):
+            skip = 1
+        else:
+            classes2.append(classes[i])
+
+    classes = classes2
+
+    idx = -1
+    for line in classes:
+        idx += 1
+        this_file = line[0]
+        decl = line[1].split(' ')
+
+        content = ''
+        if this_file != current_file:
+            out.write('\n// ' + this_file + '\n')
+        current_file = this_file
+        if len(decl) > 2 and decl[0] in ['struct', 'class']:
+            decl = decl[0] + ' ' + decl[2]
+            if not decl.endswith(';'):
+                decl += ';'
+            content = decl + '\n'
+        else:
+            content = line[1] + '\n'
+
+        if 'kademlia' in this_file:
+            out.write('namespace dht {\n')
+            out.write(content)
+            out.write('}\n')
+        else:
+            out.write(content)
+
+
+os.remove('include/libtorrent/fwd.hpp')
+with open('include/libtorrent/fwd.hpp', 'w+') as f:
+    f.write(file_header)
+
+    print_classes(f, classes, 'TORRENT_EXPORT')
+
+    f.write('\n#if TORRENT_ABI_VERSION <= 2\n')
+
+    print_classes(f, classes, 'TORRENT_DEPRECATED_EXPORT')
+
+    f.write('\n#endif // TORRENT_ABI_VERSION')
+
+    f.write(file_footer)
diff -Naupr a/tools/libtorrent_lldb.py b/tools/libtorrent_lldb.py
--- a/tools/libtorrent_lldb.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/libtorrent_lldb.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,133 @@
+import lldb
+import re
+import os
+import struct
+
+# this is an LLDB pretty printer for libtorrent types. To use in LLDB run:
+#
+#   command script import tools/libtorrent_lldb.py
+#
+# or add it to your ~/.lldbinit
+
+def __lldb_init_module (debugger, dict):
+	debugger.HandleCommand("type summary add -x \"^libtorrent::digest32<.+>$\" -F " +
+		"libtorrent_lldb.print_hash -p -w libtorrent")
+	debugger.HandleCommand("type summary add -x \"^libtorrent::sha256_hash$\" -F " +
+		"libtorrent_lldb.print_hash -p -w libtorrent")
+	debugger.HandleCommand("type summary add -x \"^libtorrent::sha1_hash$\" -F " +
+		"libtorrent_lldb.print_hash -p -w libtorrent")
+	debugger.HandleCommand("type summary add -x \"^libtorrent::span<.+>$\" -F " +
+		"libtorrent_lldb.print_span -p -w libtorrent")
+	debugger.HandleCommand("type summary add -x \"^libtorrent::flags::bitfield_flag<.+>$\" -F " +
+		"libtorrent_lldb.print_flag -p -w libtorrent")
+	debugger.HandleCommand("type summary add -x \"^boost::asio::ip::basic_endpoint<.+>$\" -F " +
+		"libtorrent_lldb.print_endpoint -p -w libtorrent")
+	debugger.HandleCommand("type summary add -x \"^libtorrent::bitfield$\" -F " +
+		"libtorrent_lldb.print_bitfield -p -w libtorrent")
+	debugger.HandleCommand("type summary add -x \"^libtorrent::typed_bitfield<.+>$\" -F " +
+		"libtorrent_lldb.print_bitfield -p -w libtorrent")
+	debugger.HandleCommand("type summary add -x \"^libtorrent::aux::strong_typedef<.+>$\" -F " +
+		"libtorrent_lldb.print_strong_type -p -w libtorrent")
+	debugger.HandleCommand("type category enable libtorrent")
+
+def print_hash(valobj, internal_dict):
+
+	if valobj.GetType().IsReferenceType():
+		valobj = valobj.Dereference()
+
+	data = valobj.GetChildMemberWithName("m_number").GetData().uint8s
+	return bytes(data).hex()
+
+def print_flag(valobj, internal_dict):
+
+	if valobj.GetType().IsReferenceType():
+		valobj = valobj.Dereference()
+
+	data = valobj.GetChildMemberWithName("m_val").GetValueAsUnsigned()
+	return "({}) {:b}".format(valobj.GetType().name, data)
+
+def swap16(i):
+	return struct.unpack("<H", struct.pack(">H", i))[0]
+
+def pairs(lst):
+	for i in range(0, len(lst), 2):
+		yield lst[i:i+2]
+
+def print_endpoint(valobj, internal_dict):
+
+	if valobj.GetType().IsReferenceType():
+		valobj = valobj.Dereference()
+
+	union = valobj.GetChildMemberWithName("impl_").GetChildMemberWithName("data_")
+	family = union.GetChildMemberWithName("base").GetChildMemberWithName("sa_family").GetValueAsUnsigned()
+
+	if family == 2:
+		a = union.GetChildMemberWithName("v4").GetChildMemberWithName("sin_addr").GetData().uint8s
+		addr = ".".join([f"{b}" for b in a ])
+		p = swap16(union.GetChildMemberWithName("v4").GetChildMemberWithName("sin_port").GetValueAsUnsigned())
+		return "{}:{}".format(addr, p)
+	else:
+		a = union.GetChildMemberWithName("v6").GetChildMemberWithName("sin6_addr").GetData().uint8s
+		p = swap16(union.GetChildMemberWithName("v6").GetChildMemberWithName("sin6_port").GetValueAsUnsigned())
+		addr = ":".join(x+y for x, y in pairs(["{:02x}".format(b) for b in a]))
+		return "[{}]:{}".format(addr, p)
+
+def print_bitfield(valobj, internal_dict):
+
+	if valobj.GetType().IsReferenceType():
+		valobj = valobj.Dereference()
+
+	array = valobj.GetChildMemberWithName("m_buf").GetChildMemberWithName("__ptr_").GetChildMemberWithName("__value_")
+	size = array.Dereference().GetValueAsUnsigned()
+	ret = "size: {} bits | ".format(size)
+	for idx in range((size + 31) // 32):
+		item = array.GetChildAtIndex(idx + 1, lldb.eNoDynamicValues, True)
+		ret += ("{:0" + f"{min(size, 32)}" + "b}").format(item.GetValueAsUnsigned())
+		size -= 32
+
+	return ret
+
+def print_span(valobj, internal_dict):
+
+	if valobj.GetType().IsReferenceType():
+		valobj = valobj.Dereference()
+
+	array = valobj.GetChildMemberWithName("m_ptr")
+	size = valobj.GetChildMemberWithName("m_len").GetValueAsSigned()
+	ret = "size = {}".format(size)
+	for idx in range(size):
+		if idx == 0:
+			item = array.Dereference()
+		else:
+			item = array.GetChildAtIndex(idx, lldb.eNoDynamicValues, True)
+		ret += "\n[{}] = {}".format(idx, item.summary)
+	return ret
+
+
+def print_strong_type(valobj, internal_dict):
+
+	if valobj.GetType().IsReferenceType():
+		valobj = valobj.Dereference()
+
+	name = valobj.GetType().name
+	if "piece_index_tag" in name:
+		name = "piece_index"
+	elif "file_index_tag" in name:
+		name = "file_index"
+	elif "queue_position_tag" in name:
+		name = "queue_pos"
+	elif "piece_extent_tag" in name:
+		name = "piece_extent"
+	elif "storage_index_tag_t" in name:
+		name = "storage_index"
+	elif "disconnect_severity_tag" in name:
+		name = "disconnect_severity"
+	elif "prio_index_tag_t" in name:
+		name = "prio_index"
+	elif "port_mapping_tag" in name:
+		name = "port_mapping"
+	else:
+		name = ""
+
+	data = valobj.GetChildMemberWithName("m_val").GetValue()
+	return "({}) {}".format(name, data)
diff -Naupr a/tools/parse_lookup_log.py b/tools/parse_lookup_log.py
--- a/tools/parse_lookup_log.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/parse_lookup_log.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,131 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+# this is meant to parse the dht_lookups.log generated by parse_dht_log.py
+from __future__ import print_function
+
+import os
+
+nodes = {}
+
+
+def get_origin(n):
+    if n in nodes:
+        return list(nodes[n]['conns'])
+    else:
+        return ['0.0.0.0']
+
+
+def calculate_pos(nid, dist):
+    nid = int(nid[0:7], 16)
+
+    x = 0
+    y = 0
+    for i in range(0, 28, 2):
+        x |= (nid & (1 << i)) >> (i / 2)
+        y |= (nid & (2 << i)) >> (i / 2 + 1)
+
+# print '%d -> %d %d' % (dist, x, y)
+
+    return (x / 3, y / 3)
+
+
+def plot_nodes(nodes, frame):
+
+    try:
+        os.mkdir('dht_frames')
+    except Exception:
+        pass
+
+    out = open('dht_frames/plot-%02d.dot' % frame, 'w+')
+    edges = set()
+    print('graph swarm {', file=out)
+# print >>out, '"tl" [shape=point pos="0,0!"];'
+# print >>out, '"tr" [shape=point pos="1638,0!"];'
+# print >>out, '"ll" [shape=point pos="1638,1638!"];'
+# print >>out, '"tr" [shape=point pos="0,1638!"];'
+    for dst, n in list(nodes.items()):
+        shape = 'point'
+        if 's' in n:
+            shape = n['s']
+
+        print('"%s" [shape=%s fillcolor="%s" label="" pos="%d,%d!"];' %
+              (dst, shape, n['c'], n['p'][0], n['p'][1]), file=out)
+        for e in n['conns']:
+            if (e, dst) in edges:
+                continue
+
+            # only add an edge once to the .dot file
+            edges.add((e, dst))
+            edges.add((dst, e))
+
+            style = 'solid'
+            col = 'gray'
+            if nodes[dst]['c'] != 'white' and nodes[e]['c'] != 'white':
+                style = 'solid'
+                col = 'black'
+            print('"%s" -- "%s" [style="%s" color="%s"];' % (e, dst, style, col), file=out)
+
+    print('}', file=out)
+    out.close()
+    os.system('neato -n dht_frames/plot-%02d.dot -Tpng -o dht_frames/frame-%02d.png' % (frame, frame))
+
+
+frame = 0
+next_render_time = 100
+f = open('dht_lookups.txt')
+for line in f:
+    if line.startswith('***'):
+        break
+
+    kind = line[0:3].strip()
+    line = line[3:].strip().split(' ')
+
+    if kind == '===':
+        continue
+
+    t = int(line[0])
+    if t > next_render_time:
+        plot_nodes(nodes, frame)
+        frame += 1
+        next_render_time += 100
+        # sys.exit(0)
+
+    if kind == '<>':
+        p = calculate_pos(line[1], 0)
+        dst = '0.0.0.0'
+        if dst not in nodes:
+            nodes[dst] = {'conns': set(), 'p': p, 'c': 'blue', 's': 'circle'}
+
+        p = calculate_pos(line[2], 25)
+        dst = '255.255.255.255'
+        if dst not in nodes:
+            nodes[dst] = {'conns': set(), 'p': p, 'c': 'yellow', 's': 'circle'}
+    elif kind == '->':
+        dst = line[3]
+
+        if dst not in nodes:
+            src = get_origin(dst)
+            p = calculate_pos(line[2], int(line[1]))
+            nodes[dst] = {'conns': set(src), 'p': p, 'c': 'grey'}
+        nodes[dst]['c'] = 'grey'
+
+    elif kind == '+':
+        dst = line[3]
+        src = line[4]
+        p = calculate_pos(line[2], int(line[1]))
+        if dst not in nodes:
+            nodes[dst] = {'conns': set(), 'p': p, 'c': 'white'}
+        nodes[dst]['conns'].add(src)
+
+    elif kind == '<-':
+        dst = line[3]
+        nodes[dst]['c'] = 'green'
+    elif kind == 'x':
+        dst = line[3]
+        nodes[dst]['c'] = 'orange'
+    elif kind == 'X':
+        dst = line[3]
+        nodes[dst]['c'] = 'red'
+
+f.close()
diff -Naupr a/tools/run_benchmark.py b/tools/run_benchmark.py
--- a/tools/run_benchmark.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/run_benchmark.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,127 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+import argparse
+import os
+import time
+import shutil
+import subprocess
+import sys
+
+
+def main():
+    args = parse_args()
+
+    ret = os.system('cd ../examples && b2 profile %s stage_client_test'
+                    % args.toolset)
+    if ret != 0:
+        print('ERROR: build failed: %d' % ret)
+        sys.exit(1)
+
+    ret = os.system('cd ../examples && b2 release %s stage_connection_tester'
+                    % args.toolset)
+    if ret != 0:
+        print('ERROR: build failed: %d' % ret)
+        sys.exit(1)
+
+    rm_file_or_dir('.ses_state')
+    rm_file_or_dir('.resume')
+    rm_file_or_dir('cpu_benchmark')
+
+    if not os.path.exists('cpu_benchmark.torrent'):
+        ret = os.system('../examples/connection_tester gen-torrent -s 10000 -n 15 -t cpu_benchmark.torrent')
+        if ret != 0:
+            print('ERROR: connection_tester failed: %d' % ret)
+            sys.exit(1)
+
+    rm_file_or_dir('t')
+
+    run_test('download', 'upload', '', args.download_peers)
+    run_test('upload', 'download', '-G', args.download_peers)
+
+
+def run_test(name, test_cmd, client_arg, num_peers):
+    output_dir = 'logs_%s' % name
+
+    rm_file_or_dir(output_dir)
+    try:
+        os.mkdir(output_dir)
+    except Exception:
+        pass
+
+    port = (int(time.time()) % 50000) + 2000
+
+    rm_file_or_dir('session_stats')
+    rm_file_or_dir('session_stats_report')
+
+    start = time.time()
+    client_cmd = f'../examples/client_test -k --listen_interfaces=127.0.0.1:{port} cpu_benchmark.torrent ' + \
+        f'--disable_hash_checks=1 --enable_dht=0 --enable_lsd=0 --enable_upnp=0 --enable_natpmp=0 ' + \
+        f'-e 120 {client_arg} -O --allow_multiple_connections_per_ip=1 --connections_limit={num_peers*2} -T {num_peers*2} ' + \
+        f'-f {output_dir}/events.log --alert_mask=8747'
+
+    test_cmd = f'../examples/connection_tester {test_cmd} -c {num_peers} -d 127.0.0.1 -p {port} -t cpu_benchmark.torrent'
+
+    client_out = open('%s/client.out' % output_dir, 'w+')
+    test_out = open('%s/test.out' % output_dir, 'w+')
+    print(f'client_cmd: "{client_cmd}"')
+    c = subprocess.Popen(client_cmd.split(' '), stdout=client_out, stderr=client_out, stdin=subprocess.PIPE)
+    time.sleep(2)
+    print(f'test_cmd: "{test_cmd}"')
+    t = subprocess.Popen(test_cmd.split(' '), stdout=test_out, stderr=test_out)
+
+    t.wait()
+
+    end = time.time()
+
+    try:
+        c.communicate('q')
+    except Exception:
+        pass
+    c.wait()
+
+    client_out.close()
+    test_out.close()
+
+    print('runtime %d seconds' % (end - start))
+    print('analyzing profile...')
+    os.system('gprof ../examples/client_test >%s/gprof.out' % output_dir)
+    print('generating profile graph...')
+    try:
+        os.system('gprof2dot --strip <%s/gprof.out | dot -Tpng -o %s/cpu_profile.png' % (output_dir, output_dir))
+    except Exception:
+        print('please install gprof2dot and dot:\nsudo pip install gprof2dot\nsudo apt install graphviz')
+
+    os.system('python3 parse_session_stats.py %s/events.log' % output_dir)
+
+    try:
+        shutil.move('session_stats_report', '%s/session_stats_report' % output_dir)
+    except Exception:
+        pass
+
+
+def rm_file_or_dir(path):
+    """ Attempt to remove file or directory at path
+    """
+    try:
+        shutil.rmtree(path)
+    except Exception:
+        pass
+
+    try:
+        os.remove(path)
+    except Exception:
+        pass
+
+
+def parse_args():
+    p = argparse.ArgumentParser()
+    p.add_argument('--toolset', default="")
+    p.add_argument('--download-peers', default=50, help="Number of peers to use for upload test")
+    p.add_argument('--upload-peers', default=20, help="Number of peers to use for upload test")
+
+    return p.parse_args()
+
+
+if __name__ == '__main__':
+    main()
diff -Naupr a/tools/run_tests.sh b/tools/run_tests.sh
--- a/tools/run_tests.sh	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/run_tests.sh	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,21 @@
+set -ex
+
+cd test
+b2 -l300 link=static deprecated-functions=on,off crypto=openssl,built-in
+
+cd ../simulation
+b2 -l300 link=static
+
+cd ../examples
+b2 link=static deprecated-functions=on,off crypto=openssl
+
+cd ../tools
+b2 link=static deprecated-functions=on,off crypto=openssl
+
+cd ../docs
+make spell-check
+
+cd ../bindings/python
+b2 stage_module stage_dependencies
+LD_LIBRARY_PATH=./dependencies python3 test.py
+
diff -Naupr a/tools/sanitizer-blacklist.txt b/tools/sanitizer-blacklist.txt
--- a/tools/sanitizer-blacklist.txt	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/sanitizer-blacklist.txt	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,4 @@
+# this function relies on implicit integer truncation
+fun:_ZN5boost6detail10crc_helper*index*
+fun:_ZN3std*mersenne_twister_engine*
+
diff -Naupr a/tools/set_version.py b/tools/set_version.py
--- a/tools/set_version.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/set_version.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+import os
+import sys
+import glob
+import re
+
+version = (int(sys.argv[1]), int(sys.argv[2]), int(sys.argv[3]), int(sys.argv[4]))
+
+
+def v(version):
+    ret = ()
+    for i in version:
+        if i < 10:
+            ret = ret + (chr(ord('0') + i),)
+        else:
+            ret = ret + (chr(ord('A') + i - 10),)
+    return ret
+
+
+revision = os.popen('git log -1 --format=format:%h').read().strip()
+
+
+def substitute_file(name):
+    subst = ''
+    f = open(name)
+    for line in f:
+        if 'constexpr int version_major = ' in line and name.endswith('.hpp'):
+            line = '\tconstexpr int version_major = %d;\n' % version[0]
+        elif 'constexpr int version_minor = ' in line and name.endswith('.hpp'):
+            line = '\tconstexpr int version_minor = %d;\n' % version[1]
+        elif 'constexpr int version_tiny = ' in line and name.endswith('.hpp'):
+            line = '\tconstexpr int version_tiny = %d;\n' % version[2]
+        elif 'constexpr std::uint64_t version_revision = ' in line and name.endswith('.hpp'):
+            line = '\tconstexpr std::uint64_t version_revision = 0x%s;\n' % revision
+        elif 'constexpr char const* version_str = ' in line and name.endswith('.hpp'):
+            line = '\tconstexpr char const* version_str = "%d.%d.%d.%d";\n' \
+                % (version[0], version[1], version[2], version[3])
+        elif '#define LIBTORRENT_VERSION_MAJOR' in line and name.endswith('.hpp'):
+            line = '#define LIBTORRENT_VERSION_MAJOR %d\n' % version[0]
+        elif '#define LIBTORRENT_VERSION_MINOR' in line and name.endswith('.hpp'):
+            line = '#define LIBTORRENT_VERSION_MINOR %d\n' % version[1]
+        elif '#define LIBTORRENT_VERSION_TINY' in line and name.endswith('.hpp'):
+            line = '#define LIBTORRENT_VERSION_TINY %d\n' % version[2]
+        elif '#define LIBTORRENT_VERSION ' in line and name.endswith('.hpp'):
+            line = '#define LIBTORRENT_VERSION "%d.%d.%d.%d"\n' % (version[0], version[1], version[2], version[3])
+        elif '#define LIBTORRENT_REVISION ' in line and name.endswith('.hpp'):
+            line = '#define LIBTORRENT_REVISION "%s"\n' % revision
+        elif 'AC_INIT([libtorrent-rasterbar]' in line and name.endswith('.ac'):
+            line = 'AC_INIT([libtorrent-rasterbar],[%d.%d.%d],[arvid@libtorrent.org],\n' % (
+                version[0], version[1], version[2])
+        elif 'set (VERSION ' in line and name.endswith('.txt'):
+            line = 'set (VERSION "%d.%d.%d")\n' % (version[0], version[1], version[2])
+        elif ':Version: ' in line and (name.endswith('.rst') or name.endswith('.py')):
+            line = ':Version: %d.%d.%d\n' % (version[0], version[1], version[2])
+        elif line.startswith('VERSION = ') and name.endswith('Jamfile'):
+            line = 'VERSION = %d.%d.%d ;\n' % (version[0], version[1], version[2])
+        elif 'VERSION=' in line and name.endswith('Makefile'):
+            line = 'VERSION=%d.%d.%d\n' % (version[0], version[1], version[2])
+        elif 'version=' in line and name.endswith('setup.py'):
+            line = '    version="%d.%d.%d",\n' % (version[0], version[1], version[2])
+        elif '"-LT' in line and name.endswith('settings_pack.cpp'):
+            line = re.sub('"-LT[0-9A-Za-z]{4}-"', '"-LT%c%c%c%c-"' % v(version), line)
+
+        subst += line
+
+    f.close()
+    open(name, 'w+').write(subst)
+
+
+substitute_file('include/libtorrent/version.hpp')
+substitute_file('Makefile')
+substitute_file('CMakeLists.txt')
+substitute_file('bindings/python/setup.py')
+substitute_file('docs/gen_reference_doc.py')
+substitute_file('src/settings_pack.cpp')
+for i in glob.glob('docs/*.rst'):
+    substitute_file(i)
+substitute_file('Jamfile')
diff -Naupr a/tools/test_coverage.sh b/tools/test_coverage.sh
--- a/tools/test_coverage.sh	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/test_coverage.sh	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,137 @@
+#!/bin/bash
+
+# $1 = test_name
+# $2 = filename pattern for tested source files
+function run_test {
+
+	set -e
+	if [[ ! -f test-coverage/coverage_$1_full ]]; then
+		cd test
+		B2_ARGS='sanitize=off asserts=off invariant-checks=off link=static deprecated-functions=off debug-iterators=off test-coverage=on picker-debugging=off'
+		bjam $B2_ARGS $1 testing.execute=off
+		EXE_PATH=$(ls -d bin/$1.test/*/debug/debug-iterators-off/deprecated-functions-off/export-extra-on/link-static/test-coverage-on/threading-multi)
+
+		# force running the test
+		rm -f $EXE_PATH/$1.output
+		rm -f $EXE_PATH/$1.run
+		rm -f $EXE_PATH/$1.test
+		cd ..
+		# expand the pattern to find the path to the object files
+		OBJECT_PATH=$(ls -d bin/*/debug/debug-iterators-off/deprecated-functions-off/export-extra-on/link-static/test-coverage-on/threading-multi)
+		# clear counters from last run
+		rm -f $OBJECT_PATH/src/*.gcda
+		rm -f $OBJECT_PATH/e25519/src/*.gcda
+		rm -f test/$EXE_PATH/*.gcda
+		cd test
+		# now run the test
+		bjam $B2_ARGS $1 -l250
+		cd ..
+
+		lcov --base-directory test -d test/$EXE_PATH -d $OBJECT_PATH/src -d $OBJECT_PATH/ed25519/src -c -o test-coverage/coverage_$1_full --exclude "/usr/*" --exclude "/Applications/Xcode.app/*" --exclude "*/boost/*"
+	fi
+	lcov --extract test-coverage/coverage_$1_full "$2" -o test-coverage/coverage_$1
+
+	if [ ! -f test-coverage/coverage_all ]; then
+		cp test-coverage/coverage_$1 test-coverage/coverage_all
+	else
+		lcov --add-tracefile test-coverage/coverage_$1 --add-tracefile test-coverage/coverage_all -o test-coverage/coverage_all
+	fi
+
+	if [[ $# > 2 ]]; then
+		lcov --extract test-coverage/coverage_$1_full "$3" -o test-coverage/coverage_$1
+		lcov --add-tracefile test-coverage/coverage_$1 --add-tracefile test-coverage/coverage_all -o test-coverage/coverage_all
+	fi
+	if [[ $# > 3 ]]; then
+		lcov --extract test-coverage/coverage_$1_full "$4" -o test-coverage/coverage_$1
+		lcov --add-tracefile test-coverage/coverage_$1 --add-tracefile test-coverage/coverage_all -o test-coverage/coverage_all
+	fi
+	set +e
+}
+
+mkdir -p test-coverage
+rm -f test-coverage/coverage_all
+
+run_test test_create_torrent "*/create_torrent.*"
+run_test test_bandwidth_limiter "*/bandwidth_*.*"
+run_test test_alloca "*/alloca.hpp"
+run_test test_generate_peer_id "*/generate_peer_id.*"
+run_test test_file_progress "*/file_progress.*"
+run_test test_stack_allocator "*/stack_allocator.*"
+run_test test_linked_list "*/linked_list.*"
+run_test test_enum_net "*/enum_net.*"
+run_test test_stat_cache "*/stat_cache.*"
+run_test test_dos_blocker "*/dos_blocker.*"
+run_test test_fence "*/disk_job_fence.*"
+run_test test_settings_pack "*/settings_pack.*"
+run_test test_timestamp_history "*/timestamp_history.*"
+run_test test_merkle "*/merkle.*"
+run_test test_resolve_links "*/resolve_links.*"
+run_test test_heterogeneous_queue "*/heterogeneous_queue.*"
+run_test test_socket_io "*/socket_io.*"
+run_test test_peer_priority "*/torrent_peer.*"
+run_test test_tailqueue "*/tailqueue.*"
+run_test test_bencoding "*/entry.*" "*/bencode.*" "*/bdecode.*"
+run_test test_bdecode "*/bdecode.*"
+run_test test_io "*/io.hpp"
+run_test test_block_cache "*/block_cache.*"
+run_test test_peer_classes "*/peer_class*.*"
+run_test test_bloom_filter "*/bloom_filter.*"
+run_test test_sha1_hash "*/sha1_hash.*"
+run_test test_identify_client "*/identify_client.*"
+run_test test_packet_buffer "*/packet_buffer.*"
+run_test test_ip_voter "*/ip_voter.*"
+run_test test_bitfield "*/bitfield.*"
+run_test test_alert_manager "*/alert_manager.*"
+run_test test_alert_types "*/alert_types.*"
+run_test test_dht "*/kademlia/*"
+run_test test_piece_picker "*/piece_picker.*"
+run_test test_torrent_info "*/torrent_info.*"
+run_test test_part_file "*/part_file.*"
+run_test test_http_parser "*/http_parser.*"
+run_test test_ip_filter "*/ip_filter.*"
+run_test test_utp "*/utp_stream.*"
+run_test test_peer_list "*/peer_list.*"
+run_test test_gzip "*/gzip.cpp"
+run_test test_file_storage "*/file_storage.*"
+run_test test_storage "*/storage.*"
+run_test test_xml "*/xml_parse.*"
+run_test test_sliding_average "*/sliding_average.*"
+run_test test_string "*/escape_string.*" "*/string_util.*"
+run_test test_utf8 "*/ConvertUTF.*"
+run_test test_hasher "*/hasher.*"
+run_test test_hasher512 "*/hasher512.*"
+run_test test_span "*/span.hpp"
+run_test test_crc32 "*/crc32c.*"
+run_test test_ffs "*/ffs.cpp"
+run_test test_ed25519 "*/ed25519/src/*"
+run_test test_receive_buffer "*/receive_buffer.*"
+run_test test_magnet "*/magnet_uri.*"
+run_test test_session "*/session_impl.*" "*/session.*"
+run_test test_remove_torrent "*/session_impl.*"
+run_test test_read_piece "*/torrent.*"
+run_test test_session_params "*/session.*"
+run_test test_buffer "*/buffer.*"
+run_test test_file "*/file.*"
+run_test test_read_resume "*/read_resume_data.*" "*/write_resume_data.*"
+run_test test_resume "*/torrent.*"
+run_test test_checking "*/torrent.*"
+run_test test_pe_crypto "*/pe_crypto.*"
+run_test test_remap_files "*/file_storage.*" "*/torrent.*"
+run_test test_time_critical "*/torrent.*" "*/peer_connection.*" "*/bt_peer_connection.*"
+run_test test_pex "*/ut_pex.*"
+run_test test_checking "*/torrent.*" "*/disk_io_thread.*"
+run_test test_url_seed "*/web_peer_connection.*"
+run_test test_web_seed "*/web_peer_connection.*"
+run_test test_web_seed_redirect "*/web_peer_connection.*"
+run_test test_web_seed_socks4 "*/web_peer_connection.*"
+run_test test_web_seed_socks5 "*/web_peer_connection.*"
+run_test test_web_seed_socks5_pw "*/web_peer_connection.*"
+run_test test_web_seed_http "*/web_peer_connection.*"
+run_test test_web_seed_http_pw "*/web_peer_connection.*"
+run_test test_web_seed_chunked "*/web_peer_connection.*"
+run_test test_web_seed_ban "*/web_peer_connection.*"
+run_test test_torrent "*/torrent.*"
+run_test test_auto_unchoke "*/session_impl.*"
+
+genhtml -o test-coverage/ -t libtorrent-unit-tests --num-spaces=4 test-coverage/coverage_all
+
diff -Naupr a/tools/update_copyright.py b/tools/update_copyright.py
--- a/tools/update_copyright.py	1970-01-01 01:00:00.000000000 +0100
+++ b/tools/update_copyright.py	2021-08-13 13:03:08.000000000 +0200
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
+
+import glob
+import copyright
+import os
+
+
+def update_file(name):
+    if os.path.split(name)[1] in ['puff.cpp', 'puff.hpp', 'sha1.cpp', 'sha1.hpp', 'route.h']:
+        return
+
+    new_header = copyright.get_authors(name)
+    subst = ''
+    f = open(name)
+
+    substitution_state = 0
+    added = False
+    found = False
+    for line in f:
+        if line.strip() == '/*':
+            substitution_state += 1
+        elif substitution_state == 1:
+            if line.strip().lower().startswith('copyright'):
+                # remove the existing copyright
+                found = True
+                existing_author = line.split(',')[-1]
+                if existing_author in new_header or existing_author.strip() == 'Not Committed Yet':
+                    continue
+                print('preserving: %s' % line)
+            elif not added and found:
+                subst += new_header
+                added = True
+        elif line.strip() == '*/':
+            substitution_state += 1
+
+        subst += line
+
+    f.close()
+    open(name, 'w+').write(subst)
+
+
+for i in glob.glob('src/*.cpp') + \
+        glob.glob('include/libtorrent/*.hpp') + \
+        glob.glob('include/libtorrent/aux_/*.hpp') + \
+        glob.glob('include/libtorrent/extensions/*.hpp') + \
+        glob.glob('include/libtorrent/kademlia/*.hpp') + \
+        glob.glob('src/kademlia/*.cpp') + \
+        glob.glob('examples/*.cpp') + \
+        glob.glob('examples/*.hpp') + \
+        glob.glob('tools/*.cpp') + \
+        glob.glob('test/*.cpp') + \
+        glob.glob('test/*.hpp') + \
+        glob.glob('fuzzers/src/*.cpp') + \
+        glob.glob('fuzzers/src/*.hpp'):
+    update_file(i)
